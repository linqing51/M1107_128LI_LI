spi-davinci.c:25:#include <linux/dma-mapping.h>
spi-davinci.c:34:#include <linux/platform_data/spi-davinci.h>
spi-davinci.c:36:#define SPI_NO_RESOURCE		((resource_size_t)-1)
spi-davinci.c:150:	if (dspi->rx) {
spi-davinci.c:151:		u8 *rx = dspi->rx;
spi-davinci.c:153:		dspi->rx = rx;
spi-davinci.c:159:	if (dspi->rx) {
spi-davinci.c:160:		u16 *rx = dspi->rx;
spi-davinci.c:162:		dspi->rx = rx;
spi-davinci.c:170:	if (dspi->tx) {
spi-davinci.c:171:		const u8 *tx = dspi->tx;
spi-davinci.c:174:		dspi->tx = tx;
spi-davinci.c:183:	if (dspi->tx) {
spi-davinci.c:184:		const u16 *tx = dspi->tx;
spi-davinci.c:187:		dspi->tx = tx;
spi-davinci.c:215:	struct davinci_spi_config *spicfg = spi->controller_data;
spi-davinci.c:216:	u8 chip_sel = spi->chip_select;
spi-davinci.c:219:	dspi = spi_master_get_devdata(spi->master);
spi-davinci.c:220:	pdata = &dspi->pdata;
spi-davinci.c:223:	if (spicfg && spicfg->wdelay)
spi-davinci.c:230:	if (spi->cs_gpio >= 0) {
spi-davinci.c:232:			gpio_set_value(spi->cs_gpio, spi->mode & SPI_CS_HIGH);
spi-davinci.c:234:			gpio_set_value(spi->cs_gpio,
spi-davinci.c:235:				!(spi->mode & SPI_CS_HIGH));
spi-davinci.c:243:	iowrite16(spidat1, dspi->base + SPIDAT1 + 2);
spi-davinci.c:247: * davinci_spi_get_prescale - Calculates the correct prescale value
spi-davinci.c:262:	ret = DIV_ROUND_UP(clk_get_rate(dspi->clk), max_speed_hz) - 1;
spi-davinci.c:264:	if (ret < dspi->prescaler_limit || ret > 255)
spi-davinci.c:265:		return -EINVAL;
spi-davinci.c:271: * davinci_spi_setup_transfer - This functions will determine transfer method
spi-davinci.c:289:	dspi = spi_master_get_devdata(spi->master);
spi-davinci.c:290:	spicfg = spi->controller_data;
spi-davinci.c:295:		bits_per_word = t->bits_per_word;
spi-davinci.c:296:		hz = t->speed_hz;
spi-davinci.c:301:		bits_per_word = spi->bits_per_word;
spi-davinci.c:308:		dspi->get_rx = davinci_spi_rx_buf_u8;
spi-davinci.c:309:		dspi->get_tx = davinci_spi_tx_buf_u8;
spi-davinci.c:310:		dspi->bytes_per_word[spi->chip_select] = 1;
spi-davinci.c:312:		dspi->get_rx = davinci_spi_rx_buf_u16;
spi-davinci.c:313:		dspi->get_tx = davinci_spi_tx_buf_u16;
spi-davinci.c:314:		dspi->bytes_per_word[spi->chip_select] = 2;
spi-davinci.c:318:		hz = spi->max_speed_hz;
spi-davinci.c:328:	if (spi->mode & SPI_LSB_FIRST)
spi-davinci.c:331:	if (spi->mode & SPI_CPOL)
spi-davinci.c:334:	if (!(spi->mode & SPI_CPHA))
spi-davinci.c:341:	if (spicfg->wdelay)
spi-davinci.c:342:		spifmt |= ((spicfg->wdelay << SPIFMT_WDELAY_SHIFT)
spi-davinci.c:347:	 *  - Standard SPI mode uses 4 pins, with chipselect
spi-davinci.c:348:	 *  - 3 pin SPI is a 4 pin variant without CS (SPI_NO_CS)
spi-davinci.c:354:	 *  - 5 pin SPI variant is standard SPI plus SPI_READY
spi-davinci.c:355:	 *  - 4 pin with enable is (SPI_READY | SPI_NO_CS)
spi-davinci.c:358:	if (dspi->version == SPI_VERSION_2) {
spi-davinci.c:362:		if (spicfg->odd_parity)
spi-davinci.c:365:		if (spicfg->parity_enable)
spi-davinci.c:368:		if (spicfg->timer_disable) {
spi-davinci.c:371:			delay |= (spicfg->c2tdelay << SPIDELAY_C2TDELAY_SHIFT)
spi-davinci.c:373:			delay |= (spicfg->t2cdelay << SPIDELAY_T2CDELAY_SHIFT)
spi-davinci.c:377:		if (spi->mode & SPI_READY) {
spi-davinci.c:379:			delay |= (spicfg->t2edelay << SPIDELAY_T2EDELAY_SHIFT)
spi-davinci.c:381:			delay |= (spicfg->c2edelay << SPIDELAY_C2EDELAY_SHIFT)
spi-davinci.c:385:		iowrite32(delay, dspi->base + SPIDELAY);
spi-davinci.c:388:	iowrite32(spifmt, dspi->base + SPIFMT0);
spi-davinci.c:395:	struct davinci_spi_config *spicfg = spi->controller_data;
spi-davinci.c:396:	struct device_node *np = spi->dev.of_node;
spi-davinci.c:402:			return -ENOMEM;
spi-davinci.c:405:		if (!of_property_read_u32(np, "ti,spi-wdelay", &prop))
spi-davinci.c:406:			spicfg->wdelay = (u8)prop;
spi-davinci.c:407:		spi->controller_data = spicfg;
spi-davinci.c:414: * davinci_spi_setup - This functions will set default transfer method
spi-davinci.c:424:	struct spi_master *master = spi->master;
spi-davinci.c:425:	struct device_node *np = spi->dev.of_node;
spi-davinci.c:428:	dspi = spi_master_get_devdata(spi->master);
spi-davinci.c:429:	pdata = &dspi->pdata;
spi-davinci.c:431:	if (!(spi->mode & SPI_NO_CS)) {
spi-davinci.c:432:		if (np && (master->cs_gpios != NULL) && (spi->cs_gpio >= 0)) {
spi-davinci.c:434:				      spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
spi-davinci.c:436:		} else if (pdata->chip_sel &&
spi-davinci.c:437:			   spi->chip_select < pdata->num_chipselect &&
spi-davinci.c:438:			   pdata->chip_sel[spi->chip_select] != SPI_INTERN_CS) {
spi-davinci.c:439:			spi->cs_gpio = pdata->chip_sel[spi->chip_select];
spi-davinci.c:441:				      spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
spi-davinci.c:446:			dev_err(&spi->dev, "GPIO %d setup failed (%d)\n",
spi-davinci.c:447:				spi->cs_gpio, retval);
spi-davinci.c:452:			set_io_bits(dspi->base + SPIPC0, 1 << spi->chip_select);
spi-davinci.c:455:	if (spi->mode & SPI_READY)
spi-davinci.c:456:		set_io_bits(dspi->base + SPIPC0, SPIPC0_SPIENA_MASK);
spi-davinci.c:458:	if (spi->mode & SPI_LOOP)
spi-davinci.c:459:		set_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);
spi-davinci.c:461:		clear_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);
spi-davinci.c:468:	struct davinci_spi_config *spicfg = spi->controller_data;
spi-davinci.c:470:	spi->controller_data = NULL;
spi-davinci.c:471:	if (spi->dev.of_node)
spi-davinci.c:477:	struct device *sdev = dspi->bitbang.master->dev.parent;
spi-davinci.c:480:		dev_dbg(sdev, "SPI Time-out Error\n");
spi-davinci.c:481:		return -ETIMEDOUT;
spi-davinci.c:485:		return -EIO;
spi-davinci.c:489:		return -EIO;
spi-davinci.c:492:	if (dspi->version == SPI_VERSION_2) {
spi-davinci.c:495:			return -EIO;
spi-davinci.c:499:			return -EIO;
spi-davinci.c:503:			return -EIO;
spi-davinci.c:507:			return -EBUSY;
spi-davinci.c:515: * davinci_spi_process_events - check for and handle any SPI controller events
spi-davinci.c:525:	buf = ioread32(dspi->base + SPIBUF);
spi-davinci.c:527:	if (dspi->rcount > 0 && !(buf & SPIBUF_RXEMPTY_MASK)) {
spi-davinci.c:528:		dspi->get_rx(buf & 0xFFFF, dspi);
spi-davinci.c:529:		dspi->rcount--;
spi-davinci.c:532:	status = ioread32(dspi->base + SPIFLG);
spi-davinci.c:539:	if (dspi->wcount > 0 && !(buf & SPIBUF_TXFULL_MASK)) {
spi-davinci.c:540:		spidat1 = ioread32(dspi->base + SPIDAT1);
spi-davinci.c:541:		dspi->wcount--;
spi-davinci.c:543:		spidat1 |= 0xFFFF & dspi->get_tx(dspi);
spi-davinci.c:544:		iowrite32(spidat1, dspi->base + SPIDAT1);
spi-davinci.c:555:	dspi->rcount = 0;
spi-davinci.c:557:	if (!dspi->wcount && !dspi->rcount)
spi-davinci.c:558:		complete(&dspi->done);
spi-davinci.c:565:	dspi->wcount = 0;
spi-davinci.c:567:	if (!dspi->wcount && !dspi->rcount)
spi-davinci.c:568:		complete(&dspi->done);
spi-davinci.c:572: * davinci_spi_bufs - functions which will handle transfer data
spi-davinci.c:583:	int data_type, ret = -ENOMEM;
spi-davinci.c:592:	dspi = spi_master_get_devdata(spi->master);
spi-davinci.c:593:	pdata = &dspi->pdata;
spi-davinci.c:594:	spicfg = (struct davinci_spi_config *)spi->controller_data;
spi-davinci.c:599:	data_type = dspi->bytes_per_word[spi->chip_select];
spi-davinci.c:601:	dspi->tx = t->tx_buf;
spi-davinci.c:602:	dspi->rx = t->rx_buf;
spi-davinci.c:603:	dspi->wcount = t->len / data_type;
spi-davinci.c:604:	dspi->rcount = dspi->wcount;
spi-davinci.c:606:	spidat1 = ioread32(dspi->base + SPIDAT1);
spi-davinci.c:608:	clear_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);
spi-davinci.c:609:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);
spi-davinci.c:611:	reinit_completion(&dspi->done);
spi-davinci.c:613:	if (spicfg->io_type == SPI_IO_TYPE_INTR)
spi-davinci.c:614:		set_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);
spi-davinci.c:616:	if (spicfg->io_type != SPI_IO_TYPE_DMA) {
spi-davinci.c:618:		dspi->wcount--;
spi-davinci.c:619:		tx_data = dspi->get_tx(dspi);
spi-davinci.c:622:		iowrite32(spidat1, dspi->base + SPIDAT1);
spi-davinci.c:626:			.src_addr = (unsigned long)dspi->pbase + SPIBUF,
spi-davinci.c:632:			.dst_addr = (unsigned long)dspi->pbase + SPIDAT1,
spi-davinci.c:640:		dummy_buf = kzalloc(t->len, GFP_KERNEL);
spi-davinci.c:644:		dmaengine_slave_config(dspi->dma_rx, &dma_rx_conf);
spi-davinci.c:645:		dmaengine_slave_config(dspi->dma_tx, &dma_tx_conf);
spi-davinci.c:648:		if (!t->rx_buf)
spi-davinci.c:651:			buf = t->rx_buf;
spi-davinci.c:652:		t->rx_dma = dma_map_single(&spi->dev, buf,
spi-davinci.c:653:				t->len, DMA_FROM_DEVICE);
spi-davinci.c:654:		if (dma_mapping_error(&spi->dev, t->rx_dma)) {
spi-davinci.c:655:			ret = -EFAULT;
spi-davinci.c:658:		sg_dma_address(&sg_rx) = t->rx_dma;
spi-davinci.c:659:		sg_dma_len(&sg_rx) = t->len;
spi-davinci.c:662:		if (!t->tx_buf)
spi-davinci.c:665:			buf = (void *)t->tx_buf;
spi-davinci.c:666:		t->tx_dma = dma_map_single(&spi->dev, buf,
spi-davinci.c:667:				t->len, DMA_TO_DEVICE);
spi-davinci.c:668:		if (dma_mapping_error(&spi->dev, t->tx_dma)) {
spi-davinci.c:669:			ret = -EFAULT;
spi-davinci.c:672:		sg_dma_address(&sg_tx) = t->tx_dma;
spi-davinci.c:673:		sg_dma_len(&sg_tx) = t->len;
spi-davinci.c:675:		rxdesc = dmaengine_prep_slave_sg(dspi->dma_rx,
spi-davinci.c:681:		txdesc = dmaengine_prep_slave_sg(dspi->dma_tx,
spi-davinci.c:687:		rxdesc->callback = davinci_spi_dma_rx_callback;
spi-davinci.c:688:		rxdesc->callback_param = (void *)dspi;
spi-davinci.c:689:		txdesc->callback = davinci_spi_dma_tx_callback;
spi-davinci.c:690:		txdesc->callback_param = (void *)dspi;
spi-davinci.c:692:		if (pdata->cshold_bug)
spi-davinci.c:693:			iowrite16(spidat1 >> 16, dspi->base + SPIDAT1 + 2);
spi-davinci.c:698:		dma_async_issue_pending(dspi->dma_rx);
spi-davinci.c:699:		dma_async_issue_pending(dspi->dma_tx);
spi-davinci.c:701:		set_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);
spi-davinci.c:705:	if (spicfg->io_type != SPI_IO_TYPE_POLL) {
spi-davinci.c:706:		wait_for_completion_interruptible(&(dspi->done));
spi-davinci.c:708:		while (dspi->rcount > 0 || dspi->wcount > 0) {
spi-davinci.c:716:	clear_io_bits(dspi->base + SPIINT, SPIINT_MASKALL);
spi-davinci.c:717:	if (spicfg->io_type == SPI_IO_TYPE_DMA) {
spi-davinci.c:718:		clear_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);
spi-davinci.c:720:		dma_unmap_single(&spi->dev, t->rx_dma,
spi-davinci.c:721:				t->len, DMA_FROM_DEVICE);
spi-davinci.c:722:		dma_unmap_single(&spi->dev, t->tx_dma,
spi-davinci.c:723:				t->len, DMA_TO_DEVICE);
spi-davinci.c:727:	clear_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);
spi-davinci.c:728:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);
spi-davinci.c:737:							dev_name(&spi->dev));
spi-davinci.c:741:	if (dspi->rcount != 0 || dspi->wcount != 0) {
spi-davinci.c:742:		dev_err(&spi->dev, "SPI data transfer error\n");
spi-davinci.c:743:		return -EIO;
spi-davinci.c:746:	return t->len;
spi-davinci.c:749:	dma_unmap_single(&spi->dev, t->tx_dma, t->len, DMA_TO_DEVICE);
spi-davinci.c:751:	dma_unmap_single(&spi->dev, t->rx_dma, t->len, DMA_FROM_DEVICE);
spi-davinci.c:759: * dummy_thread_fn - dummy thread function
spi-davinci.c:772: * davinci_spi_irq - Interrupt handler for SPI Master Controller
spi-davinci.c:789:		clear_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);
spi-davinci.c:791:	if ((!dspi->rcount && !dspi->wcount) || status)
spi-davinci.c:792:		complete(&dspi->done);
spi-davinci.c:800:	struct device *sdev = dspi->bitbang.master->dev.parent;
spi-davinci.c:806:	dspi->dma_rx = dma_request_channel(mask, edma_filter_fn,
spi-davinci.c:807:					   &dspi->dma_rx_chnum);
spi-davinci.c:808:	if (!dspi->dma_rx) {
spi-davinci.c:810:		r = -ENODEV;
spi-davinci.c:814:	dspi->dma_tx = dma_request_channel(mask, edma_filter_fn,
spi-davinci.c:815:					   &dspi->dma_tx_chnum);
spi-davinci.c:816:	if (!dspi->dma_tx) {
spi-davinci.c:818:		r = -ENODEV;
spi-davinci.c:825:	dma_release_channel(dspi->dma_rx);
spi-davinci.c:855:		.compatible = "ti,dm6441-spi",
spi-davinci.c:859:		.compatible = "ti,da830-spi",
spi-davinci.c:863:		.compatible = "ti,keystone-spi",
spi-davinci.c:871: * spi_davinci_get_pdata - Get platform data from DTS binding
spi-davinci.c:882:	struct device_node *node = pdev->dev.of_node;
spi-davinci.c:888:	pdata = &dspi->pdata;
spi-davinci.c:890:	match = of_match_device(davinci_spi_of_match, &pdev->dev);
spi-davinci.c:892:		return -ENODEV;
spi-davinci.c:894:	spi_data = (struct davinci_spi_of_data *)match->data;
spi-davinci.c:896:	pdata->version = spi_data->version;
spi-davinci.c:897:	pdata->prescaler_limit = spi_data->prescaler_limit;
spi-davinci.c:901:	 * set to -ENOENT. num-cs includes internal as well as gpios.
spi-davinci.c:906:	of_property_read_u32(node, "num-cs", &num_cs);
spi-davinci.c:907:	pdata->num_chipselect = num_cs;
spi-davinci.c:908:	of_property_read_u32(node, "ti,davinci-spi-intr-line", &intr_line);
spi-davinci.c:909:	pdata->intr_line = intr_line;
spi-davinci.c:917:	return -ENODEV;
spi-davinci.c:922: * davinci_spi_probe - probe function for SPI Master Controller
spi-davinci.c:943:	master = spi_alloc_master(&pdev->dev, sizeof(struct davinci_spi));
spi-davinci.c:945:		ret = -ENOMEM;
spi-davinci.c:953:	if (dev_get_platdata(&pdev->dev)) {
spi-davinci.c:954:		pdata = dev_get_platdata(&pdev->dev);
spi-davinci.c:955:		dspi->pdata = *pdata;
spi-davinci.c:964:	pdata = &dspi->pdata;
spi-davinci.c:966:	dspi->bytes_per_word = devm_kzalloc(&pdev->dev,
spi-davinci.c:967:					    sizeof(*dspi->bytes_per_word) *
spi-davinci.c:968:					    pdata->num_chipselect, GFP_KERNEL);
spi-davinci.c:969:	if (dspi->bytes_per_word == NULL) {
spi-davinci.c:970:		ret = -ENOMEM;
spi-davinci.c:976:		ret = -ENOENT;
spi-davinci.c:980:	dspi->pbase = r->start;
spi-davinci.c:982:	dspi->base = devm_ioremap_resource(&pdev->dev, r);
spi-davinci.c:983:	if (IS_ERR(dspi->base)) {
spi-davinci.c:984:		ret = PTR_ERR(dspi->base);
spi-davinci.c:990:		ret = -EINVAL;
spi-davinci.c:993:	dspi->irq = ret;
spi-davinci.c:995:	ret = devm_request_threaded_irq(&pdev->dev, dspi->irq, davinci_spi_irq,
spi-davinci.c:996:				dummy_thread_fn, 0, dev_name(&pdev->dev), dspi);
spi-davinci.c:1000:	dspi->bitbang.master = master;
spi-davinci.c:1002:	dspi->clk = devm_clk_get(&pdev->dev, NULL);
spi-davinci.c:1003:	if (IS_ERR(dspi->clk)) {
spi-davinci.c:1004:		ret = -ENODEV;
spi-davinci.c:1007:	clk_prepare_enable(dspi->clk);
spi-davinci.c:1009:	master->dev.of_node = pdev->dev.of_node;
spi-davinci.c:1010:	master->bus_num = pdev->id;
spi-davinci.c:1011:	master->num_chipselect = pdata->num_chipselect;
spi-davinci.c:1012:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(2, 16);
spi-davinci.c:1013:	master->setup = davinci_spi_setup;
spi-davinci.c:1014:	master->cleanup = davinci_spi_cleanup;
spi-davinci.c:1016:	dspi->bitbang.chipselect = davinci_spi_chipselect;
spi-davinci.c:1017:	dspi->bitbang.setup_transfer = davinci_spi_setup_transfer;
spi-davinci.c:1018:	dspi->prescaler_limit = pdata->prescaler_limit;
spi-davinci.c:1019:	dspi->version = pdata->version;
spi-davinci.c:1021:	dspi->bitbang.flags = SPI_NO_CS | SPI_LSB_FIRST | SPI_LOOP;
spi-davinci.c:1022:	if (dspi->version == SPI_VERSION_2)
spi-davinci.c:1023:		dspi->bitbang.flags |= SPI_READY;
spi-davinci.c:1025:	if (pdev->dev.of_node) {
spi-davinci.c:1028:		for (i = 0; i < pdata->num_chipselect; i++) {
spi-davinci.c:1029:			int cs_gpio = of_get_named_gpio(pdev->dev.of_node,
spi-davinci.c:1030:							"cs-gpios", i);
spi-davinci.c:1032:			if (cs_gpio == -EPROBE_DEFER) {
spi-davinci.c:1038:				ret = devm_gpio_request(&pdev->dev, cs_gpio,
spi-davinci.c:1039:							dev_name(&pdev->dev));
spi-davinci.c:1048:		dma_rx_chan = r->start;
spi-davinci.c:1051:		dma_tx_chan = r->start;
spi-davinci.c:1053:	dspi->bitbang.txrx_bufs = davinci_spi_bufs;
spi-davinci.c:1056:		dspi->dma_rx_chnum = dma_rx_chan;
spi-davinci.c:1057:		dspi->dma_tx_chnum = dma_tx_chan;
spi-davinci.c:1063:		dev_info(&pdev->dev, "DMA: supported\n");
spi-davinci.c:1064:		dev_info(&pdev->dev, "DMA: RX channel: %pa, TX channel: %pa, event queue: %d\n",
spi-davinci.c:1066:				pdata->dma_event_q);
spi-davinci.c:1069:	dspi->get_rx = davinci_spi_rx_buf_u8;
spi-davinci.c:1070:	dspi->get_tx = davinci_spi_tx_buf_u8;
spi-davinci.c:1072:	init_completion(&dspi->done);
spi-davinci.c:1075:	iowrite32(0, dspi->base + SPIGCR0);
spi-davinci.c:1077:	iowrite32(1, dspi->base + SPIGCR0);
spi-davinci.c:1081:	iowrite32(spipc0, dspi->base + SPIPC0);
spi-davinci.c:1083:	if (pdata->intr_line)
spi-davinci.c:1084:		iowrite32(SPI_INTLVL_1, dspi->base + SPILVL);
spi-davinci.c:1086:		iowrite32(SPI_INTLVL_0, dspi->base + SPILVL);
spi-davinci.c:1088:	iowrite32(CS_DEFAULT, dspi->base + SPIDEF);
spi-davinci.c:1091:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_CLKMOD_MASK);
spi-davinci.c:1092:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_MASTER_MASK);
spi-davinci.c:1093:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);
spi-davinci.c:1095:	ret = spi_bitbang_start(&dspi->bitbang);
spi-davinci.c:1099:	dev_info(&pdev->dev, "Controller at 0x%p\n", dspi->base);
spi-davinci.c:1104:	dma_release_channel(dspi->dma_rx);
spi-davinci.c:1105:	dma_release_channel(dspi->dma_tx);
spi-davinci.c:1107:	clk_disable_unprepare(dspi->clk);
spi-davinci.c:1115: * davinci_spi_remove - remove function for SPI Master Controller
spi-davinci.c:1131:	spi_bitbang_stop(&dspi->bitbang);
spi-davinci.c:1133:	clk_disable_unprepare(dspi->clk);
spi-dln2.c:2: * Driver for the Diolan DLN-2 USB-SPI adapter
spi-dln2.c:113:	tx.port = dln2->port;
spi-dln2.c:117:		len -= sizeof(tx.wait_for_completion);
spi-dln2.c:123:	return dln2_transfer_tx(dln2->pdev, cmd, &tx, len);
spi-dln2.c:131: * Ex: cs_mask = 0x03 -> CS0 & CS1 will be selected and the next WR/RD operation
spi-dln2.c:141:	tx.port = dln2->port;
spi-dln2.c:150:	return dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_SS, &tx, sizeof(tx));
spi-dln2.c:154: * Select one CS line. The other lines will be un-selected.
spi-dln2.c:172:	tx.port = dln2->port;
spi-dln2.c:176:	return dln2_transfer_tx(dln2->pdev, cmd, &tx, sizeof(tx));
spi-dln2.c:181:	u8 cs_mask = GENMASK(dln2->master->num_chipselect - 1, 0);
spi-dln2.c:197:	tx.port = dln2->port;
spi-dln2.c:198:	ret = dln2_transfer(dln2->pdev, DLN2_SPI_GET_SS_COUNT, &tx, sizeof(tx),
spi-dln2.c:203:		return -EPROTO;
spi-dln2.c:207:	dev_dbg(&dln2->pdev->dev, "cs_num = %d\n", *cs_num);
spi-dln2.c:223:	tx.port = dln2->port;
spi-dln2.c:225:	ret = dln2_transfer(dln2->pdev, cmd, &tx, sizeof(tx), &rx, &rx_len);
spi-dln2.c:229:		return -EPROTO;
spi-dln2.c:251:	dev_dbg(&dln2->pdev->dev, "freq_min = %d, freq_max = %d\n",
spi-dln2.c:273:	tx.port = dln2->port;
spi-dln2.c:276:	ret = dln2_transfer(dln2->pdev, DLN2_SPI_SET_FREQUENCY, &tx, sizeof(tx),
spi-dln2.c:281:		return -EPROTO;
spi-dln2.c:296:	tx.port = dln2->port;
spi-dln2.c:299:	return dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_MODE, &tx, sizeof(tx));
spi-dln2.c:312:	tx.port = dln2->port;
spi-dln2.c:315:	return dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_FRAME_SIZE,
spi-dln2.c:329:	} *rx = dln2->buf;
spi-dln2.c:333:	tx.port = dln2->port;
spi-dln2.c:335:	ret = dln2_transfer(dln2->pdev, DLN2_SPI_GET_SUPPORTED_FRAME_SIZES,
spi-dln2.c:340:		return -EPROTO;
spi-dln2.c:341:	if (rx->count > ARRAY_SIZE(rx->frame_sizes))
spi-dln2.c:342:		return -EPROTO;
spi-dln2.c:345:	for (i = 0; i < rx->count; i++)
spi-dln2.c:346:		*bpw_mask |= BIT(rx->frame_sizes[i] - 1);
spi-dln2.c:348:	dev_dbg(&dln2->pdev->dev, "bpw_mask = 0x%X\n", *bpw_mask);
spi-dln2.c:370:		while (len--)
spi-dln2.c:377:		while (len--)
spi-dln2.c:403:		while (len--)
spi-dln2.c:410:		while (len--)
spi-dln2.c:429:	} __packed *tx = dln2->buf;
spi-dln2.c:435:		return -EINVAL;
spi-dln2.c:437:	tx->port = dln2->port;
spi-dln2.c:438:	tx->size = cpu_to_le16(data_len);
spi-dln2.c:439:	tx->attr = attr;
spi-dln2.c:441:	dln2_spi_copy_to_buf(tx->buf, data, data_len, dln2->bpw);
spi-dln2.c:443:	tx_len = sizeof(*tx) + data_len - DLN2_SPI_MAX_XFER_SIZE;
spi-dln2.c:444:	return dln2_transfer_tx(dln2->pdev, DLN2_SPI_WRITE, tx, tx_len);
spi-dln2.c:462:	} __packed *rx = dln2->buf;
spi-dln2.c:468:		return -EINVAL;
spi-dln2.c:470:	tx.port = dln2->port;
spi-dln2.c:474:	ret = dln2_transfer(dln2->pdev, DLN2_SPI_READ, &tx, sizeof(tx),
spi-dln2.c:478:	if (rx_len < sizeof(rx->size) + data_len)
spi-dln2.c:479:		return -EPROTO;
spi-dln2.c:480:	if (le16_to_cpu(rx->size) != data_len)
spi-dln2.c:481:		return -EPROTO;
spi-dln2.c:483:	dln2_spi_copy_from_buf(data, rx->buf, data_len, dln2->bpw);
spi-dln2.c:511:		return -EINVAL;
spi-dln2.c:514:	 * Since this is a pseudo full-duplex communication, we're perfectly
spi-dln2.c:518:	tx = dln2->buf;
spi-dln2.c:519:	rx = dln2->buf;
spi-dln2.c:521:	tx->port = dln2->port;
spi-dln2.c:522:	tx->size = cpu_to_le16(data_len);
spi-dln2.c:523:	tx->attr = attr;
spi-dln2.c:525:	dln2_spi_copy_to_buf(tx->buf, tx_data, data_len, dln2->bpw);
spi-dln2.c:527:	tx_len = sizeof(*tx) + data_len - DLN2_SPI_MAX_XFER_SIZE;
spi-dln2.c:530:	ret = dln2_transfer(dln2->pdev, DLN2_SPI_READ_WRITE, tx, tx_len,
spi-dln2.c:534:	if (rx_len < sizeof(rx->size) + data_len)
spi-dln2.c:535:		return -EPROTO;
spi-dln2.c:536:	if (le16_to_cpu(rx->size) != data_len)
spi-dln2.c:537:		return -EPROTO;
spi-dln2.c:539:	dln2_spi_copy_from_buf(rx_data, rx->buf, data_len, dln2->bpw);
spi-dln2.c:565:		offset = data_len - remaining;
spi-dln2.c:581:			return -EINVAL;
spi-dln2.c:587:		remaining -= len;
spi-dln2.c:598:	struct spi_device *spi = message->spi;
spi-dln2.c:600:	if (dln2->cs != spi->chip_select) {
spi-dln2.c:601:		ret = dln2_spi_cs_set_one(dln2, spi->chip_select);
spi-dln2.c:605:		dln2->cs = spi->chip_select;
spi-dln2.c:617:	bus_setup_change = dln2->speed != speed || dln2->mode != mode ||
spi-dln2.c:618:			   dln2->bpw != bpw;
spi-dln2.c:627:	if (dln2->speed != speed) {
spi-dln2.c:632:		dln2->speed = speed;
spi-dln2.c:635:	if (dln2->mode != mode) {
spi-dln2.c:640:		dln2->mode = mode;
spi-dln2.c:643:	if (dln2->bpw != bpw) {
spi-dln2.c:648:		dln2->bpw = bpw;
spi-dln2.c:662:	status = dln2_spi_transfer_setup(dln2, xfer->speed_hz,
spi-dln2.c:663:					 xfer->bits_per_word,
spi-dln2.c:664:					 spi->mode);
spi-dln2.c:666:		dev_err(&dln2->pdev->dev, "Cannot setup transfer\n");
spi-dln2.c:670:	if (!xfer->cs_change && !spi_transfer_is_last(master, xfer))
spi-dln2.c:673:	status = dln2_spi_rdwr(dln2, xfer->tx_buf, xfer->rx_buf,
spi-dln2.c:674:			       xfer->len, attr);
spi-dln2.c:676:		dev_err(&dln2->pdev->dev, "write/read failed!\n");
spi-dln2.c:685:	struct dln2_platform_data *pdata = dev_get_platdata(&pdev->dev);
spi-dln2.c:688:	master = spi_alloc_master(&pdev->dev, sizeof(*dln2));
spi-dln2.c:690:		return -ENOMEM;
spi-dln2.c:696:	dln2->buf = devm_kmalloc(&pdev->dev, DLN2_SPI_BUF_SIZE, GFP_KERNEL);
spi-dln2.c:697:	if (!dln2->buf) {
spi-dln2.c:698:		ret = -ENOMEM;
spi-dln2.c:702:	dln2->master = master;
spi-dln2.c:703:	dln2->pdev = pdev;
spi-dln2.c:704:	dln2->port = pdata->port;
spi-dln2.c:706:	dln2->cs = 0xff;
spi-dln2.c:707:	dln2->mode = 0xff;
spi-dln2.c:712:		dev_err(&pdev->dev, "Failed to disable SPI module\n");
spi-dln2.c:716:	ret = dln2_spi_get_cs_num(dln2, &master->num_chipselect);
spi-dln2.c:718:		dev_err(&pdev->dev, "Failed to get number of CS pins\n");
spi-dln2.c:723:				       &master->min_speed_hz,
spi-dln2.c:724:				       &master->max_speed_hz);
spi-dln2.c:726:		dev_err(&pdev->dev, "Failed to read bus min/max freqs\n");
spi-dln2.c:731:						 &master->bits_per_word_mask);
spi-dln2.c:733:		dev_err(&pdev->dev, "Failed to read supported frame sizes\n");
spi-dln2.c:739:		dev_err(&pdev->dev, "Failed to enable CS pins\n");
spi-dln2.c:743:	master->bus_num = -1;
spi-dln2.c:744:	master->mode_bits = SPI_CPOL | SPI_CPHA;
spi-dln2.c:745:	master->prepare_message = dln2_spi_prepare_message;
spi-dln2.c:746:	master->transfer_one = dln2_spi_transfer_one;
spi-dln2.c:747:	master->auto_runtime_pm = true;
spi-dln2.c:752:		dev_err(&pdev->dev, "Failed to enable SPI module\n");
spi-dln2.c:756:	pm_runtime_set_autosuspend_delay(&pdev->dev,
spi-dln2.c:758:	pm_runtime_use_autosuspend(&pdev->dev);
spi-dln2.c:759:	pm_runtime_set_active(&pdev->dev);
spi-dln2.c:760:	pm_runtime_enable(&pdev->dev);
spi-dln2.c:762:	ret = devm_spi_register_master(&pdev->dev, master);
spi-dln2.c:764:		dev_err(&pdev->dev, "Failed to register master\n");
spi-dln2.c:771:	pm_runtime_disable(&pdev->dev);
spi-dln2.c:772:	pm_runtime_set_suspended(&pdev->dev);
spi-dln2.c:775:		dev_err(&pdev->dev, "Failed to disable SPI module\n");
spi-dln2.c:787:	pm_runtime_disable(&pdev->dev);
spi-dln2.c:790:		dev_err(&pdev->dev, "Failed to disable SPI module\n");
spi-dln2.c:816:	dln2->cs = 0xff;
spi-dln2.c:817:	dln2->speed = 0;
spi-dln2.c:818:	dln2->bpw = 0;
spi-dln2.c:819:	dln2->mode = 0xff;
spi-dln2.c:870:		.name	= "dln2-spi",
spi-dln2.c:881:MODULE_ALIAS("platform:dln2-spi");
spi-dw.c:16:#include <linux/dma-mapping.h>
spi-dw.c:25:#include "spi-dw.h"
spi-dw.c:50:	struct dw_spi *dws = file->private_data;
spi-dw.c:59:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:60:			"%s registers:\n", dev_name(&dws->master->dev));
spi-dw.c:61:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:63:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:65:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:67:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:69:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:71:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:73:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:75:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:77:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:79:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:81:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:83:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:85:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:87:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:89:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:91:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:93:	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
spi-dw.c:112:	snprintf(name, 128, "dw_spi-%s", dev_name(&dws->master->dev));
spi-dw.c:113:	dws->debugfs = debugfs_create_dir(name, NULL);
spi-dw.c:114:	if (!dws->debugfs)
spi-dw.c:115:		return -ENOMEM;
spi-dw.c:118:		dws->debugfs, (void *)dws, &dw_spi_regs_ops);
spi-dw.c:124:	debugfs_remove_recursive(dws->debugfs);
spi-dw.c:140:	struct dw_spi *dws = spi_master_get_devdata(spi->master);
spi-dw.c:144:	if (chip && chip->cs_control)
spi-dw.c:145:		chip->cs_control(!enable);
spi-dw.c:148:		dw_writel(dws, DW_SPI_SER, BIT(spi->chip_select));
spi-dw.c:156:	tx_left = (dws->tx_end - dws->tx) / dws->n_bytes;
spi-dw.c:157:	tx_room = dws->fifo_len - dw_readl(dws, DW_SPI_TXFLR);
spi-dw.c:161:	 * though to use (dws->fifo_len - rxflr - txflr) as
spi-dw.c:167:	rxtx_gap =  ((dws->rx_end - dws->rx) - (dws->tx_end - dws->tx))
spi-dw.c:168:			/ dws->n_bytes;
spi-dw.c:170:	return min3(tx_left, tx_room, (u32) (dws->fifo_len - rxtx_gap));
spi-dw.c:176:	u32 rx_left = (dws->rx_end - dws->rx) / dws->n_bytes;
spi-dw.c:186:	while (max--) {
spi-dw.c:188:		if (dws->tx_end - dws->len) {
spi-dw.c:189:			if (dws->n_bytes == 1)
spi-dw.c:190:				txw = *(u8 *)(dws->tx);
spi-dw.c:192:				txw = *(u16 *)(dws->tx);
spi-dw.c:195:		dws->tx += dws->n_bytes;
spi-dw.c:204:	while (max--) {
spi-dw.c:207:		if (dws->rx_end - dws->len) {
spi-dw.c:208:			if (dws->n_bytes == 1)
spi-dw.c:209:				*(u8 *)(dws->rx) = rxw;
spi-dw.c:211:				*(u16 *)(dws->rx) = rxw;
spi-dw.c:213:		dws->rx += dws->n_bytes;
spi-dw.c:221:	dev_err(&dws->master->dev, "%s\n", msg);
spi-dw.c:222:	dws->master->cur_msg->status = -EIO;
spi-dw.c:223:	spi_finalize_current_transfer(dws->master);
spi-dw.c:238:	if (dws->rx_end == dws->rx) {
spi-dw.c:240:		spi_finalize_current_transfer(dws->master);
spi-dw.c:262:	if (!master->cur_msg) {
spi-dw.c:267:	return dws->transfer_handler(dws);
spi-dw.c:277:	} while (dws->rx_end > dws->rx);
spi-dw.c:293:	dws->dma_mapped = 0;
spi-dw.c:295:	dws->tx = (void *)transfer->tx_buf;
spi-dw.c:296:	dws->tx_end = dws->tx + transfer->len;
spi-dw.c:297:	dws->rx = transfer->rx_buf;
spi-dw.c:298:	dws->rx_end = dws->rx + transfer->len;
spi-dw.c:299:	dws->len = transfer->len;
spi-dw.c:304:	if (transfer->speed_hz != chip->speed_hz) {
spi-dw.c:306:		clk_div = (dws->max_freq / transfer->speed_hz + 1) & 0xfffe;
spi-dw.c:308:		chip->speed_hz = transfer->speed_hz;
spi-dw.c:309:		chip->clk_div = clk_div;
spi-dw.c:311:		spi_set_clk(dws, chip->clk_div);
spi-dw.c:313:	if (transfer->bits_per_word == 8) {
spi-dw.c:314:		dws->n_bytes = 1;
spi-dw.c:315:		dws->dma_width = 1;
spi-dw.c:316:	} else if (transfer->bits_per_word == 16) {
spi-dw.c:317:		dws->n_bytes = 2;
spi-dw.c:318:		dws->dma_width = 2;
spi-dw.c:320:		return -EINVAL;
spi-dw.c:323:	cr0 = (transfer->bits_per_word - 1)
spi-dw.c:324:		| (chip->type << SPI_FRF_OFFSET)
spi-dw.c:325:		| (spi->mode << SPI_MODE_OFFSET)
spi-dw.c:326:		| (chip->tmode << SPI_TMOD_OFFSET);
spi-dw.c:332:	if (chip->cs_control) {
spi-dw.c:333:		if (dws->rx && dws->tx)
spi-dw.c:334:			chip->tmode = SPI_TMOD_TR;
spi-dw.c:335:		else if (dws->rx)
spi-dw.c:336:			chip->tmode = SPI_TMOD_RO;
spi-dw.c:338:			chip->tmode = SPI_TMOD_TO;
spi-dw.c:341:		cr0 |= (chip->tmode << SPI_TMOD_OFFSET);
spi-dw.c:347:	if (master->can_dma && master->can_dma(master, spi, transfer))
spi-dw.c:348:		dws->dma_mapped = master->cur_msg_mapped;
spi-dw.c:357:	if (dws->dma_mapped) {
spi-dw.c:358:		ret = dws->dma_ops->dma_setup(dws, transfer);
spi-dw.c:363:	} else if (!chip->poll_mode) {
spi-dw.c:364:		txlevel = min_t(u16, dws->fifo_len / 2, dws->len / dws->n_bytes);
spi-dw.c:372:		dws->transfer_handler = interrupt_transfer;
spi-dw.c:377:	if (dws->dma_mapped) {
spi-dw.c:378:		ret = dws->dma_ops->dma_transfer(dws, transfer);
spi-dw.c:383:	if (chip->poll_mode)
spi-dw.c:394:	if (dws->dma_mapped)
spi-dw.c:395:		dws->dma_ops->dma_stop(dws);
spi-dw.c:412:			return -ENOMEM;
spi-dw.c:420:	chip_info = spi->controller_data;
spi-dw.c:424:		if (chip_info->cs_control)
spi-dw.c:425:			chip->cs_control = chip_info->cs_control;
spi-dw.c:427:		chip->poll_mode = chip_info->poll_mode;
spi-dw.c:428:		chip->type = chip_info->type;
spi-dw.c:431:	chip->tmode = 0; /* Tx & Rx */
spi-dw.c:433:	if (gpio_is_valid(spi->cs_gpio)) {
spi-dw.c:434:		ret = gpio_direction_output(spi->cs_gpio,
spi-dw.c:435:				!(spi->mode & SPI_CS_HIGH));
spi-dw.c:460:	if (!dws->fifo_len) {
spi-dw.c:470:		dws->fifo_len = (fifo == 1) ? 0 : fifo;
spi-dw.c:471:		dev_dbg(dev, "Detected FIFO size: %u bytes\n", dws->fifo_len);
spi-dw.c:484:		return -ENOMEM;
spi-dw.c:486:	dws->master = master;
spi-dw.c:487:	dws->type = SSI_MOTO_SPI;
spi-dw.c:488:	dws->dma_inited = 0;
spi-dw.c:489:	dws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR);
spi-dw.c:490:	snprintf(dws->name, sizeof(dws->name), "dw_spi%d", dws->bus_num);
spi-dw.c:492:	ret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED, dws->name, master);
spi-dw.c:498:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP;
spi-dw.c:499:	master->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);
spi-dw.c:500:	master->bus_num = dws->bus_num;
spi-dw.c:501:	master->num_chipselect = dws->num_cs;
spi-dw.c:502:	master->setup = dw_spi_setup;
spi-dw.c:503:	master->cleanup = dw_spi_cleanup;
spi-dw.c:504:	master->set_cs = dw_spi_set_cs;
spi-dw.c:505:	master->transfer_one = dw_spi_transfer_one;
spi-dw.c:506:	master->handle_err = dw_spi_handle_err;
spi-dw.c:507:	master->max_speed_hz = dws->max_freq;
spi-dw.c:508:	master->dev.of_node = dev->of_node;
spi-dw.c:513:	if (dws->dma_ops && dws->dma_ops->dma_init) {
spi-dw.c:514:		ret = dws->dma_ops->dma_init(dws);
spi-dw.c:517:			dws->dma_inited = 0;
spi-dw.c:519:			master->can_dma = dws->dma_ops->can_dma;
spi-dw.c:526:		dev_err(&master->dev, "problem registering spi master\n");
spi-dw.c:534:	if (dws->dma_ops && dws->dma_ops->dma_exit)
spi-dw.c:535:		dws->dma_ops->dma_exit(dws);
spi-dw.c:537:	free_irq(dws->irq, master);
spi-dw.c:548:	if (dws->dma_ops && dws->dma_ops->dma_exit)
spi-dw.c:549:		dws->dma_ops->dma_exit(dws);
spi-dw.c:553:	free_irq(dws->irq, dws->master);
spi-dw.c:561:	ret = spi_master_suspend(dws->master);
spi-dw.c:574:	spi_hw_init(&dws->master->dev, dws);
spi-dw.c:575:	ret = spi_master_resume(dws->master);
spi-dw.c:577:		dev_err(&dws->master->dev, "fail to start queue (%d)\n", ret);
.built-in.o.cmd:1:cmd_drivers/spi/built-in.o :=  arm-zlgmcu-linux-uclibcgnueabi-ld -EL    -r -o drivers/spi/built-in.o drivers/spi/spi.o drivers/spi/spi-bitbang.o drivers/spi/spi-zmp.o 
spi-oc-tiny.c:62:	return spi_master_get_devdata(sdev->master);
spi-oc-tiny.c:69:	return min(DIV_ROUND_UP(hw->freq, hz * 2), (1U << hw->baudwidth)) - 1;
spi-oc-tiny.c:76:	if (hw->gpio_cs_count > 0) {
spi-oc-tiny.c:77:		gpio_set_value(hw->gpio_cs[spi->chip_select],
spi-oc-tiny.c:78:			(spi->mode & SPI_CS_HIGH) ? is_active : !is_active);
spi-oc-tiny.c:86:	unsigned int baud = hw->baud;
spi-oc-tiny.c:89:		if (t->speed_hz && t->speed_hz != hw->speed_hz)
spi-oc-tiny.c:90:			baud = tiny_spi_baud(spi, t->speed_hz);
spi-oc-tiny.c:92:	writel(baud, hw->base + TINY_SPI_BAUD);
spi-oc-tiny.c:93:	writel(hw->mode, hw->base + TINY_SPI_CONTROL);
spi-oc-tiny.c:101:	if (spi->max_speed_hz != hw->speed_hz) {
spi-oc-tiny.c:102:		hw->speed_hz = spi->max_speed_hz;
spi-oc-tiny.c:103:		hw->baud = tiny_spi_baud(spi, hw->speed_hz);
spi-oc-tiny.c:105:	hw->mode = spi->mode & (SPI_CPOL | SPI_CPHA);
spi-oc-tiny.c:111:	while (!(readb(hw->base + TINY_SPI_STATUS) &
spi-oc-tiny.c:118:	while (!(readb(hw->base + TINY_SPI_STATUS) &
spi-oc-tiny.c:126:	const u8 *txp = t->tx_buf;
spi-oc-tiny.c:127:	u8 *rxp = t->rx_buf;
spi-oc-tiny.c:130:	if (hw->irq >= 0) {
spi-oc-tiny.c:132:		hw->len = t->len;
spi-oc-tiny.c:133:		hw->txp = t->tx_buf;
spi-oc-tiny.c:134:		hw->rxp = t->rx_buf;
spi-oc-tiny.c:135:		hw->txc = 0;
spi-oc-tiny.c:136:		hw->rxc = 0;
spi-oc-tiny.c:139:		if (t->len > 1) {
spi-oc-tiny.c:140:			writeb(hw->txp ? *hw->txp++ : 0,
spi-oc-tiny.c:141:			       hw->base + TINY_SPI_TXDATA);
spi-oc-tiny.c:142:			hw->txc++;
spi-oc-tiny.c:143:			writeb(hw->txp ? *hw->txp++ : 0,
spi-oc-tiny.c:144:			       hw->base + TINY_SPI_TXDATA);
spi-oc-tiny.c:145:			hw->txc++;
spi-oc-tiny.c:146:			writeb(TINY_SPI_STATUS_TXR, hw->base + TINY_SPI_STATUS);
spi-oc-tiny.c:148:			writeb(hw->txp ? *hw->txp++ : 0,
spi-oc-tiny.c:149:			       hw->base + TINY_SPI_TXDATA);
spi-oc-tiny.c:150:			hw->txc++;
spi-oc-tiny.c:151:			writeb(TINY_SPI_STATUS_TXE, hw->base + TINY_SPI_STATUS);
spi-oc-tiny.c:154:		wait_for_completion(&hw->done);
spi-oc-tiny.c:157:		writeb(txp ? *txp++ : 0, hw->base + TINY_SPI_TXDATA);
spi-oc-tiny.c:158:		for (i = 1; i < t->len; i++) {
spi-oc-tiny.c:159:			writeb(txp ? *txp++ : 0, hw->base + TINY_SPI_TXDATA);
spi-oc-tiny.c:161:			if (rxp || (i != t->len - 1))
spi-oc-tiny.c:164:				*rxp++ = readb(hw->base + TINY_SPI_TXDATA);
spi-oc-tiny.c:168:			*rxp++ = readb(hw->base + TINY_SPI_RXDATA);
spi-oc-tiny.c:171:	return t->len;
spi-oc-tiny.c:178:	writeb(0, hw->base + TINY_SPI_STATUS);
spi-oc-tiny.c:179:	if (hw->rxc + 1 == hw->len) {
spi-oc-tiny.c:180:		if (hw->rxp)
spi-oc-tiny.c:181:			*hw->rxp++ = readb(hw->base + TINY_SPI_RXDATA);
spi-oc-tiny.c:182:		hw->rxc++;
spi-oc-tiny.c:183:		complete(&hw->done);
spi-oc-tiny.c:185:		if (hw->rxp)
spi-oc-tiny.c:186:			*hw->rxp++ = readb(hw->base + TINY_SPI_TXDATA);
spi-oc-tiny.c:187:		hw->rxc++;
spi-oc-tiny.c:188:		if (hw->txc < hw->len) {
spi-oc-tiny.c:189:			writeb(hw->txp ? *hw->txp++ : 0,
spi-oc-tiny.c:190:			       hw->base + TINY_SPI_TXDATA);
spi-oc-tiny.c:191:			hw->txc++;
spi-oc-tiny.c:193:			       hw->base + TINY_SPI_STATUS);
spi-oc-tiny.c:196:			       hw->base + TINY_SPI_STATUS);
spi-oc-tiny.c:208:	struct device_node *np = pdev->dev.of_node;
spi-oc-tiny.c:214:	hw->gpio_cs_count = of_gpio_count(np);
spi-oc-tiny.c:215:	if (hw->gpio_cs_count > 0) {
spi-oc-tiny.c:216:		hw->gpio_cs = devm_kzalloc(&pdev->dev,
spi-oc-tiny.c:217:				hw->gpio_cs_count * sizeof(unsigned int),
spi-oc-tiny.c:219:		if (!hw->gpio_cs)
spi-oc-tiny.c:220:			return -ENOMEM;
spi-oc-tiny.c:222:	for (i = 0; i < hw->gpio_cs_count; i++) {
spi-oc-tiny.c:223:		hw->gpio_cs[i] = of_get_gpio_flags(np, i, NULL);
spi-oc-tiny.c:224:		if (hw->gpio_cs[i] < 0)
spi-oc-tiny.c:225:			return -ENODEV;
spi-oc-tiny.c:227:	hw->bitbang.master->dev.of_node = pdev->dev.of_node;
spi-oc-tiny.c:228:	if (!of_property_read_u32(np, "clock-frequency", &val))
spi-oc-tiny.c:229:		hw->freq = val;
spi-oc-tiny.c:230:	if (!of_property_read_u32(np, "baud-width", &val))
spi-oc-tiny.c:231:		hw->baudwidth = val;
spi-oc-tiny.c:243:	struct tiny_spi_platform_data *platp = dev_get_platdata(&pdev->dev);
spi-oc-tiny.c:248:	int err = -ENODEV;
spi-oc-tiny.c:250:	master = spi_alloc_master(&pdev->dev, sizeof(struct tiny_spi));
spi-oc-tiny.c:255:	master->bus_num = pdev->id;
spi-oc-tiny.c:256:	master->num_chipselect = 255;
spi-oc-tiny.c:257:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-oc-tiny.c:258:	master->setup = tiny_spi_setup;
spi-oc-tiny.c:264:	hw->bitbang.master = master;
spi-oc-tiny.c:265:	hw->bitbang.setup_transfer = tiny_spi_setup_transfer;
spi-oc-tiny.c:266:	hw->bitbang.chipselect = tiny_spi_chipselect;
spi-oc-tiny.c:267:	hw->bitbang.txrx_bufs = tiny_spi_txrx_bufs;
spi-oc-tiny.c:271:	hw->base = devm_ioremap_resource(&pdev->dev, res);
spi-oc-tiny.c:272:	if (IS_ERR(hw->base)) {
spi-oc-tiny.c:273:		err = PTR_ERR(hw->base);
spi-oc-tiny.c:277:	hw->irq = platform_get_irq(pdev, 0);
spi-oc-tiny.c:278:	if (hw->irq >= 0) {
spi-oc-tiny.c:279:		init_completion(&hw->done);
spi-oc-tiny.c:280:		err = devm_request_irq(&pdev->dev, hw->irq, tiny_spi_irq, 0,
spi-oc-tiny.c:281:				       pdev->name, hw);
spi-oc-tiny.c:287:		hw->gpio_cs_count = platp->gpio_cs_count;
spi-oc-tiny.c:288:		hw->gpio_cs = platp->gpio_cs;
spi-oc-tiny.c:289:		if (platp->gpio_cs_count && !platp->gpio_cs) {
spi-oc-tiny.c:290:			err = -EBUSY;
spi-oc-tiny.c:293:		hw->freq = platp->freq;
spi-oc-tiny.c:294:		hw->baudwidth = platp->baudwidth;
spi-oc-tiny.c:300:	for (i = 0; i < hw->gpio_cs_count; i++) {
spi-oc-tiny.c:301:		err = gpio_request(hw->gpio_cs[i], dev_name(&pdev->dev));
spi-oc-tiny.c:304:		gpio_direction_output(hw->gpio_cs[i], 1);
spi-oc-tiny.c:306:	hw->bitbang.master->num_chipselect = max(1, hw->gpio_cs_count);
spi-oc-tiny.c:309:	err = spi_bitbang_start(&hw->bitbang);
spi-oc-tiny.c:312:	dev_info(&pdev->dev, "base %p, irq %d\n", hw->base, hw->irq);
spi-oc-tiny.c:317:	while (i-- > 0)
spi-oc-tiny.c:318:		gpio_free(hw->gpio_cs[i]);
spi-oc-tiny.c:327:	struct spi_master *master = hw->bitbang.master;
spi-oc-tiny.c:330:	spi_bitbang_stop(&hw->bitbang);
spi-oc-tiny.c:331:	for (i = 0; i < hw->gpio_cs_count; i++)
spi-oc-tiny.c:332:		gpio_free(hw->gpio_cs[i]);
spi-oc-tiny.c:339:	{ .compatible = "opencores,tiny-spi-rtlsvn2", },
spi-nuc900.c:27:#include <linux/platform_data/spi-nuc900.h>
spi-nuc900.c:67:	return spi_master_get_devdata(sdev->master);
spi-nuc900.c:74:	unsigned int cs = spi->mode & SPI_CS_HIGH ? 1 : 0;
spi-nuc900.c:75:	unsigned int cpol = spi->mode & SPI_CPOL ? 1 : 0;
spi-nuc900.c:78:	spin_lock_irqsave(&hw->lock, flags);
spi-nuc900.c:80:	val = __raw_readl(hw->regs + USI_SSR);
spi-nuc900.c:92:	__raw_writel(val, hw->regs + USI_SSR);
spi-nuc900.c:94:	val = __raw_readl(hw->regs + USI_CNT);
spi-nuc900.c:101:	__raw_writel(val, hw->regs + USI_CNT);
spi-nuc900.c:103:	spin_unlock_irqrestore(&hw->lock, flags);
spi-nuc900.c:124:	spin_lock_irqsave(&hw->lock, flags);
spi-nuc900.c:126:	val = __raw_readl(hw->regs + USI_CNT) & ~TXNUM;
spi-nuc900.c:131:	__raw_writel(val, hw->regs + USI_CNT);
spi-nuc900.c:133:	spin_unlock_irqrestore(&hw->lock, flags);
spi-nuc900.c:143:	spin_lock_irqsave(&hw->lock, flags);
spi-nuc900.c:145:	val = __raw_readl(hw->regs + USI_CNT) & ~TXBITLEN;
spi-nuc900.c:149:	__raw_writel(val, hw->regs + USI_CNT);
spi-nuc900.c:151:	spin_unlock_irqrestore(&hw->lock, flags);
spi-nuc900.c:159:	spin_lock_irqsave(&hw->lock, flags);
spi-nuc900.c:161:	val = __raw_readl(hw->regs + USI_CNT);
spi-nuc900.c:165:	__raw_writel(val, hw->regs + USI_CNT);
spi-nuc900.c:167:	spin_unlock_irqrestore(&hw->lock, flags);
spi-nuc900.c:172:	return hw->tx ? hw->tx[count] : 0;
spi-nuc900.c:179:	hw->tx = t->tx_buf;
spi-nuc900.c:180:	hw->rx = t->rx_buf;
spi-nuc900.c:181:	hw->len = t->len;
spi-nuc900.c:182:	hw->count = 0;
spi-nuc900.c:184:	__raw_writel(hw_txbyte(hw, 0x0), hw->regs + USI_TX0);
spi-nuc900.c:188:	wait_for_completion(&hw->done);
spi-nuc900.c:190:	return hw->count;
spi-nuc900.c:197:	unsigned int count = hw->count;
spi-nuc900.c:199:	status = __raw_readl(hw->regs + USI_CNT);
spi-nuc900.c:200:	__raw_writel(status, hw->regs + USI_CNT);
spi-nuc900.c:203:		hw->count++;
spi-nuc900.c:205:		if (hw->rx)
spi-nuc900.c:206:			hw->rx[count] = __raw_readl(hw->regs + USI_RX0);
spi-nuc900.c:209:		if (count < hw->len) {
spi-nuc900.c:210:			__raw_writel(hw_txbyte(hw, count), hw->regs + USI_TX0);
spi-nuc900.c:213:			complete(&hw->done);
spi-nuc900.c:219:	complete(&hw->done);
spi-nuc900.c:228:	spin_lock_irqsave(&hw->lock, flags);
spi-nuc900.c:230:	val = __raw_readl(hw->regs + USI_CNT);
spi-nuc900.c:236:	__raw_writel(val, hw->regs + USI_CNT);
spi-nuc900.c:238:	spin_unlock_irqrestore(&hw->lock, flags);
spi-nuc900.c:246:	spin_lock_irqsave(&hw->lock, flags);
spi-nuc900.c:248:	val = __raw_readl(hw->regs + USI_CNT);
spi-nuc900.c:254:	__raw_writel(val, hw->regs + USI_CNT);
spi-nuc900.c:256:	spin_unlock_irqrestore(&hw->lock, flags);
spi-nuc900.c:264:	spin_lock_irqsave(&hw->lock, flags);
spi-nuc900.c:266:	val = __raw_readl(hw->regs + USI_CNT);
spi-nuc900.c:272:	__raw_writel(val, hw->regs + USI_CNT);
spi-nuc900.c:274:	spin_unlock_irqrestore(&hw->lock, flags);
spi-nuc900.c:282:	spin_lock_irqsave(&hw->lock, flags);
spi-nuc900.c:284:	val = __raw_readl(hw->regs + USI_CNT) & ~SLEEP;
spi-nuc900.c:289:	__raw_writel(val, hw->regs + USI_CNT);
spi-nuc900.c:291:	spin_unlock_irqrestore(&hw->lock, flags);
spi-nuc900.c:299:	spin_lock_irqsave(&hw->lock, flags);
spi-nuc900.c:301:	val = __raw_readl(hw->regs + USI_CNT);
spi-nuc900.c:305:	__raw_writel(val, hw->regs + USI_CNT);
spi-nuc900.c:307:	spin_unlock_irqrestore(&hw->lock, flags);
spi-nuc900.c:312:	__raw_writel(hw->pdata->divider, hw->regs + USI_DIV);
spi-nuc900.c:317:	clk_enable(hw->clk);
spi-nuc900.c:318:	spin_lock_init(&hw->lock);
spi-nuc900.c:320:	nuc900_tx_edge(hw, hw->pdata->txneg);
spi-nuc900.c:321:	nuc900_rx_edge(hw, hw->pdata->rxneg);
spi-nuc900.c:322:	nuc900_send_first(hw, hw->pdata->lsb);
spi-nuc900.c:323:	nuc900_set_sleep(hw, hw->pdata->sleep);
spi-nuc900.c:324:	nuc900_spi_setup_txbitlen(hw, hw->pdata->txbitlen);
spi-nuc900.c:325:	nuc900_spi_setup_txnum(hw, hw->pdata->txnum);
spi-nuc900.c:337:	master = spi_alloc_master(&pdev->dev, sizeof(struct nuc900_spi));
spi-nuc900.c:339:		dev_err(&pdev->dev, "No memory for spi_master\n");
spi-nuc900.c:340:		return -ENOMEM;
spi-nuc900.c:344:	hw->master = master;
spi-nuc900.c:345:	hw->pdata  = dev_get_platdata(&pdev->dev);
spi-nuc900.c:347:	if (hw->pdata == NULL) {
spi-nuc900.c:348:		dev_err(&pdev->dev, "No platform data supplied\n");
spi-nuc900.c:349:		err = -ENOENT;
spi-nuc900.c:354:	init_completion(&hw->done);
spi-nuc900.c:356:	master->mode_bits          = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-nuc900.c:357:	if (hw->pdata->lsb)
spi-nuc900.c:358:		master->mode_bits |= SPI_LSB_FIRST;
spi-nuc900.c:359:	master->num_chipselect     = hw->pdata->num_cs;
spi-nuc900.c:360:	master->bus_num            = hw->pdata->bus_num;
spi-nuc900.c:361:	hw->bitbang.master         = hw->master;
spi-nuc900.c:362:	hw->bitbang.chipselect     = nuc900_spi_chipsel;
spi-nuc900.c:363:	hw->bitbang.txrx_bufs      = nuc900_spi_txrx;
spi-nuc900.c:366:	hw->regs = devm_ioremap_resource(&pdev->dev, res);
spi-nuc900.c:367:	if (IS_ERR(hw->regs)) {
spi-nuc900.c:368:		err = PTR_ERR(hw->regs);
spi-nuc900.c:372:	hw->irq = platform_get_irq(pdev, 0);
spi-nuc900.c:373:	if (hw->irq < 0) {
spi-nuc900.c:374:		dev_err(&pdev->dev, "No IRQ specified\n");
spi-nuc900.c:375:		err = -ENOENT;
spi-nuc900.c:379:	err = devm_request_irq(&pdev->dev, hw->irq, nuc900_spi_irq, 0,
spi-nuc900.c:380:				pdev->name, hw);
spi-nuc900.c:382:		dev_err(&pdev->dev, "Cannot claim IRQ\n");
spi-nuc900.c:386:	hw->clk = devm_clk_get(&pdev->dev, "spi");
spi-nuc900.c:387:	if (IS_ERR(hw->clk)) {
spi-nuc900.c:388:		dev_err(&pdev->dev, "No clock for device\n");
spi-nuc900.c:389:		err = PTR_ERR(hw->clk);
spi-nuc900.c:393:	mfp_set_groupg(&pdev->dev, NULL);
spi-nuc900.c:396:	err = spi_bitbang_start(&hw->bitbang);
spi-nuc900.c:398:		dev_err(&pdev->dev, "Failed to register SPI master\n");
spi-nuc900.c:405:	clk_disable(hw->clk);
spi-nuc900.c:407:	spi_master_put(hw->master);
spi-nuc900.c:415:	spi_bitbang_stop(&hw->bitbang);
spi-nuc900.c:416:	clk_disable(hw->clk);
spi-nuc900.c:417:	spi_master_put(hw->master);
spi-nuc900.c:425:		.name	= "nuc900-spi",
spi-nuc900.c:433:MODULE_ALIAS("platform:nuc900-spi");
spi-ti-qspi.c:4: * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com
spi-ti-qspi.c:22:#include <linux/dma-mapping.h>
spi-ti-qspi.c:24:#include <linux/omap-dma.h>
spi-ti-qspi.c:87:#define QSPI_WLEN(n)			((n - 1) << 19)
spi-ti-qspi.c:94:#define QSPI_FLEN(n)			((n - 1) << 0)
spi-ti-qspi.c:116:	return readl(qspi->base + reg);
spi-ti-qspi.c:122:	writel(val, qspi->base + reg);
spi-ti-qspi.c:127:	struct ti_qspi	*qspi = spi_master_get_devdata(spi->master);
spi-ti-qspi.c:128:	struct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;
spi-ti-qspi.c:132:	if (spi->master->busy) {
spi-ti-qspi.c:133:		dev_dbg(qspi->dev, "master busy doing other trasnfers\n");
spi-ti-qspi.c:134:		return -EBUSY;
spi-ti-qspi.c:137:	if (!qspi->spi_max_frequency) {
spi-ti-qspi.c:138:		dev_err(qspi->dev, "spi max frequency not defined\n");
spi-ti-qspi.c:139:		return -EINVAL;
spi-ti-qspi.c:142:	clk_rate = clk_get_rate(qspi->fclk);
spi-ti-qspi.c:144:	clk_div = DIV_ROUND_UP(clk_rate, qspi->spi_max_frequency) - 1;
spi-ti-qspi.c:147:		dev_dbg(qspi->dev, "clock divider < 0, using /1 divider\n");
spi-ti-qspi.c:148:		return -EINVAL;
spi-ti-qspi.c:152:		dev_dbg(qspi->dev, "clock divider >%d , using /%d divider\n",
spi-ti-qspi.c:154:		return -EINVAL;
spi-ti-qspi.c:157:	dev_dbg(qspi->dev, "hz: %d, clock divider %d\n",
spi-ti-qspi.c:158:			qspi->spi_max_frequency, clk_div);
spi-ti-qspi.c:160:	ret = pm_runtime_get_sync(qspi->dev);
spi-ti-qspi.c:162:		dev_err(qspi->dev, "pm_runtime_get_sync() failed\n");
spi-ti-qspi.c:176:	ctx_reg->clkctrl = clk_mask;
spi-ti-qspi.c:178:	pm_runtime_mark_last_busy(qspi->dev);
spi-ti-qspi.c:179:	ret = pm_runtime_put_autosuspend(qspi->dev);
spi-ti-qspi.c:181:		dev_err(qspi->dev, "pm_runtime_put_autosuspend() failed\n");
spi-ti-qspi.c:190:	struct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;
spi-ti-qspi.c:192:	ti_qspi_write(qspi, ctx_reg->clkctrl, QSPI_SPI_CLOCK_CNTRL_REG);
spi-ti-qspi.c:225:	return  -ETIMEDOUT;
spi-ti-qspi.c:236:	txbuf = t->tx_buf;
spi-ti-qspi.c:237:	cmd = qspi->cmd | QSPI_WR_SNGL;
spi-ti-qspi.c:238:	wlen = t->bits_per_word >> 3;	/* in bytes */
spi-ti-qspi.c:243:			return -EBUSY;
spi-ti-qspi.c:247:			dev_dbg(qspi->dev, "tx cmd %08x dc %08x data %02x\n",
spi-ti-qspi.c:248:					cmd, qspi->dc, *txbuf);
spi-ti-qspi.c:253:				writel(data, qspi->base +
spi-ti-qspi.c:256:				writel(data, qspi->base +
spi-ti-qspi.c:259:				writel(data, qspi->base +
spi-ti-qspi.c:262:				writel(data, qspi->base +
spi-ti-qspi.c:267:				writeb(*txbuf, qspi->base + QSPI_SPI_DATA_REG);
spi-ti-qspi.c:268:				cmd = qspi->cmd | QSPI_WR_SNGL;
spi-ti-qspi.c:274:			dev_dbg(qspi->dev, "tx cmd %08x dc %08x data %04x\n",
spi-ti-qspi.c:275:					cmd, qspi->dc, *txbuf);
spi-ti-qspi.c:276:			writew(*((u16 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);
spi-ti-qspi.c:279:			dev_dbg(qspi->dev, "tx cmd %08x dc %08x data %08x\n",
spi-ti-qspi.c:280:					cmd, qspi->dc, *txbuf);
spi-ti-qspi.c:281:			writel(*((u32 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);
spi-ti-qspi.c:287:			dev_err(qspi->dev, "write timed out\n");
spi-ti-qspi.c:288:			return -ETIMEDOUT;
spi-ti-qspi.c:291:		count -= xfer_len;
spi-ti-qspi.c:304:	rxbuf = t->rx_buf;
spi-ti-qspi.c:305:	cmd = qspi->cmd;
spi-ti-qspi.c:306:	switch (t->rx_nbits) {
spi-ti-qspi.c:317:	wlen = t->bits_per_word >> 3;	/* in bytes */
spi-ti-qspi.c:320:		dev_dbg(qspi->dev, "rx cmd %08x dc %08x\n", cmd, qspi->dc);
spi-ti-qspi.c:322:			return -EBUSY;
spi-ti-qspi.c:326:			dev_err(qspi->dev, "read timed out\n");
spi-ti-qspi.c:327:			return -ETIMEDOUT;
spi-ti-qspi.c:331:			*rxbuf = readb(qspi->base + QSPI_SPI_DATA_REG);
spi-ti-qspi.c:334:			*((u16 *)rxbuf) = readw(qspi->base + QSPI_SPI_DATA_REG);
spi-ti-qspi.c:337:			*((u32 *)rxbuf) = readl(qspi->base + QSPI_SPI_DATA_REG);
spi-ti-qspi.c:341:		count -= wlen;
spi-ti-qspi.c:352:	if (t->tx_buf) {
spi-ti-qspi.c:355:			dev_dbg(qspi->dev, "Error while writing\n");
spi-ti-qspi.c:360:	if (t->rx_buf) {
spi-ti-qspi.c:363:			dev_dbg(qspi->dev, "Error while reading\n");
spi-ti-qspi.c:375:	struct spi_device *spi = m->spi;
spi-ti-qspi.c:382:	qspi->dc = 0;
spi-ti-qspi.c:384:	if (spi->mode & SPI_CPHA)
spi-ti-qspi.c:385:		qspi->dc |= QSPI_CKPHA(spi->chip_select);
spi-ti-qspi.c:386:	if (spi->mode & SPI_CPOL)
spi-ti-qspi.c:387:		qspi->dc |= QSPI_CKPOL(spi->chip_select);
spi-ti-qspi.c:388:	if (spi->mode & SPI_CS_HIGH)
spi-ti-qspi.c:389:		qspi->dc |= QSPI_CSPOL(spi->chip_select);
spi-ti-qspi.c:392:	list_for_each_entry(t, &m->transfers, transfer_list)
spi-ti-qspi.c:393:		frame_len_words += t->len / (t->bits_per_word >> 3);
spi-ti-qspi.c:397:	qspi->cmd = 0;
spi-ti-qspi.c:398:	qspi->cmd |= QSPI_EN_CS(spi->chip_select);
spi-ti-qspi.c:399:	qspi->cmd |= QSPI_FLEN(frame_len_words);
spi-ti-qspi.c:401:	ti_qspi_write(qspi, qspi->dc, QSPI_SPI_DC_REG);
spi-ti-qspi.c:403:	mutex_lock(&qspi->list_lock);
spi-ti-qspi.c:405:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-ti-qspi.c:406:		qspi->cmd = ((qspi->cmd & ~QSPI_WLEN_MASK) |
spi-ti-qspi.c:407:			     QSPI_WLEN(t->bits_per_word));
spi-ti-qspi.c:409:		wlen = t->bits_per_word >> 3;
spi-ti-qspi.c:410:		transfer_len_words = min(t->len / wlen, frame_len_words);
spi-ti-qspi.c:414:			dev_dbg(qspi->dev, "transfer message failed\n");
spi-ti-qspi.c:415:			mutex_unlock(&qspi->list_lock);
spi-ti-qspi.c:416:			return -EINVAL;
spi-ti-qspi.c:419:		m->actual_length += transfer_len_words * wlen;
spi-ti-qspi.c:420:		frame_len_words -= transfer_len_words;
spi-ti-qspi.c:425:	mutex_unlock(&qspi->list_lock);
spi-ti-qspi.c:427:	ti_qspi_write(qspi, qspi->cmd | QSPI_INVAL, QSPI_SPI_CMD_REG);
spi-ti-qspi.c:428:	m->status = status;
spi-ti-qspi.c:445:	{.compatible = "ti,dra7xxx-qspi" },
spi-ti-qspi.c:446:	{.compatible = "ti,am4372-qspi" },
spi-ti-qspi.c:456:	struct device_node *np = pdev->dev.of_node;
spi-ti-qspi.c:460:	master = spi_alloc_master(&pdev->dev, sizeof(*qspi));
spi-ti-qspi.c:462:		return -ENOMEM;
spi-ti-qspi.c:464:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_RX_DUAL | SPI_RX_QUAD;
spi-ti-qspi.c:466:	master->flags = SPI_MASTER_HALF_DUPLEX;
spi-ti-qspi.c:467:	master->setup = ti_qspi_setup;
spi-ti-qspi.c:468:	master->auto_runtime_pm = true;
spi-ti-qspi.c:469:	master->transfer_one_message = ti_qspi_start_transfer_one;
spi-ti-qspi.c:470:	master->dev.of_node = pdev->dev.of_node;
spi-ti-qspi.c:471:	master->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(16) |
spi-ti-qspi.c:474:	if (!of_property_read_u32(np, "num-cs", &num_cs))
spi-ti-qspi.c:475:		master->num_chipselect = num_cs;
spi-ti-qspi.c:478:	qspi->master = master;
spi-ti-qspi.c:479:	qspi->dev = &pdev->dev;
spi-ti-qspi.c:486:			dev_err(&pdev->dev, "missing platform data\n");
spi-ti-qspi.c:487:			return -ENODEV;
spi-ti-qspi.c:496:			dev_err(&pdev->dev,
spi-ti-qspi.c:506:			dev_dbg(&pdev->dev,
spi-ti-qspi.c:513:		dev_err(&pdev->dev, "no irq resource?\n");
spi-ti-qspi.c:517:	mutex_init(&qspi->list_lock);
spi-ti-qspi.c:519:	qspi->base = devm_ioremap_resource(&pdev->dev, r);
spi-ti-qspi.c:520:	if (IS_ERR(qspi->base)) {
spi-ti-qspi.c:521:		ret = PTR_ERR(qspi->base);
spi-ti-qspi.c:526:		qspi->ctrl_mod = true;
spi-ti-qspi.c:527:		qspi->ctrl_base = devm_ioremap_resource(&pdev->dev, res_ctrl);
spi-ti-qspi.c:528:		if (IS_ERR(qspi->ctrl_base)) {
spi-ti-qspi.c:529:			ret = PTR_ERR(qspi->ctrl_base);
spi-ti-qspi.c:535:		qspi->mmap_base = devm_ioremap_resource(&pdev->dev, res_mmap);
spi-ti-qspi.c:536:		if (IS_ERR(qspi->mmap_base)) {
spi-ti-qspi.c:537:			ret = PTR_ERR(qspi->mmap_base);
spi-ti-qspi.c:542:	qspi->fclk = devm_clk_get(&pdev->dev, "fck");
spi-ti-qspi.c:543:	if (IS_ERR(qspi->fclk)) {
spi-ti-qspi.c:544:		ret = PTR_ERR(qspi->fclk);
spi-ti-qspi.c:545:		dev_err(&pdev->dev, "could not get clk: %d\n", ret);
spi-ti-qspi.c:548:	pm_runtime_use_autosuspend(&pdev->dev);
spi-ti-qspi.c:549:	pm_runtime_set_autosuspend_delay(&pdev->dev, QSPI_AUTOSUSPEND_TIMEOUT);
spi-ti-qspi.c:550:	pm_runtime_enable(&pdev->dev);
spi-ti-qspi.c:552:	if (!of_property_read_u32(np, "spi-max-frequency", &max_freq))
spi-ti-qspi.c:553:		qspi->spi_max_frequency = max_freq;
spi-ti-qspi.c:555:	ret = devm_spi_register_master(&pdev->dev, master);
spi-ti-qspi.c:568:	pm_runtime_put_sync(&pdev->dev);
spi-ti-qspi.c:569:	pm_runtime_disable(&pdev->dev);
spi-ti-qspi.c:582:		.name	= "ti-qspi",
spi-ti-qspi.c:593:MODULE_ALIAS("platform:ti-qspi");
spi-sh.c:96:	if (ss->width == 8)
spi-sh.c:97:		iowrite8(data, ss->addr + (offset >> 2));
spi-sh.c:98:	else if (ss->width == 32)
spi-sh.c:99:		iowrite32(data, ss->addr + offset);
spi-sh.c:104:	if (ss->width == 8)
spi-sh.c:105:		return ioread8(ss->addr + (offset >> 2));
spi-sh.c:106:	else if (ss->width == 32)
spi-sh.c:107:		return ioread32(ss->addr + offset);
spi-sh.c:144:		if (timeout-- < 0)
spi-sh.c:145:			return -ETIMEDOUT;
spi-sh.c:156:		if (timeout-- < 0)
spi-sh.c:157:			return -ETIMEDOUT;
spi-sh.c:166:	int remain = t->len;
spi-sh.c:171:	if (t->len)
spi-sh.c:174:	data = (unsigned char *)t->tx_buf;
spi-sh.c:187:			retval = -EIO;
spi-sh.c:193:		remain -= cur_len;
spi-sh.c:197:			ss->cr1 &= ~SPI_SH_TBE;
spi-sh.c:199:			ret = wait_event_interruptible_timeout(ss->wait,
spi-sh.c:200:						 ss->cr1 & SPI_SH_TBE,
spi-sh.c:202:			if (ret == 0 && !(ss->cr1 & SPI_SH_TBE)) {
spi-sh.c:204:				return -ETIMEDOUT;
spi-sh.c:209:	if (list_is_last(&t->transfer_list, &mesg->transfers)) {
spi-sh.c:213:		ss->cr1 &= ~SPI_SH_TBE;
spi-sh.c:215:		ret = wait_event_interruptible_timeout(ss->wait,
spi-sh.c:216:					 ss->cr1 & SPI_SH_TBE,
spi-sh.c:218:		if (ret == 0 && (ss->cr1 & SPI_SH_TBE)) {
spi-sh.c:220:			return -ETIMEDOUT;
spi-sh.c:231:	int remain = t->len;
spi-sh.c:236:	if (t->len > SPI_SH_MAX_BYTE)
spi-sh.c:239:		spi_sh_write(ss, t->len, SPI_SH_CR3);
spi-sh.c:246:	data = (unsigned char *)t->rx_buf;
spi-sh.c:249:			ss->cr1 &= ~SPI_SH_RBF;
spi-sh.c:251:			ret = wait_event_interruptible_timeout(ss->wait,
spi-sh.c:252:						 ss->cr1 & SPI_SH_RBF,
spi-sh.c:257:				return -ETIMEDOUT;
spi-sh.c:268:		remain -= cur_len;
spi-sh.c:273:	if (t->len > SPI_SH_MAX_BYTE) {
spi-sh.c:293:	spin_lock_irqsave(&ss->lock, flags);
spi-sh.c:294:	while (!list_empty(&ss->queue)) {
spi-sh.c:295:		mesg = list_entry(ss->queue.next, struct spi_message, queue);
spi-sh.c:296:		list_del_init(&mesg->queue);
spi-sh.c:298:		spin_unlock_irqrestore(&ss->lock, flags);
spi-sh.c:299:		list_for_each_entry(t, &mesg->transfers, transfer_list) {
spi-sh.c:301:					t->tx_buf, t->rx_buf);
spi-sh.c:303:					t->len, t->delay_usecs);
spi-sh.c:305:			if (t->tx_buf) {
spi-sh.c:310:			if (t->rx_buf) {
spi-sh.c:315:			mesg->actual_length += t->len;
spi-sh.c:317:		spin_lock_irqsave(&ss->lock, flags);
spi-sh.c:319:		mesg->status = 0;
spi-sh.c:320:		if (mesg->complete)
spi-sh.c:321:			mesg->complete(mesg->context);
spi-sh.c:333:	spin_unlock_irqrestore(&ss->lock, flags);
spi-sh.c:338:	mesg->status = ret;
spi-sh.c:339:	if (mesg->complete)
spi-sh.c:340:		mesg->complete(mesg->context);
spi-sh.c:350:	struct spi_sh_data *ss = spi_master_get_devdata(spi->master);
spi-sh.c:369:	struct spi_sh_data *ss = spi_master_get_devdata(spi->master);
spi-sh.c:373:	pr_debug("\tmode = %02x\n", spi->mode);
spi-sh.c:375:	spin_lock_irqsave(&ss->lock, flags);
spi-sh.c:377:	mesg->actual_length = 0;
spi-sh.c:378:	mesg->status = -EINPROGRESS;
spi-sh.c:382:	list_add_tail(&mesg->queue, &ss->queue);
spi-sh.c:383:	queue_work(ss->workqueue, &ss->ws);
spi-sh.c:385:	spin_unlock_irqrestore(&ss->lock, flags);
spi-sh.c:392:	struct spi_sh_data *ss = spi_master_get_devdata(spi->master);
spi-sh.c:407:		ss->cr1 |= SPI_SH_TBE;
spi-sh.c:409:		ss->cr1 |= SPI_SH_TBF;
spi-sh.c:411:		ss->cr1 |= SPI_SH_RBE;
spi-sh.c:413:		ss->cr1 |= SPI_SH_RBF;
spi-sh.c:415:	if (ss->cr1) {
spi-sh.c:416:		spi_sh_clear_bit(ss, ss->cr1, SPI_SH_CR4);
spi-sh.c:417:		wake_up(&ss->wait);
spi-sh.c:427:	spi_unregister_master(ss->master);
spi-sh.c:428:	destroy_workqueue(ss->workqueue);
spi-sh.c:429:	free_irq(ss->irq, ss);
spi-sh.c:444:		dev_err(&pdev->dev, "invalid resource\n");
spi-sh.c:445:		return -EINVAL;
spi-sh.c:450:		dev_err(&pdev->dev, "platform_get_irq error\n");
spi-sh.c:451:		return -ENODEV;
spi-sh.c:454:	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_sh_data));
spi-sh.c:456:		dev_err(&pdev->dev, "spi_alloc_master error.\n");
spi-sh.c:457:		return -ENOMEM;
spi-sh.c:463:	switch (res->flags & IORESOURCE_MEM_TYPE_MASK) {
spi-sh.c:465:		ss->width = 8;
spi-sh.c:468:		ss->width = 32;
spi-sh.c:471:		dev_err(&pdev->dev, "No support width\n");
spi-sh.c:472:		ret = -ENODEV;
spi-sh.c:475:	ss->irq = irq;
spi-sh.c:476:	ss->master = master;
spi-sh.c:477:	ss->addr = devm_ioremap(&pdev->dev, res->start, resource_size(res));
spi-sh.c:478:	if (ss->addr == NULL) {
spi-sh.c:479:		dev_err(&pdev->dev, "ioremap error.\n");
spi-sh.c:480:		ret = -ENOMEM;
spi-sh.c:483:	INIT_LIST_HEAD(&ss->queue);
spi-sh.c:484:	spin_lock_init(&ss->lock);
spi-sh.c:485:	INIT_WORK(&ss->ws, spi_sh_work);
spi-sh.c:486:	init_waitqueue_head(&ss->wait);
spi-sh.c:487:	ss->workqueue = create_singlethread_workqueue(
spi-sh.c:488:					dev_name(master->dev.parent));
spi-sh.c:489:	if (ss->workqueue == NULL) {
spi-sh.c:490:		dev_err(&pdev->dev, "create workqueue error\n");
spi-sh.c:491:		ret = -EBUSY;
spi-sh.c:497:		dev_err(&pdev->dev, "request_irq error\n");
spi-sh.c:501:	master->num_chipselect = 2;
spi-sh.c:502:	master->bus_num = pdev->id;
spi-sh.c:503:	master->setup = spi_sh_setup;
spi-sh.c:504:	master->transfer = spi_sh_transfer;
spi-sh.c:505:	master->cleanup = spi_sh_cleanup;
spi-sh.c:518:	destroy_workqueue(ss->workqueue);
spi-dw-pci.c:22:#include "spi-dw.h"
spi-dw-pci.c:47:	struct spi_pci_desc *desc = (struct spi_pci_desc *)ent->driver_data;
spi-dw-pci.c:55:	dws = devm_kzalloc(&pdev->dev, sizeof(*dws), GFP_KERNEL);
spi-dw-pci.c:57:		return -ENOMEM;
spi-dw-pci.c:60:	dws->paddr = pci_resource_start(pdev, pci_bar);
spi-dw-pci.c:66:	dws->regs = pcim_iomap_table(pdev)[pci_bar];
spi-dw-pci.c:67:	dws->irq = pdev->irq;
spi-dw-pci.c:74:		dws->num_cs = desc->num_cs;
spi-dw-pci.c:75:		dws->bus_num = desc->bus_num;
spi-dw-pci.c:77:		if (desc->setup) {
spi-dw-pci.c:78:			ret = desc->setup(dws);
spi-dw-pci.c:83:		return -ENODEV;
spi-dw-pci.c:86:	ret = dw_spi_add_host(&pdev->dev, dws);
spi-dw-pci.c:93:	dev_info(&pdev->dev, "found PCI SPI controller(ID: %04x:%04x)\n",
spi-dw-pci.c:94:		pdev->vendor, pdev->device);
spi-bitbang.c:30:/*----------------------------------------------------------------------*/
spi-bitbang.c:33: * FIRST PART (OPTIONAL):  word-at-a-time spi_transfer support.
spi-bitbang.c:34: * Use this for GPIO or shift-register level hardware APIs.
spi-bitbang.c:36: * spi_bitbang_cs is in spi_device->controller_state, which is unavailable
spi-bitbang.c:38: * used, though maybe they're called from controller-aware code.
spi-bitbang.c:40: * chipselect() and friends may use spi_device->controller_data and
spi-bitbang.c:69:	unsigned		bits = t->bits_per_word;
spi-bitbang.c:70:	unsigned		count = t->len;
spi-bitbang.c:71:	const u8		*tx = t->tx_buf;
spi-bitbang.c:72:	u8			*rx = t->rx_buf;
spi-bitbang.c:82:		count -= 1;
spi-bitbang.c:84:	return t->len - count;
spi-bitbang.c:95:	unsigned		bits = t->bits_per_word;
spi-bitbang.c:96:	unsigned		count = t->len;
spi-bitbang.c:97:	const u16		*tx = t->tx_buf;
spi-bitbang.c:98:	u16			*rx = t->rx_buf;
spi-bitbang.c:108:		count -= 2;
spi-bitbang.c:110:	return t->len - count;
spi-bitbang.c:121:	unsigned		bits = t->bits_per_word;
spi-bitbang.c:122:	unsigned		count = t->len;
spi-bitbang.c:123:	const u32		*tx = t->tx_buf;
spi-bitbang.c:124:	u32			*rx = t->rx_buf;
spi-bitbang.c:134:		count -= 4;
spi-bitbang.c:136:	return t->len - count;
spi-bitbang.c:141:	struct spi_bitbang_cs	*cs = spi->controller_state;
spi-bitbang.c:146:		bits_per_word = t->bits_per_word;
spi-bitbang.c:147:		hz = t->speed_hz;
spi-bitbang.c:153:	/* spi_transfer level calls that work per-word */
spi-bitbang.c:155:		bits_per_word = spi->bits_per_word;
spi-bitbang.c:157:		cs->txrx_bufs = bitbang_txrx_8;
spi-bitbang.c:159:		cs->txrx_bufs = bitbang_txrx_16;
spi-bitbang.c:161:		cs->txrx_bufs = bitbang_txrx_32;
spi-bitbang.c:163:		return -EINVAL;
spi-bitbang.c:167:		hz = spi->max_speed_hz;
spi-bitbang.c:169:		cs->nsecs = (1000000000/2) / hz;
spi-bitbang.c:170:		if (cs->nsecs > (MAX_UDELAY_MS * 1000 * 1000))
spi-bitbang.c:171:			return -EINVAL;
spi-bitbang.c:179: * spi_bitbang_setup - default setup for per-word I/O loops
spi-bitbang.c:183:	struct spi_bitbang_cs	*cs = spi->controller_state;
spi-bitbang.c:186:	bitbang = spi_master_get_devdata(spi->master);
spi-bitbang.c:191:			return -ENOMEM;
spi-bitbang.c:192:		spi->controller_state = cs;
spi-bitbang.c:195:	/* per-word shift register access, in hardware or bitbanging */
spi-bitbang.c:196:	cs->txrx_word = bitbang->txrx_word[spi->mode & (SPI_CPOL|SPI_CPHA)];
spi-bitbang.c:197:	if (!cs->txrx_word)
spi-bitbang.c:198:		return -EINVAL;
spi-bitbang.c:200:	if (bitbang->setup_transfer) {
spi-bitbang.c:201:		int retval = bitbang->setup_transfer(spi, NULL);
spi-bitbang.c:206:	dev_dbg(&spi->dev, "%s, %u nsec/bit\n", __func__, 2 * cs->nsecs);
spi-bitbang.c:214:	mutex_lock(&bitbang->lock);
spi-bitbang.c:215:	if (!bitbang->busy) {
spi-bitbang.c:216:		bitbang->chipselect(spi, BITBANG_CS_INACTIVE);
spi-bitbang.c:217:		ndelay(cs->nsecs);
spi-bitbang.c:219:	mutex_unlock(&bitbang->lock);
spi-bitbang.c:226: * spi_bitbang_cleanup - default cleanup for per-word I/O loops
spi-bitbang.c:230:	kfree(spi->controller_state);
spi-bitbang.c:236:	struct spi_bitbang_cs	*cs = spi->controller_state;
spi-bitbang.c:237:	unsigned		nsecs = cs->nsecs;
spi-bitbang.c:239:	return cs->txrx_bufs(spi, cs->txrx_word, nsecs, t);
spi-bitbang.c:242:/*----------------------------------------------------------------------*/
spi-bitbang.c:252: * Drivers can provide word-at-a-time i/o primitives, or provide
spi-bitbang.c:253: * transfer-at-a-time ones to leverage dma or fifo hardware.
spi-bitbang.c:262:	mutex_lock(&bitbang->lock);
spi-bitbang.c:263:	bitbang->busy = 1;
spi-bitbang.c:264:	mutex_unlock(&bitbang->lock);
spi-bitbang.c:276:	if (bitbang->setup_transfer) {
spi-bitbang.c:277:		status = bitbang->setup_transfer(spi, transfer);
spi-bitbang.c:282:	if (transfer->len)
spi-bitbang.c:283:		status = bitbang->txrx_bufs(spi, transfer);
spi-bitbang.c:285:	if (status == transfer->len)
spi-bitbang.c:288:		status = -EREMOTEIO;
spi-bitbang.c:302:	mutex_lock(&bitbang->lock);
spi-bitbang.c:303:	bitbang->busy = 0;
spi-bitbang.c:304:	mutex_unlock(&bitbang->lock);
spi-bitbang.c:311:	struct spi_bitbang *bitbang = spi_master_get_devdata(spi->master);
spi-bitbang.c:317:	enable = (!!(spi->mode & SPI_CS_HIGH) == enable);
spi-bitbang.c:320:	bitbang->chipselect(spi, enable ? BITBANG_CS_ACTIVE :
spi-bitbang.c:325:/*----------------------------------------------------------------------*/
spi-bitbang.c:328: * spi_bitbang_start - start up a polled/bitbanging SPI master driver
spi-bitbang.c:331: * Caller should have zero-initialized all parts of the structure, and then
spi-bitbang.c:337: * For i/o loops, provide callbacks either per-word (for bitbanging, or for
spi-bitbang.c:338: * hardware that basically exposes a shift register) or per-spi_transfer
spi-bitbang.c:341: * Drivers using per-word I/O loops should use (or call) spi_bitbang_setup,
spi-bitbang.c:343: * master methods.  Those methods are the defaults if the bitbang->txrx_bufs
spi-bitbang.c:357:	struct spi_master *master = bitbang->master;
spi-bitbang.c:360:	if (!master || !bitbang->chipselect)
spi-bitbang.c:361:		return -EINVAL;
spi-bitbang.c:363:	mutex_init(&bitbang->lock);
spi-bitbang.c:365:	if (!master->mode_bits)
spi-bitbang.c:366:		master->mode_bits = SPI_CPOL | SPI_CPHA | bitbang->flags;
spi-bitbang.c:368:	if (master->transfer || master->transfer_one_message)
spi-bitbang.c:369:		return -EINVAL;
spi-bitbang.c:371:	master->prepare_transfer_hardware = spi_bitbang_prepare_hardware;
spi-bitbang.c:372:	master->unprepare_transfer_hardware = spi_bitbang_unprepare_hardware;
spi-bitbang.c:373:	master->transfer_one = spi_bitbang_transfer_one;
spi-bitbang.c:374:	master->set_cs = spi_bitbang_set_cs;
spi-bitbang.c:376:	if (!bitbang->txrx_bufs) {
spi-bitbang.c:377:		bitbang->use_dma = 0;
spi-bitbang.c:378:		bitbang->txrx_bufs = spi_bitbang_bufs;
spi-bitbang.c:379:		if (!master->setup) {
spi-bitbang.c:380:			if (!bitbang->setup_transfer)
spi-bitbang.c:381:				bitbang->setup_transfer =
spi-bitbang.c:383:			master->setup = spi_bitbang_setup;
spi-bitbang.c:384:			master->cleanup = spi_bitbang_cleanup;
spi-bitbang.c:400: * spi_bitbang_stop - stops the task providing spi communication
spi-bitbang.c:404:	spi_unregister_master(bitbang->master);
spi-mpc52xx.c:27:MODULE_DESCRIPTION("MPC52xx SPI (non-PSC) Driver");
spi-mpc52xx.c:100:	if (ms->gpio_cs_count > 0) {
spi-mpc52xx.c:101:		cs = ms->message->spi->chip_select;
spi-mpc52xx.c:102:		gpio_set_value(ms->gpio_cs[cs], value ? 0 : 1);
spi-mpc52xx.c:104:		out_8(ms->regs + SPI_PORTDATA, value ? 0 : 0x08);
spi-mpc52xx.c:114:	ms->rx_buf = ms->transfer->rx_buf;
spi-mpc52xx.c:115:	ms->tx_buf = ms->transfer->tx_buf;
spi-mpc52xx.c:116:	ms->len = ms->transfer->len;
spi-mpc52xx.c:119:	if (ms->cs_change)
spi-mpc52xx.c:121:	ms->cs_change = ms->transfer->cs_change;
spi-mpc52xx.c:124:	ms->wcol_tx_timestamp = get_tbl();
spi-mpc52xx.c:125:	if (ms->tx_buf)
spi-mpc52xx.c:126:		out_8(ms->regs + SPI_DATA, *ms->tx_buf++);
spi-mpc52xx.c:128:		out_8(ms->regs + SPI_DATA, 0);
spi-mpc52xx.c:151:		dev_err(&ms->master->dev, "spurious irq, status=0x%.2x\n",
spi-mpc52xx.c:155:	if (list_empty(&ms->queue))
spi-mpc52xx.c:159:	ms->message = list_first_entry(&ms->queue, struct spi_message, queue);
spi-mpc52xx.c:160:	list_del_init(&ms->message->queue);
spi-mpc52xx.c:164:	spi = ms->message->spi;
spi-mpc52xx.c:165:	if (spi->mode & SPI_CPHA)
spi-mpc52xx.c:167:	if (spi->mode & SPI_CPOL)
spi-mpc52xx.c:169:	if (spi->mode & SPI_LSB_FIRST)
spi-mpc52xx.c:171:	out_8(ms->regs + SPI_CTRL1, ctrl1);
spi-mpc52xx.c:176:	sppr = ((ms->ipb_freq / ms->message->spi->max_speed_hz) + 1) >> 1;
spi-mpc52xx.c:180:	while (((sppr - 1) & ~0x7) != 0) {
spi-mpc52xx.c:184:	sppr--;		/* sppr quantity in register is offset by 1 */
spi-mpc52xx.c:190:	out_8(ms->regs + SPI_BRR, sppr << 4 | spr); /* Set speed */
spi-mpc52xx.c:192:	ms->cs_change = 1;
spi-mpc52xx.c:193:	ms->transfer = container_of(ms->message->transfers.next,
spi-mpc52xx.c:197:	ms->state = mpc52xx_spi_fsmstate_transfer;
spi-mpc52xx.c:214:		return ms->irq0 ? FSM_STOP : FSM_POLL;
spi-mpc52xx.c:224:		ms->wcol_count++;
spi-mpc52xx.c:225:		ms->wcol_ticks += get_tbl() - ms->wcol_tx_timestamp;
spi-mpc52xx.c:226:		ms->wcol_tx_timestamp = get_tbl();
spi-mpc52xx.c:228:		if (ms->tx_buf)
spi-mpc52xx.c:229:			data = *(ms->tx_buf - 1);
spi-mpc52xx.c:230:		out_8(ms->regs + SPI_DATA, data); /* try again */
spi-mpc52xx.c:233:		ms->modf_count++;
spi-mpc52xx.c:234:		dev_err(&ms->master->dev, "mode fault\n");
spi-mpc52xx.c:236:		ms->message->status = -EIO;
spi-mpc52xx.c:237:		if (ms->message->complete)
spi-mpc52xx.c:238:			ms->message->complete(ms->message->context);
spi-mpc52xx.c:239:		ms->state = mpc52xx_spi_fsmstate_idle;
spi-mpc52xx.c:244:	ms->byte_count++;
spi-mpc52xx.c:245:	if (ms->rx_buf)
spi-mpc52xx.c:246:		*ms->rx_buf++ = data;
spi-mpc52xx.c:249:	ms->len--;
spi-mpc52xx.c:250:	if (ms->len == 0) {
spi-mpc52xx.c:251:		ms->timestamp = get_tbl();
spi-mpc52xx.c:252:		ms->timestamp += ms->transfer->delay_usecs * tb_ticks_per_usec;
spi-mpc52xx.c:253:		ms->state = mpc52xx_spi_fsmstate_wait;
spi-mpc52xx.c:258:	ms->wcol_tx_timestamp = get_tbl();
spi-mpc52xx.c:259:	if (ms->tx_buf)
spi-mpc52xx.c:260:		out_8(ms->regs + SPI_DATA, *ms->tx_buf++);
spi-mpc52xx.c:262:		out_8(ms->regs + SPI_DATA, 0);
spi-mpc52xx.c:277:		dev_err(&ms->master->dev, "spurious irq, status=0x%.2x\n",
spi-mpc52xx.c:280:	if (((int)get_tbl()) - ms->timestamp < 0)
spi-mpc52xx.c:283:	ms->message->actual_length += ms->transfer->len;
spi-mpc52xx.c:288:	if (ms->transfer->transfer_list.next == &ms->message->transfers) {
spi-mpc52xx.c:289:		ms->msg_count++;
spi-mpc52xx.c:291:		ms->message->status = 0;
spi-mpc52xx.c:292:		if (ms->message->complete)
spi-mpc52xx.c:293:			ms->message->complete(ms->message->context);
spi-mpc52xx.c:294:		ms->state = mpc52xx_spi_fsmstate_idle;
spi-mpc52xx.c:300:	if (ms->cs_change)
spi-mpc52xx.c:303:	ms->transfer = container_of(ms->transfer->transfer_list.next,
spi-mpc52xx.c:306:	ms->state = mpc52xx_spi_fsmstate_transfer;
spi-mpc52xx.c:311: * mpc52xx_spi_fsm_process - Finite State Machine iteration function
spi-mpc52xx.c:323:		status = in_8(ms->regs + SPI_STATUS);
spi-mpc52xx.c:324:		data = in_8(ms->regs + SPI_DATA);
spi-mpc52xx.c:325:		rc = ms->state(irq, ms, status, data);
spi-mpc52xx.c:329:		schedule_work(&ms->work);
spi-mpc52xx.c:333: * mpc52xx_spi_irq - IRQ handler
spi-mpc52xx.c:338:	spin_lock(&ms->lock);
spi-mpc52xx.c:340:	spin_unlock(&ms->lock);
spi-mpc52xx.c:345: * mpc52xx_spi_wq - Workqueue function for polling the state machine
spi-mpc52xx.c:352:	spin_lock_irqsave(&ms->lock, flags);
spi-mpc52xx.c:354:	spin_unlock_irqrestore(&ms->lock, flags);
spi-mpc52xx.c:363:	struct mpc52xx_spi *ms = spi_master_get_devdata(spi->master);
spi-mpc52xx.c:366:	m->actual_length = 0;
spi-mpc52xx.c:367:	m->status = -EINPROGRESS;
spi-mpc52xx.c:369:	spin_lock_irqsave(&ms->lock, flags);
spi-mpc52xx.c:370:	list_add_tail(&m->queue, &ms->queue);
spi-mpc52xx.c:371:	spin_unlock_irqrestore(&ms->lock, flags);
spi-mpc52xx.c:372:	schedule_work(&ms->work);
spi-mpc52xx.c:390:	dev_dbg(&op->dev, "probing mpc5200 SPI device\n");
spi-mpc52xx.c:391:	regs = of_iomap(op->dev.of_node, 0);
spi-mpc52xx.c:393:		return -ENODEV;
spi-mpc52xx.c:402:	/* Clear the status register and re-read it to check for a MODF
spi-mpc52xx.c:411:		dev_err(&op->dev, "mode fault; is port_config correct?\n");
spi-mpc52xx.c:412:		rc = -EIO;
spi-mpc52xx.c:416:	dev_dbg(&op->dev, "allocating spi_master struct\n");
spi-mpc52xx.c:417:	master = spi_alloc_master(&op->dev, sizeof *ms);
spi-mpc52xx.c:419:		rc = -ENOMEM;
spi-mpc52xx.c:423:	master->transfer = mpc52xx_spi_transfer;
spi-mpc52xx.c:424:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;
spi-mpc52xx.c:425:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-mpc52xx.c:426:	master->dev.of_node = op->dev.of_node;
spi-mpc52xx.c:431:	ms->master = master;
spi-mpc52xx.c:432:	ms->regs = regs;
spi-mpc52xx.c:433:	ms->irq0 = irq_of_parse_and_map(op->dev.of_node, 0);
spi-mpc52xx.c:434:	ms->irq1 = irq_of_parse_and_map(op->dev.of_node, 1);
spi-mpc52xx.c:435:	ms->state = mpc52xx_spi_fsmstate_idle;
spi-mpc52xx.c:436:	ms->ipb_freq = mpc5xxx_get_bus_frequency(op->dev.of_node);
spi-mpc52xx.c:437:	ms->gpio_cs_count = of_gpio_count(op->dev.of_node);
spi-mpc52xx.c:438:	if (ms->gpio_cs_count > 0) {
spi-mpc52xx.c:439:		master->num_chipselect = ms->gpio_cs_count;
spi-mpc52xx.c:440:		ms->gpio_cs = kmalloc(ms->gpio_cs_count * sizeof(unsigned int),
spi-mpc52xx.c:442:		if (!ms->gpio_cs) {
spi-mpc52xx.c:443:			rc = -ENOMEM;
spi-mpc52xx.c:447:		for (i = 0; i < ms->gpio_cs_count; i++) {
spi-mpc52xx.c:448:			gpio_cs = of_get_gpio(op->dev.of_node, i);
spi-mpc52xx.c:450:				dev_err(&op->dev,
spi-mpc52xx.c:453:				rc = -ENODEV;
spi-mpc52xx.c:457:			rc = gpio_request(gpio_cs, dev_name(&op->dev));
spi-mpc52xx.c:459:				dev_err(&op->dev,
spi-mpc52xx.c:466:			ms->gpio_cs[i] = gpio_cs;
spi-mpc52xx.c:470:	spin_lock_init(&ms->lock);
spi-mpc52xx.c:471:	INIT_LIST_HEAD(&ms->queue);
spi-mpc52xx.c:472:	INIT_WORK(&ms->work, mpc52xx_spi_wq);
spi-mpc52xx.c:475:	if (ms->irq0 && ms->irq1) {
spi-mpc52xx.c:476:		rc = request_irq(ms->irq0, mpc52xx_spi_irq, 0,
spi-mpc52xx.c:477:				  "mpc5200-spi-modf", ms);
spi-mpc52xx.c:478:		rc |= request_irq(ms->irq1, mpc52xx_spi_irq, 0,
spi-mpc52xx.c:479:				  "mpc5200-spi-spif", ms);
spi-mpc52xx.c:481:			free_irq(ms->irq0, ms);
spi-mpc52xx.c:482:			free_irq(ms->irq1, ms);
spi-mpc52xx.c:483:			ms->irq0 = ms->irq1 = 0;
spi-mpc52xx.c:487:		ms->irq0 = ms->irq1 = 0;
spi-mpc52xx.c:490:	if (!ms->irq0)
spi-mpc52xx.c:491:		dev_info(&op->dev, "using polled mode\n");
spi-mpc52xx.c:493:	dev_dbg(&op->dev, "registering spi_master struct\n");
spi-mpc52xx.c:498:	dev_info(&ms->master->dev, "registered MPC5200 SPI bus\n");
spi-mpc52xx.c:503:	dev_err(&ms->master->dev, "initialization failed\n");
spi-mpc52xx.c:505:	while (i-- > 0)
spi-mpc52xx.c:506:		gpio_free(ms->gpio_cs[i]);
spi-mpc52xx.c:508:	kfree(ms->gpio_cs);
spi-mpc52xx.c:523:	free_irq(ms->irq0, ms);
spi-mpc52xx.c:524:	free_irq(ms->irq1, ms);
spi-mpc52xx.c:526:	for (i = 0; i < ms->gpio_cs_count; i++)
spi-mpc52xx.c:527:		gpio_free(ms->gpio_cs[i]);
spi-mpc52xx.c:529:	kfree(ms->gpio_cs);
spi-mpc52xx.c:531:	iounmap(ms->regs);
spi-mpc52xx.c:538:	{ .compatible = "fsl,mpc5200-spi", },
spi-mpc52xx.c:545:		.name = "mpc52xx-spi",
spi-fsl-spi.h:59: *	SPI MODE 0 (inactive low, phase middle, MSB, 8-bit length, slow clk
spi-txx9.c:5: * Copyright (C) 2000-2001 Toshiba Corporation
spi-txx9.c:7: * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
spi-txx9.c:12: * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
spi-txx9.c:14: * Convert to generic SPI framework - Atsushi Nemoto (anemo@mba.ocn.ne.jp)
spi-txx9.c:89:	return __raw_readl(c->membase + reg);
spi-txx9.c:93:	__raw_writel(val, c->membase + reg);
spi-txx9.c:99:	int val = (spi->mode & SPI_CS_HIGH) ? on : !on;
spi-txx9.c:103:		if (c->last_chipselect >= 0)
spi-txx9.c:104:			gpio_set_value(c->last_chipselect,
spi-txx9.c:105:					!c->last_chipselect_val);
spi-txx9.c:106:		c->last_chipselect = spi->chip_select;
spi-txx9.c:107:		c->last_chipselect_val = val;
spi-txx9.c:109:		c->last_chipselect = -1;
spi-txx9.c:112:	gpio_set_value(spi->chip_select, val);
spi-txx9.c:118:	struct txx9spi *c = spi_master_get_devdata(spi->master);
spi-txx9.c:120:	if (!spi->max_speed_hz)
spi-txx9.c:121:		return -EINVAL;
spi-txx9.c:123:	if (gpio_direction_output(spi->chip_select,
spi-txx9.c:124:			!(spi->mode & SPI_CS_HIGH))) {
spi-txx9.c:125:		dev_err(&spi->dev, "Cannot setup GPIO for chipselect.\n");
spi-txx9.c:126:		return -EINVAL;
spi-txx9.c:130:	spin_lock(&c->lock);
spi-txx9.c:131:	txx9spi_cs_func(spi, c, 0, (NSEC_PER_SEC / 2) / spi->max_speed_hz);
spi-txx9.c:132:	spin_unlock(&c->lock);
spi-txx9.c:144:	wake_up(&c->waitq);
spi-txx9.c:150:	struct spi_device *spi = m->spi;
spi-txx9.c:160:	cs_delay = 100 + (NSEC_PER_SEC / 2) / spi->max_speed_hz;
spi-txx9.c:164:		dev_err(&spi->dev, "Bad mode.\n");
spi-txx9.c:165:		status = -EIO;
spi-txx9.c:173:			| ((spi->mode & SPI_CPOL) ? TXx9_SPCR0_SPOL : 0)
spi-txx9.c:174:			| ((spi->mode & SPI_CPHA) ? TXx9_SPCR0_SPHA : 0)
spi-txx9.c:178:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-txx9.c:179:		const void *txbuf = t->tx_buf;
spi-txx9.c:180:		void *rxbuf = t->rx_buf;
spi-txx9.c:182:		unsigned int len = t->len;
spi-txx9.c:184:		u32 speed_hz = t->speed_hz;
spi-txx9.c:185:		u8 bits_per_word = t->bits_per_word;
spi-txx9.c:191:			int n = DIV_ROUND_UP(c->baseclk, speed_hz) - 1;
spi-txx9.c:207:		cs_change = t->cs_change;
spi-txx9.c:220:			cr0 |= (count - 1) << 12;
spi-txx9.c:236:			wait_event(c->waitq,
spi-txx9.c:249:			len -= count * wsize;
spi-txx9.c:251:		m->actual_length += t->len;
spi-txx9.c:252:		if (t->delay_usecs)
spi-txx9.c:253:			udelay(t->delay_usecs);
spi-txx9.c:257:		if (t->transfer_list.next == &m->transfers)
spi-txx9.c:259:		/* sometimes a short mid-message deselect of the chip
spi-txx9.c:266:	m->status = status;
spi-txx9.c:267:	if (m->complete)
spi-txx9.c:268:		m->complete(m->context);
spi-txx9.c:286:	spin_lock_irqsave(&c->lock, flags);
spi-txx9.c:287:	while (!list_empty(&c->queue)) {
spi-txx9.c:290:		m = container_of(c->queue.next, struct spi_message, queue);
spi-txx9.c:291:		list_del_init(&m->queue);
spi-txx9.c:292:		spin_unlock_irqrestore(&c->lock, flags);
spi-txx9.c:296:		spin_lock_irqsave(&c->lock, flags);
spi-txx9.c:298:	spin_unlock_irqrestore(&c->lock, flags);
spi-txx9.c:303:	struct spi_master *master = spi->master;
spi-txx9.c:308:	m->actual_length = 0;
spi-txx9.c:311:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-txx9.c:312:		if (!t->tx_buf && !t->rx_buf && t->len)
spi-txx9.c:313:			return -EINVAL;
spi-txx9.c:316:	spin_lock_irqsave(&c->lock, flags);
spi-txx9.c:317:	list_add_tail(&m->queue, &c->queue);
spi-txx9.c:318:	queue_work(c->workqueue, &c->work);
spi-txx9.c:319:	spin_unlock_irqrestore(&c->lock, flags);
spi-txx9.c:329:	int ret = -ENODEV;
spi-txx9.c:333:	master = spi_alloc_master(&dev->dev, sizeof(*c));
spi-txx9.c:339:	INIT_WORK(&c->work, txx9spi_work);
spi-txx9.c:340:	spin_lock_init(&c->lock);
spi-txx9.c:341:	INIT_LIST_HEAD(&c->queue);
spi-txx9.c:342:	init_waitqueue_head(&c->waitq);
spi-txx9.c:344:	c->clk = devm_clk_get(&dev->dev, "spi-baseclk");
spi-txx9.c:345:	if (IS_ERR(c->clk)) {
spi-txx9.c:346:		ret = PTR_ERR(c->clk);
spi-txx9.c:347:		c->clk = NULL;
spi-txx9.c:350:	ret = clk_enable(c->clk);
spi-txx9.c:352:		c->clk = NULL;
spi-txx9.c:355:	c->baseclk = clk_get_rate(c->clk);
spi-txx9.c:356:	master->min_speed_hz = DIV_ROUND_UP(c->baseclk, SPI_MAX_DIVIDER + 1);
spi-txx9.c:357:	master->max_speed_hz = c->baseclk / (SPI_MIN_DIVIDER + 1);
spi-txx9.c:360:	c->membase = devm_ioremap_resource(&dev->dev, res);
spi-txx9.c:361:	if (IS_ERR(c->membase))
spi-txx9.c:372:	ret = devm_request_irq(&dev->dev, irq, txx9spi_interrupt, 0,
spi-txx9.c:377:	c->workqueue = create_singlethread_workqueue(
spi-txx9.c:378:				dev_name(master->dev.parent));
spi-txx9.c:379:	if (!c->workqueue)
spi-txx9.c:381:	c->last_chipselect = -1;
spi-txx9.c:383:	dev_info(&dev->dev, "at %#llx, irq %d, %dMHz\n",
spi-txx9.c:384:		 (unsigned long long)res->start, irq,
spi-txx9.c:385:		 (c->baseclk + 500000) / 1000000);
spi-txx9.c:387:	/* the spi->mode bits understood by this driver: */
spi-txx9.c:388:	master->mode_bits = SPI_CS_HIGH | SPI_CPOL | SPI_CPHA;
spi-txx9.c:390:	master->bus_num = dev->id;
spi-txx9.c:391:	master->setup = txx9spi_setup;
spi-txx9.c:392:	master->transfer = txx9spi_transfer;
spi-txx9.c:393:	master->num_chipselect = (u16)UINT_MAX; /* any GPIO numbers */
spi-txx9.c:394:	master->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);
spi-txx9.c:396:	ret = devm_spi_register_master(&dev->dev, master);
spi-txx9.c:401:	ret = -EBUSY;
spi-txx9.c:403:	if (c->workqueue)
spi-txx9.c:404:		destroy_workqueue(c->workqueue);
spi-txx9.c:405:	clk_disable(c->clk);
spi-txx9.c:415:	destroy_workqueue(c->workqueue);
spi-txx9.c:416:	clk_disable(c->clk);
spi-clps711x.c:4: *  Copyright (C) 2012-2014 Alexander Shiyan <shc_work@mail.ru>
spi-clps711x.c:23:#include <linux/platform_data/spi-clps711x.h>
spi-clps711x.c:25:#define DRIVER_NAME	"spi-clps711x"
spi-clps711x.c:43:	/* We are expect that SPI-device is not selected */
spi-clps711x.c:44:	gpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
spi-clps711x.c:53:	struct spi_device *spi = msg->spi;
spi-clps711x.c:56:	return regmap_update_bits(hw->syscon, SYSCON_OFFSET, SYSCON3_ADCCKNSEN,
spi-clps711x.c:57:				  (spi->mode & SPI_CPHA) ?
spi-clps711x.c:68:	clk_set_rate(hw->spi_clk, xfer->speed_hz ? : spi->max_speed_hz);
spi-clps711x.c:70:	hw->len = xfer->len;
spi-clps711x.c:71:	hw->bpw = xfer->bits_per_word;
spi-clps711x.c:72:	hw->tx_buf = (u8 *)xfer->tx_buf;
spi-clps711x.c:73:	hw->rx_buf = (u8 *)xfer->rx_buf;
spi-clps711x.c:76:	data = hw->tx_buf ? *hw->tx_buf++ : 0;
spi-clps711x.c:77:	writel(data | SYNCIO_FRMLEN(hw->bpw) | SYNCIO_TXFRMEN, hw->syncio);
spi-clps711x.c:89:	data = readb(hw->syncio);
spi-clps711x.c:90:	if (hw->rx_buf)
spi-clps711x.c:91:		*hw->rx_buf++ = data;
spi-clps711x.c:94:	if (--hw->len > 0) {
spi-clps711x.c:95:		data = hw->tx_buf ? *hw->tx_buf++ : 0;
spi-clps711x.c:96:		writel(data | SYNCIO_FRMLEN(hw->bpw) | SYNCIO_TXFRMEN,
spi-clps711x.c:97:		       hw->syncio);
spi-clps711x.c:107:	struct spi_clps711x_pdata *pdata = dev_get_platdata(&pdev->dev);
spi-clps711x.c:113:		dev_err(&pdev->dev, "No platform data supplied\n");
spi-clps711x.c:114:		return -EINVAL;
spi-clps711x.c:117:	if (pdata->num_chipselect < 1) {
spi-clps711x.c:118:		dev_err(&pdev->dev, "At least one CS must be defined\n");
spi-clps711x.c:119:		return -EINVAL;
spi-clps711x.c:126:	master = spi_alloc_master(&pdev->dev, sizeof(*hw));
spi-clps711x.c:128:		return -ENOMEM;
spi-clps711x.c:130:	master->cs_gpios = devm_kzalloc(&pdev->dev, sizeof(int) *
spi-clps711x.c:131:					pdata->num_chipselect, GFP_KERNEL);
spi-clps711x.c:132:	if (!master->cs_gpios) {
spi-clps711x.c:133:		ret = -ENOMEM;
spi-clps711x.c:137:	master->bus_num = pdev->id;
spi-clps711x.c:138:	master->mode_bits = SPI_CPHA | SPI_CS_HIGH;
spi-clps711x.c:139:	master->bits_per_word_mask =  SPI_BPW_RANGE_MASK(1, 8);
spi-clps711x.c:140:	master->num_chipselect = pdata->num_chipselect;
spi-clps711x.c:141:	master->setup = spi_clps711x_setup;
spi-clps711x.c:142:	master->prepare_message = spi_clps711x_prepare_message;
spi-clps711x.c:143:	master->transfer_one = spi_clps711x_transfer_one;
spi-clps711x.c:147:	for (i = 0; i < master->num_chipselect; i++) {
spi-clps711x.c:148:		master->cs_gpios[i] = pdata->chipselect[i];
spi-clps711x.c:149:		ret = devm_gpio_request(&pdev->dev, master->cs_gpios[i],
spi-clps711x.c:152:			dev_err(&pdev->dev, "Can't get CS GPIO %i\n", i);
spi-clps711x.c:157:	hw->spi_clk = devm_clk_get(&pdev->dev, NULL);
spi-clps711x.c:158:	if (IS_ERR(hw->spi_clk)) {
spi-clps711x.c:159:		ret = PTR_ERR(hw->spi_clk);
spi-clps711x.c:163:	hw->syscon = syscon_regmap_lookup_by_pdevname("syscon.3");
spi-clps711x.c:164:	if (IS_ERR(hw->syscon)) {
spi-clps711x.c:165:		ret = PTR_ERR(hw->syscon);
spi-clps711x.c:170:	hw->syncio = devm_ioremap_resource(&pdev->dev, res);
spi-clps711x.c:171:	if (IS_ERR(hw->syncio)) {
spi-clps711x.c:172:		ret = PTR_ERR(hw->syncio);
spi-clps711x.c:177:	regmap_update_bits(hw->syscon, SYSCON_OFFSET, SYSCON3_ADCCON, 0);
spi-clps711x.c:180:	readl(hw->syncio);
spi-clps711x.c:182:	ret = devm_request_irq(&pdev->dev, irq, spi_clps711x_isr, 0,
spi-clps711x.c:183:			       dev_name(&pdev->dev), master);
spi-clps711x.c:187:	ret = devm_spi_register_master(&pdev->dev, master);
spi-clps711x.c:189:		dev_info(&pdev->dev,
spi-clps711x.c:191:			 master->max_speed_hz);
spi-clps711x.c:195:	dev_err(&pdev->dev, "Failed to register master\n");
spi-bcm2835aux.c:7: * Based on: spi-bcm2835.c
spi-bcm2835aux.c:112:	return readl(bs->regs + reg);
spi-bcm2835aux.c:118:	writel(val, bs->regs + reg);
spi-bcm2835aux.c:124:	int count = min(bs->rx_len, 3);
spi-bcm2835aux.c:127:	if (bs->rx_buf) {
spi-bcm2835aux.c:130:			*bs->rx_buf++ = (data >> 24) & 0xff;
spi-bcm2835aux.c:133:			*bs->rx_buf++ = (data >> 16) & 0xff;
spi-bcm2835aux.c:136:			*bs->rx_buf++ = (data >> 8) & 0xff;
spi-bcm2835aux.c:139:			*bs->rx_buf++ = (data >> 0) & 0xff;
spi-bcm2835aux.c:140:			/* fallthrough - no default */
spi-bcm2835aux.c:143:	bs->rx_len -= count;
spi-bcm2835aux.c:144:	bs->pending -= count;
spi-bcm2835aux.c:155:	count = min(bs->tx_len, 3);
spi-bcm2835aux.c:158:		byte = bs->tx_buf ? *bs->tx_buf++ : 0;
spi-bcm2835aux.c:159:		data |= byte << (8 * (2 - i));
spi-bcm2835aux.c:162:	/* and set the variable bit-length */
spi-bcm2835aux.c:166:	bs->tx_len -= count;
spi-bcm2835aux.c:167:	bs->pending += count;
spi-bcm2835aux.c:169:	/* write to the correct TX-register */
spi-bcm2835aux.c:170:	if (bs->tx_len)
spi-bcm2835aux.c:189:	for (; bs->rx_len && (stat & BCM2835_AUX_SPI_STAT_RX_LVL);
spi-bcm2835aux.c:194:	while (bs->tx_len &&
spi-bcm2835aux.c:195:	       (bs->pending < 12) &&
spi-bcm2835aux.c:216:	if (!bs->rx_len) {
spi-bcm2835aux.c:218:		complete(&master->xfer_completion);
spi-bcm2835aux.c:231:	bcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1] |
spi-bcm2835aux.c:246:	bcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1]);
spi-bcm2835aux.c:247:	bcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL0, bs->cntl[0]);
spi-bcm2835aux.c:250:	while ((bs->tx_len) &&
spi-bcm2835aux.c:251:	       (bs->pending < 12) &&
spi-bcm2835aux.c:269:	bcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1]);
spi-bcm2835aux.c:270:	bcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL0, bs->cntl[0]);
spi-bcm2835aux.c:276:	while (bs->rx_len) {
spi-bcm2835aux.c:282:		if (bs->rx_len && time_after(jiffies, timeout)) {
spi-bcm2835aux.c:283:			dev_dbg_ratelimited(&spi->dev,
spi-bcm2835aux.c:284:					    "timeout period reached: jiffies: %lu remaining tx/rx: %d/%d - falling back to interrupt mode\n",
spi-bcm2835aux.c:285:					    jiffies - timeout,
spi-bcm2835aux.c:286:					    bs->tx_len, bs->rx_len);
spi-bcm2835aux.c:293:	/* Transfer complete - reset SPI HW */
spi-bcm2835aux.c:316:	bs->cntl[0] = BCM2835_AUX_SPI_CNTL0_ENABLE |
spi-bcm2835aux.c:319:	bs->cntl[1] = BCM2835_AUX_SPI_CNTL1_MSBF_IN;
spi-bcm2835aux.c:322:	spi_hz = tfr->speed_hz;
spi-bcm2835aux.c:323:	clk_hz = clk_get_rate(bs->clk);
spi-bcm2835aux.c:328:		speed = DIV_ROUND_UP(clk_hz, 2 * spi_hz) - 1;
spi-bcm2835aux.c:334:	bs->cntl[0] |= speed << BCM2835_AUX_SPI_CNTL0_SPEED_SHIFT;
spi-bcm2835aux.c:339:	if (spi->mode & SPI_CPOL)
spi-bcm2835aux.c:340:		bs->cntl[0] |= BCM2835_AUX_SPI_CNTL0_CPOL;
spi-bcm2835aux.c:341:	if (spi->mode & SPI_CPHA)
spi-bcm2835aux.c:342:		bs->cntl[0] |= BCM2835_AUX_SPI_CNTL0_CPHA_OUT |
spi-bcm2835aux.c:346:	bs->tx_buf = tfr->tx_buf;
spi-bcm2835aux.c:347:	bs->rx_buf = tfr->rx_buf;
spi-bcm2835aux.c:348:	bs->tx_len = tfr->len;
spi-bcm2835aux.c:349:	bs->rx_len = tfr->len;
spi-bcm2835aux.c:350:	bs->pending = 0;
spi-bcm2835aux.c:354:	 * chunk getting transferred - in our case the chunk size
spi-bcm2835aux.c:357:	xfer_time_us = tfr->len * 9 * 1000000;
spi-bcm2835aux.c:384:	master = spi_alloc_master(&pdev->dev, sizeof(*bs));
spi-bcm2835aux.c:386:		dev_err(&pdev->dev, "spi_alloc_master() failed\n");
spi-bcm2835aux.c:387:		return -ENOMEM;
spi-bcm2835aux.c:391:	master->mode_bits = BCM2835_AUX_SPI_MODE_BITS;
spi-bcm2835aux.c:392:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-bcm2835aux.c:393:	master->num_chipselect = -1;
spi-bcm2835aux.c:394:	master->transfer_one = bcm2835aux_spi_transfer_one;
spi-bcm2835aux.c:395:	master->handle_err = bcm2835aux_spi_handle_err;
spi-bcm2835aux.c:396:	master->dev.of_node = pdev->dev.of_node;
spi-bcm2835aux.c:402:	bs->regs = devm_ioremap_resource(&pdev->dev, res);
spi-bcm2835aux.c:403:	if (IS_ERR(bs->regs)) {
spi-bcm2835aux.c:404:		err = PTR_ERR(bs->regs);
spi-bcm2835aux.c:408:	bs->clk = devm_clk_get(&pdev->dev, NULL);
spi-bcm2835aux.c:409:	if ((!bs->clk) || (IS_ERR(bs->clk))) {
spi-bcm2835aux.c:410:		err = PTR_ERR(bs->clk);
spi-bcm2835aux.c:411:		dev_err(&pdev->dev, "could not get clk: %d\n", err);
spi-bcm2835aux.c:415:	bs->irq = platform_get_irq(pdev, 0);
spi-bcm2835aux.c:416:	if (bs->irq <= 0) {
spi-bcm2835aux.c:417:		dev_err(&pdev->dev, "could not get IRQ: %d\n", bs->irq);
spi-bcm2835aux.c:418:		err = bs->irq ? bs->irq : -ENODEV;
spi-bcm2835aux.c:423:	err = clk_prepare_enable(bs->clk);
spi-bcm2835aux.c:425:		dev_err(&pdev->dev, "could not prepare clock: %d\n", err);
spi-bcm2835aux.c:430:	clk_hz = clk_get_rate(bs->clk);
spi-bcm2835aux.c:432:		dev_err(&pdev->dev, "clock returns 0 Hz\n");
spi-bcm2835aux.c:433:		err = -ENODEV;
spi-bcm2835aux.c:437:	/* reset SPI-HW block */
spi-bcm2835aux.c:440:	err = devm_request_irq(&pdev->dev, bs->irq,
spi-bcm2835aux.c:443:			       dev_name(&pdev->dev), master);
spi-bcm2835aux.c:445:		dev_err(&pdev->dev, "could not request IRQ: %d\n", err);
spi-bcm2835aux.c:449:	err = devm_spi_register_master(&pdev->dev, master);
spi-bcm2835aux.c:451:		dev_err(&pdev->dev, "could not register SPI master: %d\n", err);
spi-bcm2835aux.c:458:	clk_disable_unprepare(bs->clk);
spi-bcm2835aux.c:472:	clk_disable_unprepare(bs->clk);
spi-bcm2835aux.c:478:	{ .compatible = "brcm,bcm2835-aux-spi", },
spi-bcm2835aux.c:485:		.name		= "spi-bcm2835aux",
spi-xlp.c:2: * Copyright (C) 2003-2015 Broadcom Corporation
spi-xlp.c:115:	return readl(priv->base + regoff + cs * SPI_CS_OFFSET);
spi-xlp.c:121:	writel(val, priv->base + regoff + cs * SPI_CS_OFFSET);
spi-xlp.c:127:	writel(val, priv->base + regoff);
spi-xlp.c:149:	xspi = spi_master_get_devdata(spi->master);
spi-xlp.c:150:	cs = spi->chip_select;
spi-xlp.c:154:	fdiv = DIV_ROUND_UP(xspi->spi_clk, spi->max_speed_hz);
spi-xlp.c:163:	if (spi->mode & SPI_CPHA)
spi-xlp.c:167:	if (spi->mode & SPI_CPOL)
spi-xlp.c:171:	if (!(spi->mode & SPI_CS_HIGH))
spi-xlp.c:175:	if (spi->mode & SPI_LSB_FIRST)
spi-xlp.c:193:	rxfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_FIFO_WCNT);
spi-xlp.c:196:		rx_data = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_RXDATA_FIFO);
spi-xlp.c:198:		nbytes = min(xspi->rx_len, 4);
spi-xlp.c:199:		for (i = nbytes - 1; i >= 0; i--, j++)
spi-xlp.c:200:			xspi->rx_buf[i] = (rx_data >> (j * 8)) & 0xff;
spi-xlp.c:202:		xspi->rx_len -= nbytes;
spi-xlp.c:203:		xspi->rx_buf += nbytes;
spi-xlp.c:204:		rxfifo_cnt--;
spi-xlp.c:213:	txfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_FIFO_WCNT);
spi-xlp.c:216:	while (xspi->tx_len && (txfifo_cnt < XLP_SPI_FIFO_SIZE)) {
spi-xlp.c:219:		nbytes = min(xspi->tx_len, 4);
spi-xlp.c:220:		for (i = nbytes - 1; i >= 0; i--, j++)
spi-xlp.c:221:			tx_data |= xspi->tx_buf[i] << (j * 8);
spi-xlp.c:223:		xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_TXDATA_FIFO, tx_data);
spi-xlp.c:224:		xspi->tx_len -= nbytes;
spi-xlp.c:225:		xspi->tx_buf += nbytes;
spi-xlp.c:235:	stat = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_STATUS) &
spi-xlp.c:241:		if (xspi->tx_len)
spi-xlp.c:244:			xspi->txerrors++;
spi-xlp.c:248:		if (xspi->rx_len)
spi-xlp.c:251:			xspi->rxerrors++;
spi-xlp.c:255:	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_STATUS, stat);
spi-xlp.c:257:		complete(&xspi->done);
spi-xlp.c:267:	if (xspi->tx_buf)
spi-xlp.c:269:	if (xspi->rx_buf)
spi-xlp.c:273:	cmd |= ((xfer_len * 8 - 1) << XLP_SPI_XFR_BITCNT_SHIFT);
spi-xlp.c:274:	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_CMD, cmd);
spi-xlp.c:284:	xs->tx_buf = tx_buf;
spi-xlp.c:285:	xs->rx_buf = rx_buf;
spi-xlp.c:286:	xs->tx_len = (xs->tx_buf == NULL) ? 0 : xfer_len;
spi-xlp.c:287:	xs->rx_len = (xs->rx_buf == NULL) ? 0 : xfer_len;
spi-xlp.c:288:	xs->txerrors = xs->rxerrors = 0;
spi-xlp.c:291:	if (xs->tx_len)
spi-xlp.c:301:	if (xs->tx_len)
spi-xlp.c:308:	xlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, intr_mask);
spi-xlp.c:310:	timeout = wait_for_completion_timeout(&xs->done,
spi-xlp.c:313:	xlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, 0x0);
spi-xlp.c:315:		dev_err(&xs->dev, "xfer timedout!\n");
spi-xlp.c:318:	if (xs->txerrors || xs->rxerrors)
spi-xlp.c:319:		dev_err(&xs->dev, "Over/Underflow rx %d tx %d xfer %d!\n",
spi-xlp.c:320:				xs->rxerrors, xs->txerrors, xfer_len);
spi-xlp.c:324:	return -ETIMEDOUT;
spi-xlp.c:333:	tx_buf = t->tx_buf;
spi-xlp.c:334:	rx_buf = t->rx_buf;
spi-xlp.c:335:	bytesleft = t->len;
spi-xlp.c:342:					bytesleft, xs->cmd_cont);
spi-xlp.c:345:		bytesleft -= sz;
spi-xlp.c:361:	xspi->cs = spi->chip_select;
spi-xlp.c:362:	xspi->dev = spi->dev;
spi-xlp.c:365:		xspi->cmd_cont = 0;
spi-xlp.c:367:		xspi->cmd_cont = 1;
spi-xlp.c:370:		ret = -EIO;
spi-xlp.c:384:	xspi = devm_kzalloc(&pdev->dev, sizeof(*xspi), GFP_KERNEL);
spi-xlp.c:386:		return -ENOMEM;
spi-xlp.c:389:	xspi->base = devm_ioremap_resource(&pdev->dev, res);
spi-xlp.c:390:	if (IS_ERR(xspi->base))
spi-xlp.c:391:		return PTR_ERR(xspi->base);
spi-xlp.c:395:		dev_err(&pdev->dev, "no IRQ resource found: %d\n", irq);
spi-xlp.c:398:	err = devm_request_irq(&pdev->dev, irq, xlp_spi_interrupt, 0,
spi-xlp.c:399:			pdev->name, xspi);
spi-xlp.c:401:		dev_err(&pdev->dev, "unable to request irq %d\n", irq);
spi-xlp.c:405:	clk = devm_clk_get(&pdev->dev, NULL);
spi-xlp.c:407:		dev_err(&pdev->dev, "could not get spi clock\n");
spi-xlp.c:408:		return -ENODEV;
spi-xlp.c:410:	xspi->spi_clk = clk_get_rate(clk);
spi-xlp.c:412:	master = spi_alloc_master(&pdev->dev, 0);
spi-xlp.c:414:		dev_err(&pdev->dev, "could not alloc master\n");
spi-xlp.c:415:		return -ENOMEM;
spi-xlp.c:418:	master->bus_num = 0;
spi-xlp.c:419:	master->num_chipselect = XLP_SPI_MAX_CS;
spi-xlp.c:420:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-xlp.c:421:	master->setup = xlp_spi_setup;
spi-xlp.c:422:	master->transfer_one = xlp_spi_transfer_one;
spi-xlp.c:423:	master->dev.of_node = pdev->dev.of_node;
spi-xlp.c:425:	init_completion(&xspi->done);
spi-xlp.c:430:	err = devm_spi_register_master(&pdev->dev, master);
spi-xlp.c:432:		dev_err(&pdev->dev, "spi register master failed!\n");
spi-xlp.c:441:	{ .compatible = "netlogic,xlp832-spi" },
spi-xlp.c:448:		.name	= "xlp-spi",
 spi.o
spi-xtensa-xtfpga.c:37:	__raw_writel(val, spi->regs + addr);
spi-xtensa-xtfpga.c:43:	return __raw_readl(spi->regs + addr);
spi-xtensa-xtfpga.c:59:	struct xtfpga_spi *xspi = spi_master_get_devdata(spi->master);
spi-xtensa-xtfpga.c:61:	xspi->data = (xspi->data << bits) | (v & GENMASK(bits - 1, 0));
spi-xtensa-xtfpga.c:62:	xspi->data_sz += bits;
spi-xtensa-xtfpga.c:63:	if (xspi->data_sz >= 16) {
spi-xtensa-xtfpga.c:65:				   xspi->data >> (xspi->data_sz - 16));
spi-xtensa-xtfpga.c:66:		xspi->data_sz -= 16;
spi-xtensa-xtfpga.c:77:	struct xtfpga_spi *xspi = spi_master_get_devdata(spi->master);
spi-xtensa-xtfpga.c:79:	WARN_ON(xspi->data_sz != 0);
spi-xtensa-xtfpga.c:80:	xspi->data_sz = 0;
spi-xtensa-xtfpga.c:90:	master = spi_alloc_master(&pdev->dev, sizeof(struct xtfpga_spi));
spi-xtensa-xtfpga.c:92:		return -ENOMEM;
spi-xtensa-xtfpga.c:94:	master->flags = SPI_MASTER_NO_RX;
spi-xtensa-xtfpga.c:95:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 16);
spi-xtensa-xtfpga.c:96:	master->bus_num = pdev->dev.id;
spi-xtensa-xtfpga.c:97:	master->dev.of_node = pdev->dev.of_node;
spi-xtensa-xtfpga.c:100:	xspi->bitbang.master = master;
spi-xtensa-xtfpga.c:101:	xspi->bitbang.chipselect = xtfpga_spi_chipselect;
spi-xtensa-xtfpga.c:102:	xspi->bitbang.txrx_word[SPI_MODE_0] = xtfpga_spi_txrx_word;
spi-xtensa-xtfpga.c:106:		dev_err(&pdev->dev, "No memory resource\n");
spi-xtensa-xtfpga.c:107:		ret = -ENODEV;
spi-xtensa-xtfpga.c:110:	xspi->regs = devm_ioremap_resource(&pdev->dev, mem);
spi-xtensa-xtfpga.c:111:	if (IS_ERR(xspi->regs)) {
spi-xtensa-xtfpga.c:112:		ret = PTR_ERR(xspi->regs);
spi-xtensa-xtfpga.c:119:		dev_err(&pdev->dev, "Device stuck in busy state\n");
spi-xtensa-xtfpga.c:120:		ret = -EBUSY;
spi-xtensa-xtfpga.c:124:	ret = spi_bitbang_start(&xspi->bitbang);
spi-xtensa-xtfpga.c:126:		dev_err(&pdev->dev, "spi_bitbang_start failed\n");
spi-xtensa-xtfpga.c:142:	spi_bitbang_stop(&xspi->bitbang);
spi-xtensa-xtfpga.c:152:	{ .compatible = "cdns,xtfpga-spi", },
spi-bcm63xx.c:4: * Copyright (C) 2009-2012 Florian Fainelli <florian@openwrt.org>
spi-bcm63xx.c:32:#define SPI_6348_CMD			0x00	/* 16-bits register */
spi-bcm63xx.c:41:#define SPI_6348_MSG_CTL		0x40	/* 8-bits register */
spi-bcm63xx.c:50:#define SPI_6358_MSG_CTL		0x00	/* 16-bits register */
spi-bcm63xx.c:56:#define SPI_6358_CMD			0x700	/* 16-bits register */
spi-bcm63xx.c:164:	return readb(bs->regs + bs->reg_offsets[offset]);
spi-bcm63xx.c:171:	return ioread16be(bs->regs + bs->reg_offsets[offset]);
spi-bcm63xx.c:173:	return readw(bs->regs + bs->reg_offsets[offset]);
spi-bcm63xx.c:180:	writeb(value, bs->regs + bs->reg_offsets[offset]);
spi-bcm63xx.c:187:	iowrite16be(value, bs->regs + bs->reg_offsets[offset]);
spi-bcm63xx.c:189:	writew(value, bs->regs + bs->reg_offsets[offset]);
spi-bcm63xx.c:206:	struct bcm63xx_spi *bs = spi_master_get_devdata(spi->master);
spi-bcm63xx.c:212:		if (t->speed_hz >= bcm63xx_spi_freq_table[i][0]) {
spi-bcm63xx.c:228:	dev_dbg(&spi->dev, "Setting clock register to %02x (hz %d)\n",
spi-bcm63xx.c:229:		clk_cfg, t->speed_hz);
spi-bcm63xx.c:232:/* the spi->mode bits understood by this driver: */
spi-bcm63xx.c:238:	struct bcm63xx_spi *bs = spi_master_get_devdata(spi->master);
spi-bcm63xx.c:249:	dev_dbg(&spi->dev, "txrx: tx %p, rx %p, len %d\n",
spi-bcm63xx.c:250:		t->tx_buf, t->rx_buf, t->len);
spi-bcm63xx.c:252:	if (num_transfers > 1 && t->tx_buf && t->len <= BCM63XX_SPI_MAX_PREPEND)
spi-bcm63xx.c:253:		prepend_len = t->len;
spi-bcm63xx.c:257:		if (t->tx_buf) {
spi-bcm63xx.c:259:			memcpy_toio(bs->tx_io + len, t->tx_buf, t->len);
spi-bcm63xx.c:266:		if (t->rx_buf) {
spi-bcm63xx.c:268:			/* prepend is half-duplex write only */
spi-bcm63xx.c:273:		len += t->len;
spi-bcm63xx.c:275:		t = list_entry(t->transfer_list.next, struct spi_transfer,
spi-bcm63xx.c:279:	reinit_completion(&bs->done);
spi-bcm63xx.c:285:		msg_ctl |= (SPI_FD_RW << bs->msg_type_shift);
spi-bcm63xx.c:287:		msg_ctl |= (SPI_HD_R << bs->msg_type_shift);
spi-bcm63xx.c:289:		msg_ctl |= (SPI_HD_W << bs->msg_type_shift);
spi-bcm63xx.c:291:	switch (bs->msg_ctl_width) {
spi-bcm63xx.c:303:	cmd |= (spi->chip_select << SPI_CMD_DEVICE_ID_SHIFT);
spi-bcm63xx.c:309:	timeout = wait_for_completion_timeout(&bs->done, HZ);
spi-bcm63xx.c:311:		return -ETIMEDOUT;
spi-bcm63xx.c:320:		if (t->rx_buf)
spi-bcm63xx.c:321:			memcpy_fromio(t->rx_buf, bs->rx_io + len, t->len);
spi-bcm63xx.c:324:			len += t->len;
spi-bcm63xx.c:326:		t = list_entry(t->transfer_list.next, struct spi_transfer,
spi-bcm63xx.c:338:	struct spi_device *spi = m->spi;
spi-bcm63xx.c:347:	 * full-duplex transfers.
spi-bcm63xx.c:349:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-bcm63xx.c:354:		total_len += t->len;
spi-bcm63xx.c:356:		if (n_transfers == 2 && !first->rx_buf && !t->tx_buf &&
spi-bcm63xx.c:357:		    first->len <= BCM63XX_SPI_MAX_PREPEND)
spi-bcm63xx.c:359:		else if (can_use_prepend && t->tx_buf)
spi-bcm63xx.c:364:		     total_len > (bs->fifo_size + BCM63XX_SPI_MAX_PREPEND)) ||
spi-bcm63xx.c:365:		    (!can_use_prepend && total_len > bs->fifo_size)) {
spi-bcm63xx.c:366:			dev_err(&spi->dev, "unable to do transfers larger than FIFO size (%i > %i)\n",
spi-bcm63xx.c:367:				total_len, bs->fifo_size);
spi-bcm63xx.c:368:			status = -EINVAL;
spi-bcm63xx.c:373:		if (t->speed_hz != first->speed_hz) {
spi-bcm63xx.c:374:			dev_err(&spi->dev, "unable to change speed between transfers\n");
spi-bcm63xx.c:375:			status = -EINVAL;
spi-bcm63xx.c:380:		if (t->delay_usecs) {
spi-bcm63xx.c:381:			dev_err(&spi->dev, "unable to keep CS asserted after transfer\n");
spi-bcm63xx.c:382:			status = -EINVAL;
spi-bcm63xx.c:386:		if (t->cs_change ||
spi-bcm63xx.c:387:		    list_is_last(&t->transfer_list, &m->transfers)) {
spi-bcm63xx.c:396:			m->actual_length += total_len;
spi-bcm63xx.c:405:	m->status = status;
spi-bcm63xx.c:427:		complete(&bs->done);
spi-bcm63xx.c:470:		.name = "bcm6348-spi",
spi-bcm63xx.c:474:		.name = "bcm6358-spi",
spi-bcm63xx.c:485:	struct device *dev = &pdev->dev;
spi-bcm63xx.c:492:	if (!pdev->id_entry->driver_data)
spi-bcm63xx.c:493:		return -EINVAL;
spi-bcm63xx.c:495:	bcm63xx_spireg = (const unsigned long *)pdev->id_entry->driver_data;
spi-bcm63xx.c:512:		return -ENOMEM;
spi-bcm63xx.c:516:	init_completion(&bs->done);
spi-bcm63xx.c:519:	bs->pdev = pdev;
spi-bcm63xx.c:522:	bs->regs = devm_ioremap_resource(&pdev->dev, r);
spi-bcm63xx.c:523:	if (IS_ERR(bs->regs)) {
spi-bcm63xx.c:524:		ret = PTR_ERR(bs->regs);
spi-bcm63xx.c:528:	bs->irq = irq;
spi-bcm63xx.c:529:	bs->clk = clk;
spi-bcm63xx.c:530:	bs->reg_offsets = bcm63xx_spireg;
spi-bcm63xx.c:531:	bs->fifo_size = bs->reg_offsets[SPI_MSG_DATA_SIZE];
spi-bcm63xx.c:533:	ret = devm_request_irq(&pdev->dev, irq, bcm63xx_spi_interrupt, 0,
spi-bcm63xx.c:534:							pdev->name, master);
spi-bcm63xx.c:540:	master->bus_num = BCM63XX_SPI_BUS_NUM;
spi-bcm63xx.c:541:	master->num_chipselect = BCM63XX_SPI_MAX_CS;
spi-bcm63xx.c:542:	master->transfer_one_message = bcm63xx_spi_transfer_one;
spi-bcm63xx.c:543:	master->mode_bits = MODEBITS;
spi-bcm63xx.c:544:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-bcm63xx.c:545:	master->auto_runtime_pm = true;
spi-bcm63xx.c:546:	bs->msg_type_shift = bs->reg_offsets[SPI_MSG_TYPE_SHIFT];
spi-bcm63xx.c:547:	bs->msg_ctl_width = bs->reg_offsets[SPI_MSG_CTL_WIDTH];
spi-bcm63xx.c:548:	bs->tx_io = (u8 *)(bs->regs + bs->reg_offsets[SPI_MSG_DATA]);
spi-bcm63xx.c:549:	bs->rx_io = (const u8 *)(bs->regs + bs->reg_offsets[SPI_RX_DATA]);
spi-bcm63xx.c:552:	ret = clk_prepare_enable(bs->clk);
spi-bcm63xx.c:566:		 r, irq, bs->fifo_size);
spi-bcm63xx.c:586:	clk_disable_unprepare(bs->clk);
spi-bcm63xx.c:599:	clk_disable_unprepare(bs->clk);
spi-bcm63xx.c:610:	ret = clk_prepare_enable(bs->clk);
spi-bcm63xx.c:626:		.name	= "bcm63xx-spi",
spi-tle62x0.c:43:	unsigned char *buff = st->tx_buff;
spi-tle62x0.c:44:	unsigned int gpio_state = st->gpio_state;
spi-tle62x0.c:48:	if (st->nr_gpio == 16) {
spi-tle62x0.c:55:	dev_dbg(&st->us->dev, "buff %3ph\n", buff);
spi-tle62x0.c:57:	return spi_write(st->us, buff, (st->nr_gpio == 16) ? 3 : 2);
spi-tle62x0.c:62:	unsigned char *txbuff = st->tx_buff;
spi-tle62x0.c:65:		.rx_buf		= st->rx_buff,
spi-tle62x0.c:66:		.len		= (st->nr_gpio * 2) / 8,
spi-tle62x0.c:78:	return spi_sync(st->us, &msg);
spi-tle62x0.c:104:	unsigned char *buff = st->rx_buff;
spi-tle62x0.c:109:	mutex_lock(&st->lock);
spi-tle62x0.c:113:		mutex_unlock(&st->lock);
spi-tle62x0.c:117:	for (ptr = 0; ptr < (st->nr_gpio * 2)/8; ptr += 1) {
spi-tle62x0.c:124:	for (ptr = 0; ptr < st->nr_gpio; ptr++) {
spi-tle62x0.c:130:	mutex_unlock(&st->lock);
spi-tle62x0.c:131:	return bp - buf;
spi-tle62x0.c:143:	mutex_lock(&st->lock);
spi-tle62x0.c:144:	value = (st->gpio_state >> gpio_num) & 1;
spi-tle62x0.c:145:	mutex_unlock(&st->lock);
spi-tle62x0.c:161:		return -EINVAL;
spi-tle62x0.c:165:	mutex_lock(&st->lock);
spi-tle62x0.c:168:		st->gpio_state |= 1 << gpio_num;
spi-tle62x0.c:170:		st->gpio_state &= ~(1 << gpio_num);
spi-tle62x0.c:173:	mutex_unlock(&st->lock);
spi-tle62x0.c:239:	return -1;
spi-tle62x0.c:249:	pdata = dev_get_platdata(&spi->dev);
spi-tle62x0.c:251:		dev_err(&spi->dev, "no device data specified\n");
spi-tle62x0.c:252:		return -EINVAL;
spi-tle62x0.c:257:		return -ENOMEM;
spi-tle62x0.c:259:	st->us = spi;
spi-tle62x0.c:260:	st->nr_gpio = pdata->gpio_count;
spi-tle62x0.c:261:	st->gpio_state = pdata->init_state;
spi-tle62x0.c:263:	mutex_init(&st->lock);
spi-tle62x0.c:265:	ret = device_create_file(&spi->dev, &dev_attr_status_show);
spi-tle62x0.c:267:		dev_err(&spi->dev, "cannot create status attribute\n");
spi-tle62x0.c:271:	for (ptr = 0; ptr < pdata->gpio_count; ptr++) {
spi-tle62x0.c:272:		ret = device_create_file(&spi->dev, gpio_attrs[ptr]);
spi-tle62x0.c:274:			dev_err(&spi->dev, "cannot create gpio attribute\n");
spi-tle62x0.c:284:	while (--ptr >= 0)
spi-tle62x0.c:285:		device_remove_file(&spi->dev, gpio_attrs[ptr]);
spi-tle62x0.c:287:	device_remove_file(&spi->dev, &dev_attr_status_show);
spi-tle62x0.c:299:	for (ptr = 0; ptr < st->nr_gpio; ptr++)
spi-tle62x0.c:300:		device_remove_file(&spi->dev, gpio_attrs[ptr]);
spi-tle62x0.c:302:	device_remove_file(&spi->dev, &dev_attr_status_show);
spi-ath79.c:4: * Copyright (C) 2009-2011 Gabor Juhos <juhosg@openwrt.org>
spi-ath79.c:6: * This driver has been based on the spi-gpio.c:
spi-ath79.c:28:#include <asm/mach-ath79/ar71xx_regs.h>
spi-ath79.c:29:#include <asm/mach-ath79/ath79_spi_platform.h>
spi-ath79.c:31:#define DRV_NAME	"ath79-spi"
spi-ath79.c:47:	return ioread32(sp->base + reg);
spi-ath79.c:52:	iowrite32(val, sp->base + reg);
spi-ath79.c:57:	return spi_master_get_devdata(spi->master);
spi-ath79.c:62:	if (nsecs > sp->rrw_delay)
spi-ath79.c:63:		ndelay(nsecs - sp->rrw_delay);
spi-ath79.c:69:	int cs_high = (spi->mode & SPI_CS_HIGH) ? is_active : !is_active;
spi-ath79.c:73:		if (spi->mode & SPI_CPOL)
spi-ath79.c:74:			sp->ioc_base |= AR71XX_SPI_IOC_CLK;
spi-ath79.c:76:			sp->ioc_base &= ~AR71XX_SPI_IOC_CLK;
spi-ath79.c:78:		ath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);
spi-ath79.c:81:	if (spi->chip_select) {
spi-ath79.c:82:		/* SPI is normally active-low */
spi-ath79.c:83:		gpio_set_value(spi->cs_gpio, cs_high);
spi-ath79.c:86:			sp->ioc_base |= AR71XX_SPI_IOC_CS0;
spi-ath79.c:88:			sp->ioc_base &= ~AR71XX_SPI_IOC_CS0;
spi-ath79.c:90:		ath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);
spi-ath79.c:101:	sp->reg_ctrl = ath79_spi_rr(sp, AR71XX_SPI_REG_CTRL);
spi-ath79.c:102:	sp->ioc_base = ath79_spi_rr(sp, AR71XX_SPI_REG_IOC);
spi-ath79.c:111:	ath79_spi_wr(sp, AR71XX_SPI_REG_CTRL, sp->reg_ctrl);
spi-ath79.c:121:	if (spi->chip_select && !gpio_is_valid(spi->cs_gpio))
spi-ath79.c:122:		return -EINVAL;
spi-ath79.c:125:	if (spi->chip_select) {
spi-ath79.c:129:		if (spi->mode & SPI_CS_HIGH)
spi-ath79.c:134:		status = gpio_request_one(spi->cs_gpio, flags,
spi-ath79.c:135:					  dev_name(&spi->dev));
spi-ath79.c:137:		if (spi->mode & SPI_CS_HIGH)
spi-ath79.c:138:			sp->ioc_base &= ~AR71XX_SPI_IOC_CS0;
spi-ath79.c:140:			sp->ioc_base |= AR71XX_SPI_IOC_CS0;
spi-ath79.c:142:		ath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);
spi-ath79.c:150:	if (spi->chip_select) {
spi-ath79.c:151:		gpio_free(spi->cs_gpio);
spi-ath79.c:159:	if (!spi->controller_state) {
spi-ath79.c:166:	if (status && !spi->controller_state)
spi-ath79.c:182:	u32 ioc = sp->ioc_base;
spi-ath79.c:185:	for (word <<= (32 - bits); likely(bits); bits--) {
spi-ath79.c:216:	master = spi_alloc_master(&pdev->dev, sizeof(*sp));
spi-ath79.c:218:		dev_err(&pdev->dev, "failed to allocate spi master\n");
spi-ath79.c:219:		return -ENOMEM;
spi-ath79.c:223:	master->dev.of_node = pdev->dev.of_node;
spi-ath79.c:226:	pdata = dev_get_platdata(&pdev->dev);
spi-ath79.c:228:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);
spi-ath79.c:229:	master->setup = ath79_spi_setup;
spi-ath79.c:230:	master->cleanup = ath79_spi_cleanup;
spi-ath79.c:232:		master->bus_num = pdata->bus_num;
spi-ath79.c:233:		master->num_chipselect = pdata->num_chipselect;
spi-ath79.c:236:	sp->bitbang.master = master;
spi-ath79.c:237:	sp->bitbang.chipselect = ath79_spi_chipselect;
spi-ath79.c:238:	sp->bitbang.txrx_word[SPI_MODE_0] = ath79_spi_txrx_mode0;
spi-ath79.c:239:	sp->bitbang.setup_transfer = spi_bitbang_setup_transfer;
spi-ath79.c:240:	sp->bitbang.flags = SPI_CS_HIGH;
spi-ath79.c:243:	sp->base = devm_ioremap_resource(&pdev->dev, r);
spi-ath79.c:244:	if (IS_ERR(sp->base)) {
spi-ath79.c:245:		ret = PTR_ERR(sp->base);
spi-ath79.c:249:	sp->clk = devm_clk_get(&pdev->dev, "ahb");
spi-ath79.c:250:	if (IS_ERR(sp->clk)) {
spi-ath79.c:251:		ret = PTR_ERR(sp->clk);
spi-ath79.c:255:	ret = clk_prepare_enable(sp->clk);
spi-ath79.c:259:	rate = DIV_ROUND_UP(clk_get_rate(sp->clk), MHZ);
spi-ath79.c:261:		ret = -EINVAL;
spi-ath79.c:265:	sp->rrw_delay = ATH79_SPI_RRW_DELAY_FACTOR / rate;
spi-ath79.c:266:	dev_dbg(&pdev->dev, "register read/write delay is %u nsecs\n",
spi-ath79.c:267:		sp->rrw_delay);
spi-ath79.c:270:	ret = spi_bitbang_start(&sp->bitbang);
spi-ath79.c:279:	clk_disable_unprepare(sp->clk);
spi-ath79.c:281:	spi_master_put(sp->bitbang.master);
spi-ath79.c:290:	spi_bitbang_stop(&sp->bitbang);
spi-ath79.c:292:	clk_disable_unprepare(sp->clk);
spi-ath79.c:293:	spi_master_put(sp->bitbang.master);
spi-ath79.c:304:	{ .compatible = "qca,ar7100-spi", },
spi.c:22:#include <linux/dma-mapping.h>
spi.c:27:#include <linux/clk/clk-conf.h>
spi.c:53:	if (spi->master->cleanup)
spi.c:54:		spi->master->cleanup(spi);
spi.c:56:	spi_master_put(spi->master);
spi.c:66:	len = acpi_device_modalias(dev, buf, PAGE_SIZE - 1);
spi.c:67:	if (len != -ENODEV)
spi.c:70:	return sprintf(buf, "%s%s\n", SPI_MODULE_PREFIX, spi->modalias);
spi.c:81:	return spi_statistics_##field##_show(&master->statistics, buf);	\
spi.c:93:	return spi_statistics_##field##_show(&spi->statistics, buf);	\
spi.c:106:	spin_lock_irqsave(&stat->lock, flags);				\
spi.c:107:	len = sprintf(buf, format_string, stat->field);			\
spi.c:108:	spin_unlock_irqrestore(&stat->lock, flags);			\
spi.c:134:SPI_STATISTICS_TRANSFER_BYTES_HISTO(0,  "0-1");
spi.c:135:SPI_STATISTICS_TRANSFER_BYTES_HISTO(1,  "2-3");
spi.c:136:SPI_STATISTICS_TRANSFER_BYTES_HISTO(2,  "4-7");
spi.c:137:SPI_STATISTICS_TRANSFER_BYTES_HISTO(3,  "8-15");
spi.c:138:SPI_STATISTICS_TRANSFER_BYTES_HISTO(4,  "16-31");
spi.c:139:SPI_STATISTICS_TRANSFER_BYTES_HISTO(5,  "32-63");
spi.c:140:SPI_STATISTICS_TRANSFER_BYTES_HISTO(6,  "64-127");
spi.c:141:SPI_STATISTICS_TRANSFER_BYTES_HISTO(7,  "128-255");
spi.c:142:SPI_STATISTICS_TRANSFER_BYTES_HISTO(8,  "256-511");
spi.c:143:SPI_STATISTICS_TRANSFER_BYTES_HISTO(9,  "512-1023");
spi.c:144:SPI_STATISTICS_TRANSFER_BYTES_HISTO(10, "1024-2047");
spi.c:145:SPI_STATISTICS_TRANSFER_BYTES_HISTO(11, "2048-4095");
spi.c:146:SPI_STATISTICS_TRANSFER_BYTES_HISTO(12, "4096-8191");
spi.c:147:SPI_STATISTICS_TRANSFER_BYTES_HISTO(13, "8192-16383");
spi.c:148:SPI_STATISTICS_TRANSFER_BYTES_HISTO(14, "16384-32767");
spi.c:149:SPI_STATISTICS_TRANSFER_BYTES_HISTO(15, "32768-65535");
spi.c:249:	int l2len = min(fls(xfer->len), SPI_STATISTICS_HISTO_SIZE) - 1;
spi.c:254:	spin_lock_irqsave(&stats->lock, flags);
spi.c:256:	stats->transfers++;
spi.c:257:	stats->transfer_bytes_histo[l2len]++;
spi.c:259:	stats->bytes += xfer->len;
spi.c:260:	if ((xfer->tx_buf) &&
spi.c:261:	    (xfer->tx_buf != master->dummy_tx))
spi.c:262:		stats->bytes_tx += xfer->len;
spi.c:263:	if ((xfer->rx_buf) &&
spi.c:264:	    (xfer->rx_buf != master->dummy_rx))
spi.c:265:		stats->bytes_rx += xfer->len;
spi.c:267:	spin_unlock_irqrestore(&stats->lock, flags);
spi.c:271:/* modalias support makes "modprobe $MODALIAS" new-style hotplug work,
spi.c:278:	while (id->name[0]) {
spi.c:279:		if (!strcmp(sdev->modalias, id->name))
spi.c:288:	const struct spi_driver *sdrv = to_spi_driver(sdev->dev.driver);
spi.c:290:	return spi_match_id(sdrv->id_table, sdev);
spi.c:307:	if (sdrv->id_table)
spi.c:308:		return !!spi_match_id(sdrv->id_table, spi);
spi.c:310:	return strcmp(spi->modalias, drv->name) == 0;
spi.c:319:	if (rc != -ENODEV)
spi.c:322:	add_uevent_var(env, "MODALIAS=%s%s", SPI_MODULE_PREFIX, spi->modalias);
spi.c:337:	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
spi.c:341:	ret = of_clk_set_defaults(dev->of_node, false);
spi.c:345:	if (dev->of_node) {
spi.c:346:		spi->irq = of_irq_get(dev->of_node, 0);
spi.c:347:		if (spi->irq == -EPROBE_DEFER)
spi.c:348:			return -EPROBE_DEFER;
spi.c:349:		if (spi->irq < 0)
spi.c:350:			spi->irq = 0;
spi.c:354:	if (ret != -EPROBE_DEFER) {
spi.c:355:		ret = sdrv->probe(spi);
spi.c:365:	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
spi.c:368:	ret = sdrv->remove(to_spi_device(dev));
spi.c:376:	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
spi.c:378:	sdrv->shutdown(to_spi_device(dev));
spi.c:382: * __spi_register_driver - register a SPI driver
spi.c:391:	sdrv->driver.owner = owner;
spi.c:392:	sdrv->driver.bus = &spi_bus_type;
spi.c:393:	if (sdrv->probe)
spi.c:394:		sdrv->driver.probe = spi_drv_probe;
spi.c:395:	if (sdrv->remove)
spi.c:396:		sdrv->driver.remove = spi_drv_remove;
spi.c:397:	if (sdrv->shutdown)
spi.c:398:		sdrv->driver.shutdown = spi_drv_shutdown;
spi.c:399:	return driver_register(&sdrv->driver);
spi.c:403:/*-------------------------------------------------------------------------*/
spi.c:406: * would make them board-specific.  Similarly with SPI master drivers.
spi.c:407: * Device registration normally goes into like arch/.../mach.../board-YYY.c
spi.c:426: * spi_alloc_device - Allocate a new SPI device
spi.c:455:	spi->master = master;
spi.c:456:	spi->dev.parent = &master->dev;
spi.c:457:	spi->dev.bus = &spi_bus_type;
spi.c:458:	spi->dev.release = spidev_release;
spi.c:459:	spi->cs_gpio = -ENOENT;
spi.c:461:	spin_lock_init(&spi->statistics.lock);
spi.c:463:	device_initialize(&spi->dev);
spi.c:470:	struct acpi_device *adev = ACPI_COMPANION(&spi->dev);
spi.c:473:		dev_set_name(&spi->dev, "spi-%s", acpi_dev_name(adev));
spi.c:477:	dev_set_name(&spi->dev, "%s.%u", dev_name(&spi->master->dev),
spi.c:478:		     spi->chip_select);
spi.c:485:	if (spi->master == new_spi->master &&
spi.c:486:	    spi->chip_select == new_spi->chip_select)
spi.c:487:		return -EBUSY;
spi.c:492: * spi_add_device - Add spi_device allocated with spi_alloc_device
spi.c:503:	struct spi_master *master = spi->master;
spi.c:504:	struct device *dev = master->dev.parent;
spi.c:507:	if (spi->chip_select >= master->num_chipselect) {
spi.c:509:			spi->chip_select,
spi.c:510:			master->num_chipselect);
spi.c:511:		return -EINVAL;
spi.c:525:				spi->chip_select);
spi.c:529:	if (master->cs_gpios)
spi.c:530:		spi->cs_gpio = master->cs_gpios[spi->chip_select];
spi.c:539:				dev_name(&spi->dev), status);
spi.c:544:	status = device_add(&spi->dev);
spi.c:547:				dev_name(&spi->dev), status);
spi.c:549:		dev_dbg(dev, "registered child %s\n", dev_name(&spi->dev));
spi.c:558: * spi_new_device - instantiate one new SPI device
spi.c:564: * after board init creates the hard-wired devices.  Some development
spi.c:567: * driver could add devices (which it would learn about out-of-band).
spi.c:577:	/* NOTE:  caller did any chip->bus_num checks necessary.
spi.c:580:	 * error-or-pointer (not NULL-or-pointer), troubleshootability
spi.c:588:	WARN_ON(strlen(chip->modalias) >= sizeof(proxy->modalias));
spi.c:590:	proxy->chip_select = chip->chip_select;
spi.c:591:	proxy->max_speed_hz = chip->max_speed_hz;
spi.c:592:	proxy->mode = chip->mode;
spi.c:593:	proxy->irq = chip->irq;
spi.c:594:	strlcpy(proxy->modalias, chip->modalias, sizeof(proxy->modalias));
spi.c:595:	proxy->dev.platform_data = (void *) chip->platform_data;
spi.c:596:	proxy->controller_data = chip->controller_data;
spi.c:597:	proxy->controller_state = NULL;
spi.c:614:	if (master->bus_num != bi->bus_num)
spi.c:619:		dev_err(master->dev.parent, "can't create new device for %s\n",
spi.c:620:			bi->modalias);
spi.c:624: * spi_register_board_info - register SPI devices for a given board
spi.c:629: * Board-specific early init code calls this (probably during arch_initcall)
spi.c:633: * not make Linux forget about these hard-wired devices.
spi.c:635: * Other code can also call this, e.g. a particular add-on board might provide
spi.c:640: * any embedded pointers (platform_data, etc), they're copied as-is.
spi.c:650:		return -EINVAL;
spi.c:654:		return -ENOMEM;
spi.c:659:		memcpy(&bi->board_info, info, sizeof(*info));
spi.c:661:		list_add_tail(&bi->list, &board_list);
spi.c:663:			spi_match_master_to_boardinfo(master, &bi->board_info);
spi.c:673:	return spi_master_get_devdata(sdev->master);
spi.c:677:/*-------------------------------------------------------------------------*/
spi.c:681:	if (spi->mode & SPI_CS_HIGH)
spi.c:684:	if (gpio_is_valid(spi->cs_gpio))
spi.c:688:			gpio_direction_output(spi->cs_gpio, 1);
spi.c:689:			gpio_set_value(spi->cs_gpio, !enable);
spi.c:693:			gpio_direction_output(spi->cs_gpio, 1);
spi.c:694:			gpio_set_value(spi->cs_gpio, !enable);
spi.c:695:			//gpio_direction_output(spi->cs_gpio, 0);
spi.c:698:	else if (spi->master->set_cs)
spi.c:699:		spi->master->set_cs(spi, !enable);
spi.c:719:		desc_len = master->max_dma_len;
spi.c:737:					  PAGE_SIZE - offset_in_page(buf)));
spi.c:741:				return -ENOMEM;
spi.c:743:			sg_set_page(&sgt->sgl[i], vm_page,
spi.c:748:			sg_set_buf(&sgt->sgl[i], sg_buf, min);
spi.c:753:		len -= min;
spi.c:756:	ret = dma_map_sg(dev, sgt->sgl, sgt->nents, dir);
spi.c:758:		ret = -ENOMEM;
spi.c:764:	sgt->nents = ret;
spi.c:772:	if (sgt->orig_nents) {
spi.c:773:		dma_unmap_sg(dev, sgt->sgl, sgt->orig_nents, dir);
spi.c:784:	if (!master->can_dma)
spi.c:787:	if (master->dma_tx)
spi.c:788:		tx_dev = master->dma_tx->device->dev;
spi.c:790:		tx_dev = &master->dev;
spi.c:792:	if (master->dma_rx)
spi.c:793:		rx_dev = master->dma_rx->device->dev;
spi.c:795:		rx_dev = &master->dev;
spi.c:797:	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
spi.c:798:		if (!master->can_dma(master, msg->spi, xfer))
spi.c:801:		if (xfer->tx_buf != NULL) {
spi.c:802:			ret = spi_map_buf(master, tx_dev, &xfer->tx_sg,
spi.c:803:					  (void *)xfer->tx_buf, xfer->len,
spi.c:809:		if (xfer->rx_buf != NULL) {
spi.c:810:			ret = spi_map_buf(master, rx_dev, &xfer->rx_sg,
spi.c:811:					  xfer->rx_buf, xfer->len,
spi.c:814:				spi_unmap_buf(master, tx_dev, &xfer->tx_sg,
spi.c:821:	master->cur_msg_mapped = true;
spi.c:831:	if (!master->cur_msg_mapped || !master->can_dma)
spi.c:834:	if (master->dma_tx)
spi.c:835:		tx_dev = master->dma_tx->device->dev;
spi.c:837:		tx_dev = &master->dev;
spi.c:839:	if (master->dma_rx)
spi.c:840:		rx_dev = master->dma_rx->device->dev;
spi.c:842:		rx_dev = &master->dev;
spi.c:844:	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
spi.c:845:		if (!master->can_dma(master, msg->spi, xfer))
spi.c:848:		spi_unmap_buf(master, rx_dev, &xfer->rx_sg, DMA_FROM_DEVICE);
spi.c:849:		spi_unmap_buf(master, tx_dev, &xfer->tx_sg, DMA_TO_DEVICE);
spi.c:873:	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
spi.c:878:		if (xfer->tx_buf == master->dummy_tx)
spi.c:879:			xfer->tx_buf = NULL;
spi.c:880:		if (xfer->rx_buf == master->dummy_rx)
spi.c:881:			xfer->rx_buf = NULL;
spi.c:893:	if (master->flags & (SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX)) {
spi.c:897:		list_for_each_entry(xfer, &msg->transfers, transfer_list) {
spi.c:898:			if ((master->flags & SPI_MASTER_MUST_TX) &&
spi.c:899:			    !xfer->tx_buf)
spi.c:900:				max_tx = max(xfer->len, max_tx);
spi.c:901:			if ((master->flags & SPI_MASTER_MUST_RX) &&
spi.c:902:			    !xfer->rx_buf)
spi.c:903:				max_rx = max(xfer->len, max_rx);
spi.c:907:			tmp = krealloc(master->dummy_tx, max_tx,
spi.c:910:				return -ENOMEM;
spi.c:911:			master->dummy_tx = tmp;
spi.c:916:			tmp = krealloc(master->dummy_rx, max_rx,
spi.c:919:				return -ENOMEM;
spi.c:920:			master->dummy_rx = tmp;
spi.c:924:			list_for_each_entry(xfer, &msg->transfers,
spi.c:926:				if (!xfer->len)
spi.c:928:				if (!xfer->tx_buf)
spi.c:929:					xfer->tx_buf = master->dummy_tx;
spi.c:930:				if (!xfer->rx_buf)
spi.c:931:					xfer->rx_buf = master->dummy_rx;
spi.c:940: * spi_transfer_one_message - Default implementation of transfer_one_message()
spi.c:953:	struct spi_statistics *statm = &master->statistics;
spi.c:954:	struct spi_statistics *stats = &msg->spi->statistics;
spi.c:956:	spi_set_cs(msg->spi, true);
spi.c:961:	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
spi.c:967:		if (xfer->tx_buf || xfer->rx_buf) {
spi.c:968:			reinit_completion(&master->xfer_completion);
spi.c:970:			ret = master->transfer_one(master, msg->spi, xfer);
spi.c:976:				dev_err(&msg->spi->dev,
spi.c:983:				ms = xfer->len * 8 * 1000 / xfer->speed_hz;
spi.c:986:				ms = wait_for_completion_timeout(&master->xfer_completion,
spi.c:995:				dev_err(&msg->spi->dev,
spi.c:997:				msg->status = -ETIMEDOUT;
spi.c:1000:			if (xfer->len)
spi.c:1001:				dev_err(&msg->spi->dev,
spi.c:1003:					xfer->len);
spi.c:1008:		if (msg->status != -EINPROGRESS)
spi.c:1011:		if (xfer->delay_usecs)
spi.c:1012:			udelay(xfer->delay_usecs);
spi.c:1014:		if (xfer->cs_change) {
spi.c:1015:			if (list_is_last(&xfer->transfer_list,
spi.c:1016:					 &msg->transfers)) {
spi.c:1019:				spi_set_cs(msg->spi, false);
spi.c:1021:				spi_set_cs(msg->spi, true);
spi.c:1025:		msg->actual_length += xfer->len;
spi.c:1032:		spi_set_cs(msg->spi, false);
spi.c:1035:	if (msg->status == -EINPROGRESS)
spi.c:1036:		msg->status = ret;
spi.c:1038:	if (msg->status && master->handle_err)
spi.c:1039:		master->handle_err(master, msg);
spi.c:1047: * spi_finalize_current_transfer - report completion of a transfer
spi.c:1056:	complete(&master->xfer_completion);
spi.c:1061: * __spi_pump_messages - function which processes spi message queue
spi.c:1080:	spin_lock_irqsave(&master->queue_lock, flags);
spi.c:1083:	if (master->cur_msg) {
spi.c:1084:		spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1089:	if (master->idling) {
spi.c:1090:		queue_kthread_work(&master->kworker, &master->pump_messages);
spi.c:1091:		spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1096:	if (list_empty(&master->queue) || !master->running) {
spi.c:1097:		if (!master->busy) {
spi.c:1098:			spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1104:			queue_kthread_work(&master->kworker,
spi.c:1105:					   &master->pump_messages);
spi.c:1106:			spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1110:		master->busy = false;
spi.c:1111:		master->idling = true;
spi.c:1112:		spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1114:		kfree(master->dummy_rx);
spi.c:1115:		master->dummy_rx = NULL;
spi.c:1116:		kfree(master->dummy_tx);
spi.c:1117:		master->dummy_tx = NULL;
spi.c:1118:		if (master->unprepare_transfer_hardware &&
spi.c:1119:		    master->unprepare_transfer_hardware(master))
spi.c:1120:			dev_err(&master->dev,
spi.c:1122:		if (master->auto_runtime_pm) {
spi.c:1123:			pm_runtime_mark_last_busy(master->dev.parent);
spi.c:1124:			pm_runtime_put_autosuspend(master->dev.parent);
spi.c:1128:		spin_lock_irqsave(&master->queue_lock, flags);
spi.c:1129:		master->idling = false;
spi.c:1130:		spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1135:	master->cur_msg =
spi.c:1136:		list_first_entry(&master->queue, struct spi_message, queue);
spi.c:1138:	list_del_init(&master->cur_msg->queue);
spi.c:1139:	if (master->busy)
spi.c:1142:		master->busy = true;
spi.c:1143:	spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1145:	if (!was_busy && master->auto_runtime_pm) {
spi.c:1146:		ret = pm_runtime_get_sync(master->dev.parent);
spi.c:1148:			dev_err(&master->dev, "Failed to power device: %d\n",
spi.c:1157:	if (!was_busy && master->prepare_transfer_hardware) {
spi.c:1158:		ret = master->prepare_transfer_hardware(master);
spi.c:1160:			dev_err(&master->dev,
spi.c:1163:			if (master->auto_runtime_pm)
spi.c:1164:				pm_runtime_put(master->dev.parent);
spi.c:1169:	trace_spi_message_start(master->cur_msg);
spi.c:1171:	if (master->prepare_message) {
spi.c:1172:		ret = master->prepare_message(master, master->cur_msg);
spi.c:1174:			dev_err(&master->dev,
spi.c:1176:			master->cur_msg->status = ret;
spi.c:1180:		master->cur_msg_prepared = true;
spi.c:1183:	ret = spi_map_msg(master, master->cur_msg);
spi.c:1185:		master->cur_msg->status = ret;
spi.c:1190:	ret = master->transfer_one_message(master, master->cur_msg);
spi.c:1192:		dev_err(&master->dev,
spi.c:1199: * spi_pump_messages - kthread work function which processes spi message queue
spi.c:1212:	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
spi.c:1214:	master->running = false;
spi.c:1215:	master->busy = false;
spi.c:1217:	init_kthread_worker(&master->kworker);
spi.c:1218:	master->kworker_task = kthread_run(kthread_worker_fn,
spi.c:1219:					   &master->kworker, "%s",
spi.c:1220:					   dev_name(&master->dev));
spi.c:1221:	if (IS_ERR(master->kworker_task)) {
spi.c:1222:		dev_err(&master->dev, "failed to create message pump task\n");
spi.c:1223:		return PTR_ERR(master->kworker_task);
spi.c:1225:	init_kthread_work(&master->pump_messages, spi_pump_messages);
spi.c:1234:	if (master->rt) {
spi.c:1235:		dev_info(&master->dev,
spi.c:1237:		sched_setscheduler(master->kworker_task, SCHED_FIFO, &param);
spi.c:1244: * spi_get_next_queued_message() - called by driver to check for queued
spi.c:1259:	spin_lock_irqsave(&master->queue_lock, flags);
spi.c:1260:	next = list_first_entry_or_null(&master->queue, struct spi_message,
spi.c:1262:	spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1269: * spi_finalize_current_message() - the current message is complete
spi.c:1281:	spin_lock_irqsave(&master->queue_lock, flags);
spi.c:1282:	mesg = master->cur_msg;
spi.c:1283:	spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1287:	if (master->cur_msg_prepared && master->unprepare_message) {
spi.c:1288:		ret = master->unprepare_message(master, mesg);
spi.c:1290:			dev_err(&master->dev,
spi.c:1295:	spin_lock_irqsave(&master->queue_lock, flags);
spi.c:1296:	master->cur_msg = NULL;
spi.c:1297:	master->cur_msg_prepared = false;
spi.c:1298:	queue_kthread_work(&master->kworker, &master->pump_messages);
spi.c:1299:	spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1303:	mesg->state = NULL;
spi.c:1304:	if (mesg->complete)
spi.c:1305:		mesg->complete(mesg->context);
spi.c:1313:	spin_lock_irqsave(&master->queue_lock, flags);
spi.c:1315:	if (master->running || master->busy) {
spi.c:1316:		spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1317:		return -EBUSY;
spi.c:1320:	master->running = true;
spi.c:1321:	master->cur_msg = NULL;
spi.c:1322:	spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1324:	queue_kthread_work(&master->kworker, &master->pump_messages);
spi.c:1335:	spin_lock_irqsave(&master->queue_lock, flags);
spi.c:1339:	 * A wait_queue on the master->busy could be used, but then the common
spi.c:1343:	while ((!list_empty(&master->queue) || master->busy) && limit--) {
spi.c:1344:		spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1346:		spin_lock_irqsave(&master->queue_lock, flags);
spi.c:1349:	if (!list_empty(&master->queue) || master->busy)
spi.c:1350:		ret = -EBUSY;
spi.c:1352:		master->running = false;
spi.c:1354:	spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1357:		dev_warn(&master->dev,
spi.c:1377:		dev_err(&master->dev, "problem destroying queue\n");
spi.c:1381:	flush_kthread_worker(&master->kworker);
spi.c:1382:	kthread_stop(master->kworker_task);
spi.c:1391:	struct spi_master *master = spi->master;
spi.c:1394:	spin_lock_irqsave(&master->queue_lock, flags);
spi.c:1396:	if (!master->running) {
spi.c:1397:		spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1398:		return -ESHUTDOWN;
spi.c:1400:	msg->actual_length = 0;
spi.c:1401:	msg->status = -EINPROGRESS;
spi.c:1403:	list_add_tail(&msg->queue, &master->queue);
spi.c:1404:	if (!master->busy && need_pump)
spi.c:1405:		queue_kthread_work(&master->kworker, &master->pump_messages);
spi.c:1407:	spin_unlock_irqrestore(&master->queue_lock, flags);
spi.c:1412: * spi_queued_transfer - transfer function for queued transfers
spi.c:1427:	master->transfer = spi_queued_transfer;
spi.c:1428:	if (!master->transfer_one_message)
spi.c:1429:		master->transfer_one_message = spi_transfer_one_message;
spi.c:1434:		dev_err(&master->dev, "problem initializing queue\n");
spi.c:1437:	master->queued = true;
spi.c:1440:		dev_err(&master->dev, "problem starting queue\n");
spi.c:1452:/*-------------------------------------------------------------------------*/
spi.c:1465:		dev_err(&master->dev, "spi_device alloc error for %s\n",
spi.c:1466:			nc->full_name);
spi.c:1467:		rc = -ENOMEM;
spi.c:1472:	rc = of_modalias_node(nc, spi->modalias,
spi.c:1473:				sizeof(spi->modalias));
spi.c:1475:		dev_err(&master->dev, "cannot find modalias for %s\n",
spi.c:1476:			nc->full_name);
spi.c:1483:		dev_err(&master->dev, "%s has no valid 'reg' property (%d)\n",
spi.c:1484:			nc->full_name, rc);
spi.c:1488:	spi->chip_select = value;
spi.c:1491:	if (of_find_property(nc, "spi-cpha", NULL))
spi.c:1492:		spi->mode |= SPI_CPHA;
spi.c:1493:	if (of_find_property(nc, "spi-cpol", NULL))
spi.c:1494:		spi->mode |= SPI_CPOL;
spi.c:1495:	if (of_find_property(nc, "spi-cs-high", NULL))
spi.c:1496:		spi->mode |= SPI_CS_HIGH;
spi.c:1497:	if (of_find_property(nc, "spi-3wire", NULL))
spi.c:1498:		spi->mode |= SPI_3WIRE;
spi.c:1499:	if (of_find_property(nc, "spi-lsb-first", NULL))
spi.c:1500:		spi->mode |= SPI_LSB_FIRST;
spi.c:1503:	if (!of_property_read_u32(nc, "spi-tx-bus-width", &value)) {
spi.c:1508:			spi->mode |= SPI_TX_DUAL;
spi.c:1511:			spi->mode |= SPI_TX_QUAD;
spi.c:1514:			dev_warn(&master->dev,
spi.c:1515:				"spi-tx-bus-width %d not supported\n",
spi.c:1521:	if (!of_property_read_u32(nc, "spi-rx-bus-width", &value)) {
spi.c:1526:			spi->mode |= SPI_RX_DUAL;
spi.c:1529:			spi->mode |= SPI_RX_QUAD;
spi.c:1532:			dev_warn(&master->dev,
spi.c:1533:				"spi-rx-bus-width %d not supported\n",
spi.c:1540:	rc = of_property_read_u32(nc, "spi-max-frequency", &value);
spi.c:1542:		dev_err(&master->dev, "%s has no valid 'spi-max-frequency' property (%d)\n",
spi.c:1543:			nc->full_name, rc);
spi.c:1546:	spi->max_speed_hz = value;
spi.c:1550:	spi->dev.of_node = nc;
spi.c:1555:		dev_err(&master->dev, "spi_device register error %s\n",
spi.c:1556:			nc->full_name);
spi.c:1568: * of_register_spi_devices() - Register child devices onto the SPI bus
spi.c:1579:	if (!master->dev.of_node)
spi.c:1582:	for_each_available_child_of_node(master->dev.of_node, nc) {
spi.c:1585:			dev_warn(&master->dev, "Failed to create SPI device for %s\n",
spi.c:1586:				nc->full_name);
spi.c:1598:	if (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {
spi.c:1601:		sb = &ares->data.spi_serial_bus;
spi.c:1602:		if (sb->type == ACPI_RESOURCE_SERIAL_TYPE_SPI) {
spi.c:1603:			spi->chip_select = sb->device_selection;
spi.c:1604:			spi->max_speed_hz = sb->connection_speed;
spi.c:1606:			if (sb->clock_phase == ACPI_SPI_SECOND_PHASE)
spi.c:1607:				spi->mode |= SPI_CPHA;
spi.c:1608:			if (sb->clock_polarity == ACPI_SPI_START_HIGH)
spi.c:1609:				spi->mode |= SPI_CPOL;
spi.c:1610:			if (sb->device_polarity == ACPI_SPI_ACTIVE_HIGH)
spi.c:1611:				spi->mode |= SPI_CS_HIGH;
spi.c:1613:	} else if (spi->irq < 0) {
spi.c:1617:			spi->irq = r.start;
spi.c:1635:	if (acpi_bus_get_status(adev) || !adev->status.present)
spi.c:1640:		dev_err(&master->dev, "failed to allocate SPI device for %s\n",
spi.c:1641:			dev_name(&adev->dev));
spi.c:1645:	ACPI_COMPANION_SET(&spi->dev, adev);
spi.c:1646:	spi->irq = -1;
spi.c:1653:	if (ret < 0 || !spi->max_speed_hz) {
spi.c:1658:	adev->power.flags.ignore_parent = true;
spi.c:1659:	strlcpy(spi->modalias, acpi_device_hid(adev), sizeof(spi->modalias));
spi.c:1661:		adev->power.flags.ignore_parent = false;
spi.c:1662:		dev_err(&master->dev, "failed to add SPI device %s from ACPI\n",
spi.c:1663:			dev_name(&adev->dev));
spi.c:1675:	handle = ACPI_HANDLE(master->dev.parent);
spi.c:1683:		dev_warn(&master->dev, "failed to enumerate SPI slaves\n");
spi.c:1706: * spi_alloc_master - allocate SPI master controller
spi.c:1708: * @size: how much zeroed driver-private data to allocate; the pointer to this
spi.c:1736:	device_initialize(&master->dev);
spi.c:1737:	master->bus_num = -1;
spi.c:1738:	master->num_chipselect = 1;
spi.c:1739:	master->dev.class = &spi_master_class;
spi.c:1740:	master->dev.parent = dev;
spi.c:1751:	struct device_node *np = master->dev.of_node;
spi.c:1756:	nb = of_gpio_named_count(np, "cs-gpios");
spi.c:1757:	master->num_chipselect = max_t(int, nb, master->num_chipselect);
spi.c:1759:	/* Return error only for an incorrectly formed cs-gpios property */
spi.c:1760:	if (nb == 0 || nb == -ENOENT)
spi.c:1765:	cs = devm_kzalloc(&master->dev,
spi.c:1766:			  sizeof(int) * master->num_chipselect,
spi.c:1768:	master->cs_gpios = cs;
spi.c:1770:	if (!master->cs_gpios)
spi.c:1771:		return -ENOMEM;
spi.c:1773:	for (i = 0; i < master->num_chipselect; i++)
spi.c:1774:		cs[i] = -ENOENT;	
spi.c:1778:		cs[i] = of_get_named_gpio(np, "cs-gpios", i);
spi.c:1792: * spi_register_master - register SPI master controller
spi.c:1796: * SPI master controllers connect to their drivers using some non-SPI bus,
spi.c:1801: * and board-specific addressing for SPI devices combines those numbers
spi.c:1815:	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<15) - 1);
spi.c:1816:	struct device		*dev = master->dev.parent;
spi.c:1818:	int			status = -ENODEV;
spi.c:1822:		return -ENODEV;
spi.c:1828:	/* even if it's just one always-selected device, there must
spi.c:1831:	if (master->num_chipselect == 0)
spi.c:1832:		return -EINVAL;
spi.c:1834:	if ((master->bus_num < 0) && master->dev.of_node)
spi.c:1835:		master->bus_num = of_alias_get_id(master->dev.of_node, "spi"); 
spi.c:1838:	if (master->bus_num < 0) {
spi.c:1842:		master->bus_num = atomic_dec_return(&dyn_bus_id);
spi.c:1846:	INIT_LIST_HEAD(&master->queue);
spi.c:1847:	spin_lock_init(&master->queue_lock);
spi.c:1848:	spin_lock_init(&master->bus_lock_spinlock);
spi.c:1849:	mutex_init(&master->bus_lock_mutex);
spi.c:1850:	master->bus_lock_flag = 0;
spi.c:1851:	init_completion(&master->xfer_completion);
spi.c:1852:	if (!master->max_dma_len)
spi.c:1853:		master->max_dma_len = INT_MAX;
spi.c:1858:	dev_set_name(&master->dev, "spi%u", master->bus_num);	
spi.c:1860:	status = device_add(&master->dev);
spi.c:1863:	dev_dbg(dev, "registered master %s%s\n", dev_name(&master->dev),
spi.c:1867:	if (master->transfer)
spi.c:1872:			device_del(&master->dev);
spi.c:1879:	spin_lock_init(&master->statistics.lock);
spi.c:1882:	list_add_tail(&master->list, &spi_master_list);
spi.c:1884:		spi_match_master_to_boardinfo(master, &bi->board_info);
spi.c:1902: * dev_spi_register_master - register managed SPI master controller
spi.c:1919:		return -ENOMEM;	
spi.c:1940: * spi_unregister_master - unregister SPI master controller
spi.c:1953:	if (master->queued) {
spi.c:1955:			dev_err(&master->dev, "queue remove failed\n");
spi.c:1959:	list_del(&master->list);
spi.c:1962:	dummy = device_for_each_child(&master->dev, NULL, __unregister);
spi.c:1963:	device_unregister(&master->dev);
spi.c:1971:	/* Basically no-ops for non-queued masters */
spi.c:1972:	if (!master->queued)
spi.c:1977:		dev_err(&master->dev, "queue stop failed\n");
spi.c:1987:	if (!master->queued)
spi.c:1992:		dev_err(&master->dev, "queue restart failed\n");
spi.c:2004:	return m->bus_num == *bus_num;
spi.c:2008: * spi_busnum_to_master - look up master associated with bus_num
spi.c:2034:/*-------------------------------------------------------------------------*/
spi.c:2042:	if (master->bits_per_word_mask) {
spi.c:2045:			return -EINVAL;
spi.c:2046:		if (!(master->bits_per_word_mask &
spi.c:2048:			return -EINVAL;
spi.c:2055: * spi_setup - setup SPI mode and clock rate
spi.c:2070: * LSB-first wire encoding, or active-high chipselects.
spi.c:2081:	if (((spi->mode & SPI_TX_DUAL) && (spi->mode & SPI_TX_QUAD)) ||
spi.c:2082:		((spi->mode & SPI_RX_DUAL) && (spi->mode & SPI_RX_QUAD))) {
spi.c:2083:		dev_err(&spi->dev,
spi.c:2085:		return -EINVAL;
spi.c:2089:	if ((spi->mode & SPI_3WIRE) && (spi->mode &
spi.c:2091:		return -EINVAL;
spi.c:2095:	bad_bits = spi->mode & ~spi->master->mode_bits;
spi.c:2099:		dev_warn(&spi->dev,
spi.c:2102:		spi->mode &= ~ugly_bits;
spi.c:2106:		dev_err(&spi->dev, "setup: unsupported mode bits %x\n",
spi.c:2108:		return -EINVAL;
spi.c:2111:	if (!spi->bits_per_word)
spi.c:2112:		spi->bits_per_word = 8;
spi.c:2114:	status = __spi_validate_bits_per_word(spi->master, spi->bits_per_word);
spi.c:2118:	if (!spi->max_speed_hz)
spi.c:2119:		spi->max_speed_hz = spi->master->max_speed_hz;
spi.c:2121:	if (spi->master->setup)
spi.c:2122:		status = spi->master->setup(spi);	
spi.c:2126:	dev_dbg(&spi->dev, "setup mode %d, %s%s%s%s%u bits/w, %u Hz max --> %d\n",
spi.c:2127:			(int) (spi->mode & (SPI_CPOL | SPI_CPHA)),
spi.c:2128:			(spi->mode & SPI_CS_HIGH) ? "cs_high, " : "",
spi.c:2129:			(spi->mode & SPI_LSB_FIRST) ? "lsb, " : "",
spi.c:2130:			(spi->mode & SPI_3WIRE) ? "3wire, " : "",
spi.c:2131:			(spi->mode & SPI_LOOP) ? "loopback, " : "",
spi.c:2132:			spi->bits_per_word, spi->max_speed_hz,
spi.c:2141:	struct spi_master *master = spi->master;
spi.c:2145:	if (list_empty(&message->transfers))
spi.c:2146:		return -EINVAL;
spi.c:2148:	/* Half-duplex links include original MicroWire, and ones with
spi.c:2153:	if ((master->flags & SPI_MASTER_HALF_DUPLEX)
spi.c:2154:			|| (spi->mode & SPI_3WIRE)) {
spi.c:2155:		unsigned flags = master->flags;
spi.c:2157:		list_for_each_entry(xfer, &message->transfers, transfer_list) {
spi.c:2158:			if (xfer->rx_buf && xfer->tx_buf)
spi.c:2159:				return -EINVAL;
spi.c:2160:			if ((flags & SPI_MASTER_NO_TX) && xfer->tx_buf)
spi.c:2161:				return -EINVAL;
spi.c:2162:			if ((flags & SPI_MASTER_NO_RX) && xfer->rx_buf)
spi.c:2163:				return -EINVAL;
spi.c:2173:	message->frame_length = 0;
spi.c:2174:	list_for_each_entry(xfer, &message->transfers, transfer_list) {
spi.c:2175:		message->frame_length += xfer->len;
spi.c:2176:		if (!xfer->bits_per_word)
spi.c:2177:			xfer->bits_per_word = spi->bits_per_word;
spi.c:2179:		if (!xfer->speed_hz)
spi.c:2180:			xfer->speed_hz = spi->max_speed_hz;
spi.c:2181:		if (!xfer->speed_hz)
spi.c:2182:			xfer->speed_hz = master->max_speed_hz;
spi.c:2184:		if (master->max_speed_hz &&
spi.c:2185:		    xfer->speed_hz > master->max_speed_hz)
spi.c:2186:			xfer->speed_hz = master->max_speed_hz;
spi.c:2188:		if (__spi_validate_bits_per_word(master, xfer->bits_per_word))
spi.c:2189:			return -EINVAL;
spi.c:2193:		 * where SPI word size should be power-of-two multiple
spi.c:2195:		if (xfer->bits_per_word <= 8)
spi.c:2197:		else if (xfer->bits_per_word <= 16)
spi.c:2203:		if (xfer->len % w_size)
spi.c:2204:			return -EINVAL;
spi.c:2206:		if (xfer->speed_hz && master->min_speed_hz &&
spi.c:2207:		    xfer->speed_hz < master->min_speed_hz)
spi.c:2208:			return -EINVAL;
spi.c:2210:		if (xfer->tx_buf && !xfer->tx_nbits)
spi.c:2211:			xfer->tx_nbits = SPI_NBITS_SINGLE;
spi.c:2212:		if (xfer->rx_buf && !xfer->rx_nbits)
spi.c:2213:			xfer->rx_nbits = SPI_NBITS_SINGLE;
spi.c:2218:		if (xfer->tx_buf) {
spi.c:2219:			if (xfer->tx_nbits != SPI_NBITS_SINGLE &&
spi.c:2220:				xfer->tx_nbits != SPI_NBITS_DUAL &&
spi.c:2221:				xfer->tx_nbits != SPI_NBITS_QUAD)
spi.c:2222:				return -EINVAL;
spi.c:2223:			if ((xfer->tx_nbits == SPI_NBITS_DUAL) &&
spi.c:2224:				!(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
spi.c:2225:				return -EINVAL;
spi.c:2226:			if ((xfer->tx_nbits == SPI_NBITS_QUAD) &&
spi.c:2227:				!(spi->mode & SPI_TX_QUAD))
spi.c:2228:				return -EINVAL;
spi.c:2231:		if (xfer->rx_buf) {
spi.c:2232:			if (xfer->rx_nbits != SPI_NBITS_SINGLE &&
spi.c:2233:				xfer->rx_nbits != SPI_NBITS_DUAL &&
spi.c:2234:				xfer->rx_nbits != SPI_NBITS_QUAD)
spi.c:2235:				return -EINVAL;
spi.c:2236:			if ((xfer->rx_nbits == SPI_NBITS_DUAL) &&
spi.c:2237:				!(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
spi.c:2238:				return -EINVAL;
spi.c:2239:			if ((xfer->rx_nbits == SPI_NBITS_QUAD) &&
spi.c:2240:				!(spi->mode & SPI_RX_QUAD))
spi.c:2241:				return -EINVAL;
spi.c:2245:	message->status = -EINPROGRESS;
spi.c:2252:	struct spi_master *master = spi->master;
spi.c:2254:	message->spi = spi;
spi.c:2256:	SPI_STATISTICS_INCREMENT_FIELD(&master->statistics, spi_async);
spi.c:2257:	SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics, spi_async);
spi.c:2261:	return master->transfer(spi, message);
spi.c:2265: * spi_async - asynchronous SPI transfer
spi.c:2274: * Before that invocation, the value of message->status is undefined.
spi.c:2275: * When the callback is issued, message->status holds either zero (to
spi.c:2297:	struct spi_master *master = spi->master;
spi.c:2305:	spin_lock_irqsave(&master->bus_lock_spinlock, flags);
spi.c:2307:	if (master->bus_lock_flag)
spi.c:2308:		ret = -EBUSY;
spi.c:2312:	spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
spi.c:2319: * spi_async_locked - version of spi_async with exclusive bus usage
spi.c:2328: * Before that invocation, the value of message->status is undefined.
spi.c:2329: * When the callback is issued, message->status holds either zero (to
spi.c:2351:	struct spi_master *master = spi->master;
spi.c:2359:	spin_lock_irqsave(&master->bus_lock_spinlock, flags);
spi.c:2363:	spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
spi.c:2371:/*-------------------------------------------------------------------------*/
spi.c:2388:	struct spi_master *master = spi->master;
spi.c:2395:	message->complete = spi_complete;
spi.c:2396:	message->context = &done;
spi.c:2397:	message->spi = spi;
spi.c:2399:	SPI_STATISTICS_INCREMENT_FIELD(&master->statistics, spi_sync);
spi.c:2400:	SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics, spi_sync);
spi.c:2403:		mutex_lock(&master->bus_lock_mutex);
spi.c:2412:	if (master->transfer == spi_queued_transfer) {
spi.c:2414:		spin_lock_irqsave(&master->bus_lock_spinlock, flags);
spi.c:2420:		spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
spi.c:2426:		mutex_unlock(&master->bus_lock_mutex);
spi.c:2432:		if (master->transfer == spi_queued_transfer) {
spi.c:2433:			SPI_STATISTICS_INCREMENT_FIELD(&master->statistics,
spi.c:2435:			SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics,
spi.c:2441:		status = message->status;
spi.c:2443:	message->context = NULL; 	
spi.c:2448: * spi_sync - blocking/synchronous SPI data transfers
spi.c:2454: * is non-interruptible, and has no timeout.  Low-overhead controller
spi.c:2459: * frequently-used devices may want to minimize costs of selecting a chip,
spi.c:2475: * spi_sync_locked - version of spi_sync with exclusive bus usage
spi.c:2481: * is non-interruptible, and has no timeout.  Low-overhead controller
spi.c:2497: * spi_bus_lock - obtain a lock for exclusive SPI bus usage
spi.c:2502: * is non-interruptible, and has no timeout.
spi.c:2515:	mutex_lock(&master->bus_lock_mutex);
spi.c:2517:	spin_lock_irqsave(&master->bus_lock_spinlock, flags);
spi.c:2518:	master->bus_lock_flag = 1;
spi.c:2519:	spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
spi.c:2528: * spi_bus_unlock - release the lock for exclusive SPI bus usage
spi.c:2533: * is non-interruptible, and has no timeout.
spi.c:2542:	master->bus_lock_flag = 0;
spi.c:2544:	mutex_unlock(&master->bus_lock_mutex);
spi.c:2556: * spi_write_then_read - SPI synchronous write followed by read
spi.c:2558: * @txbuf: data to be written (need not be dma-safe)
spi.c:2560: * @rxbuf: buffer into which data will be read (need not be dma-safe)
spi.c:2571: * Performance-sensitive or bulk transfer code should instead use
spi.c:2572: * spi_{async,sync}() calls with dma-safe buffers.
spi.c:2587:	/* Use preallocated DMA-safe buffer if we can.  We can't avoid
spi.c:2590:	 * using the pre-allocated buffer or the transfer is too large.
spi.c:2596:			return -ENOMEM;
spi.c:2630:/*-------------------------------------------------------------------------*/
spi.c:2635:	return dev->of_node == data;
spi.c:2648:	return dev->of_node == data;
spi.c:2674:		master = of_find_spi_master_by_node(rd->dn->parent);
spi.c:2678:		spi = of_register_spi_device(master, rd->dn);
spi.c:2679:		put_device(&master->dev);
spi.c:2683:					__func__, rd->dn->full_name);
spi.c:2690:		spi = of_find_spi_device_by_node(rd->dn);
spi.c:2698:		put_device(&spi->dev);
spi.c:2718:		status = -ENOMEM;
spi-mpc52xx-psc.c:66:	struct mpc52xx_psc_spi_cs *cs = spi->controller_state;
spi-mpc52xx-psc.c:68:	cs->speed_hz = (t && t->speed_hz)
spi-mpc52xx-psc.c:69:			? t->speed_hz : spi->max_speed_hz;
spi-mpc52xx-psc.c:70:	cs->bits_per_word = (t && t->bits_per_word)
spi-mpc52xx-psc.c:71:			? t->bits_per_word : spi->bits_per_word;
spi-mpc52xx-psc.c:72:	cs->bits_per_word = ((cs->bits_per_word + 7) / 8) * 8;
spi-mpc52xx-psc.c:78:	struct mpc52xx_psc_spi_cs *cs = spi->controller_state;
spi-mpc52xx-psc.c:79:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
spi-mpc52xx-psc.c:80:	struct mpc52xx_psc __iomem *psc = mps->psc;
spi-mpc52xx-psc.c:84:	sicr = in_be32(&psc->sicr);
spi-mpc52xx-psc.c:87:	if (spi->mode & SPI_CPHA)
spi-mpc52xx-psc.c:91:	if (spi->mode & SPI_CPOL)
spi-mpc52xx-psc.c:96:	if (spi->mode & SPI_LSB_FIRST)
spi-mpc52xx-psc.c:100:	out_be32(&psc->sicr, sicr);
spi-mpc52xx-psc.c:103:	 * Because psc->ccr is defined as 16bit register instead of 32bit
spi-mpc52xx-psc.c:106:	ccr = in_be16((u16 __iomem *)&psc->ccr);
spi-mpc52xx-psc.c:108:	if (cs->speed_hz)
spi-mpc52xx-psc.c:109:		ccr |= (MCLK / cs->speed_hz - 1) & 0xFF;
spi-mpc52xx-psc.c:111:		ccr |= (MCLK / 1000000 - 1) & 0xFF;
spi-mpc52xx-psc.c:112:	out_be16((u16 __iomem *)&psc->ccr, ccr);
spi-mpc52xx-psc.c:113:	mps->bits_per_word = cs->bits_per_word;
spi-mpc52xx-psc.c:115:	if (mps->cs_control)
spi-mpc52xx-psc.c:116:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 1 : 0);
spi-mpc52xx-psc.c:121:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
spi-mpc52xx-psc.c:123:	if (mps->cs_control)
spi-mpc52xx-psc.c:124:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 0 : 1);
spi-mpc52xx-psc.c:134:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
spi-mpc52xx-psc.c:135:	struct mpc52xx_psc __iomem *psc = mps->psc;
spi-mpc52xx-psc.c:136:	struct mpc52xx_psc_fifo __iomem *fifo = mps->fifo;
spi-mpc52xx-psc.c:139:	unsigned char *rx_buf = (unsigned char *)t->rx_buf;
spi-mpc52xx-psc.c:140:	unsigned char *tx_buf = (unsigned char *)t->tx_buf;
spi-mpc52xx-psc.c:146:	if (!t->tx_buf && !t->rx_buf && t->len)
spi-mpc52xx-psc.c:147:		return -EINVAL;
spi-mpc52xx-psc.c:150:	out_8(&psc->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);
spi-mpc52xx-psc.c:151:	while (rb < t->len) {
spi-mpc52xx-psc.c:152:		if (t->len - rb > MPC52xx_PSC_BUFSIZE) {
spi-mpc52xx-psc.c:156:			send_at_once = t->len - sb;
spi-mpc52xx-psc.c:157:			rfalarm = MPC52xx_PSC_BUFSIZE - (t->len - rb);
spi-mpc52xx-psc.c:161:		dev_dbg(&spi->dev, "send %d bytes...\n", send_at_once);
spi-mpc52xx-psc.c:162:		for (; send_at_once; sb++, send_at_once--) {
spi-mpc52xx-psc.c:165:				out_8(&psc->ircr2, 0x01);
spi-mpc52xx-psc.c:168:				out_8(&psc->mpc52xx_psc_buffer_8, tx_buf[sb]);
spi-mpc52xx-psc.c:170:				out_8(&psc->mpc52xx_psc_buffer_8, 0);
spi-mpc52xx-psc.c:178:		out_8(&psc->command, MPC52xx_PSC_SEL_MODE_REG_1);
spi-mpc52xx-psc.c:179:		if (t->len - rb == 1) {
spi-mpc52xx-psc.c:180:			out_8(&psc->mode, 0);
spi-mpc52xx-psc.c:182:			out_8(&psc->mode, MPC52xx_PSC_MODE_FFULL);
spi-mpc52xx-psc.c:183:			out_be16(&fifo->rfalarm, rfalarm);
spi-mpc52xx-psc.c:185:		out_be16(&psc->mpc52xx_psc_imr, MPC52xx_PSC_IMR_RXRDY);
spi-mpc52xx-psc.c:186:		wait_for_completion(&mps->done);
spi-mpc52xx-psc.c:187:		recv_at_once = in_be16(&fifo->rfnum);
spi-mpc52xx-psc.c:188:		dev_dbg(&spi->dev, "%d bytes received\n", recv_at_once);
spi-mpc52xx-psc.c:192:			for (; recv_at_once; rb++, recv_at_once--)
spi-mpc52xx-psc.c:193:				rx_buf[rb] = in_8(&psc->mpc52xx_psc_buffer_8);
spi-mpc52xx-psc.c:195:			for (; recv_at_once; rb++, recv_at_once--)
spi-mpc52xx-psc.c:196:				in_8(&psc->mpc52xx_psc_buffer_8);
spi-mpc52xx-psc.c:200:	out_8(&psc->command, MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);
spi-mpc52xx-psc.c:210:	spin_lock_irq(&mps->lock);
spi-mpc52xx-psc.c:211:	mps->busy = 1;
spi-mpc52xx-psc.c:212:	while (!list_empty(&mps->queue)) {
spi-mpc52xx-psc.c:219:		m = container_of(mps->queue.next, struct spi_message, queue);
spi-mpc52xx-psc.c:220:		list_del_init(&m->queue);
spi-mpc52xx-psc.c:221:		spin_unlock_irq(&mps->lock);
spi-mpc52xx-psc.c:223:		spi = m->spi;
spi-mpc52xx-psc.c:226:		list_for_each_entry (t, &m->transfers, transfer_list) {
spi-mpc52xx-psc.c:227:			if (t->bits_per_word || t->speed_hz) {
spi-mpc52xx-psc.c:235:			cs_change = t->cs_change;
spi-mpc52xx-psc.c:240:			m->actual_length += t->len;
spi-mpc52xx-psc.c:242:			if (t->delay_usecs)
spi-mpc52xx-psc.c:243:				udelay(t->delay_usecs);
spi-mpc52xx-psc.c:249:		m->status = status;
spi-mpc52xx-psc.c:250:		if (m->complete)
spi-mpc52xx-psc.c:251:			m->complete(m->context);
spi-mpc52xx-psc.c:258:		spin_lock_irq(&mps->lock);
spi-mpc52xx-psc.c:260:	mps->busy = 0;
spi-mpc52xx-psc.c:261:	spin_unlock_irq(&mps->lock);
spi-mpc52xx-psc.c:266:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
spi-mpc52xx-psc.c:267:	struct mpc52xx_psc_spi_cs *cs = spi->controller_state;
spi-mpc52xx-psc.c:270:	if (spi->bits_per_word%8)
spi-mpc52xx-psc.c:271:		return -EINVAL;
spi-mpc52xx-psc.c:276:			return -ENOMEM;
spi-mpc52xx-psc.c:277:		spi->controller_state = cs;
spi-mpc52xx-psc.c:280:	cs->bits_per_word = spi->bits_per_word;
spi-mpc52xx-psc.c:281:	cs->speed_hz = spi->max_speed_hz;
spi-mpc52xx-psc.c:283:	spin_lock_irqsave(&mps->lock, flags);
spi-mpc52xx-psc.c:284:	if (!mps->busy)
spi-mpc52xx-psc.c:286:	spin_unlock_irqrestore(&mps->lock, flags);
spi-mpc52xx-psc.c:294:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
spi-mpc52xx-psc.c:297:	m->actual_length = 0;
spi-mpc52xx-psc.c:298:	m->status = -EINPROGRESS;
spi-mpc52xx-psc.c:300:	spin_lock_irqsave(&mps->lock, flags);
spi-mpc52xx-psc.c:301:	list_add_tail(&m->queue, &mps->queue);
spi-mpc52xx-psc.c:302:	queue_work(mps->workqueue, &mps->work);
spi-mpc52xx-psc.c:303:	spin_unlock_irqrestore(&mps->lock, flags);
spi-mpc52xx-psc.c:310:	kfree(spi->controller_state);
spi-mpc52xx-psc.c:315:	struct mpc52xx_psc __iomem *psc = mps->psc;
spi-mpc52xx-psc.c:316:	struct mpc52xx_psc_fifo __iomem *fifo = mps->fifo;
spi-mpc52xx-psc.c:321:	mclken_div = (mps->sysclk ? mps->sysclk : 512000000) / MCLK;
spi-mpc52xx-psc.c:327:	out_8(&psc->command, MPC52xx_PSC_RST_RX);
spi-mpc52xx-psc.c:328:	out_8(&psc->command, MPC52xx_PSC_RST_TX);
spi-mpc52xx-psc.c:329:	out_8(&psc->command, MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);
spi-mpc52xx-psc.c:332:	out_be16(&psc->mpc52xx_psc_imr, 0);
spi-mpc52xx-psc.c:333:	out_8(&psc->command, MPC52xx_PSC_SEL_MODE_REG_1);
spi-mpc52xx-psc.c:334:	out_8(&fifo->rfcntl, 0);
spi-mpc52xx-psc.c:335:	out_8(&psc->mode, MPC52xx_PSC_MODE_FFULL);
spi-mpc52xx-psc.c:339:	out_be32(&psc->sicr, 0x0180C800);
spi-mpc52xx-psc.c:340:	out_be16((u16 __iomem *)&psc->ccr, 0x070F); /* default SPI Clk 1MHz */
spi-mpc52xx-psc.c:343:	out_8(&psc->ctur, 0x00);
spi-mpc52xx-psc.c:344:	out_8(&psc->ctlr, 0x84);
spi-mpc52xx-psc.c:346:	mps->bits_per_word = 8;
spi-mpc52xx-psc.c:354:	struct mpc52xx_psc __iomem *psc = mps->psc;
spi-mpc52xx-psc.c:357:	if (in_be16(&psc->mpc52xx_psc_isr) & MPC52xx_PSC_IMR_RXRDY) {
spi-mpc52xx-psc.c:358:		out_be16(&psc->mpc52xx_psc_imr, 0);
spi-mpc52xx-psc.c:359:		complete(&mps->done);
spi-mpc52xx-psc.c:365:/* bus_num is used only for the case dev->platform_data == NULL */
spi-mpc52xx-psc.c:376:		return -ENOMEM;
spi-mpc52xx-psc.c:381:	/* the spi->mode bits understood by this driver: */
spi-mpc52xx-psc.c:382:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;
spi-mpc52xx-psc.c:384:	mps->irq = irq;
spi-mpc52xx-psc.c:388:		mps->cs_control = NULL;
spi-mpc52xx-psc.c:389:		mps->sysclk = 0;
spi-mpc52xx-psc.c:390:		master->bus_num = bus_num;
spi-mpc52xx-psc.c:391:		master->num_chipselect = 255;
spi-mpc52xx-psc.c:393:		mps->cs_control = pdata->cs_control;
spi-mpc52xx-psc.c:394:		mps->sysclk = pdata->sysclk;
spi-mpc52xx-psc.c:395:		master->bus_num = pdata->bus_num;
spi-mpc52xx-psc.c:396:		master->num_chipselect = pdata->max_chipselect;
spi-mpc52xx-psc.c:398:	master->setup = mpc52xx_psc_spi_setup;
spi-mpc52xx-psc.c:399:	master->transfer = mpc52xx_psc_spi_transfer;
spi-mpc52xx-psc.c:400:	master->cleanup = mpc52xx_psc_spi_cleanup;
spi-mpc52xx-psc.c:401:	master->dev.of_node = dev->of_node;
spi-mpc52xx-psc.c:403:	mps->psc = ioremap(regaddr, size);
spi-mpc52xx-psc.c:404:	if (!mps->psc) {
spi-mpc52xx-psc.c:406:		ret = -EFAULT;
spi-mpc52xx-psc.c:410:	mps->fifo = ((void __iomem *)mps->psc) + sizeof(struct mpc52xx_psc);
spi-mpc52xx-psc.c:412:	ret = request_irq(mps->irq, mpc52xx_psc_spi_isr, 0, "mpc52xx-psc-spi",
spi-mpc52xx-psc.c:417:	ret = mpc52xx_psc_spi_port_config(master->bus_num, mps);
spi-mpc52xx-psc.c:423:	spin_lock_init(&mps->lock);
spi-mpc52xx-psc.c:424:	init_completion(&mps->done);
spi-mpc52xx-psc.c:425:	INIT_WORK(&mps->work, mpc52xx_psc_spi_work);
spi-mpc52xx-psc.c:426:	INIT_LIST_HEAD(&mps->queue);
spi-mpc52xx-psc.c:428:	mps->workqueue = create_singlethread_workqueue(
spi-mpc52xx-psc.c:429:		dev_name(master->dev.parent));
spi-mpc52xx-psc.c:430:	if (mps->workqueue == NULL) {
spi-mpc52xx-psc.c:431:		ret = -EBUSY;
spi-mpc52xx-psc.c:442:	destroy_workqueue(mps->workqueue);
spi-mpc52xx-psc.c:444:	free_irq(mps->irq, mps);
spi-mpc52xx-psc.c:446:	if (mps->psc)
spi-mpc52xx-psc.c:447:		iounmap(mps->psc);
spi-mpc52xx-psc.c:457:	s16 id = -1;
spi-mpc52xx-psc.c:459:	regaddr_p = of_get_address(op->dev.of_node, 0, &size64, NULL);
spi-mpc52xx-psc.c:461:		dev_err(&op->dev, "Invalid PSC address\n");
spi-mpc52xx-psc.c:462:		return -EINVAL;
spi-mpc52xx-psc.c:464:	regaddr64 = of_translate_address(op->dev.of_node, regaddr_p);
spi-mpc52xx-psc.c:467:	if (op->dev.platform_data == NULL) {
spi-mpc52xx-psc.c:470:		psc_nump = of_get_property(op->dev.of_node, "cell-index", NULL);
spi-mpc52xx-psc.c:472:			dev_err(&op->dev, "Invalid cell-index property\n");
spi-mpc52xx-psc.c:473:			return -EINVAL;
spi-mpc52xx-psc.c:478:	return mpc52xx_psc_spi_do_probe(&op->dev, (u32)regaddr64, (u32)size64,
spi-mpc52xx-psc.c:479:				irq_of_parse_and_map(op->dev.of_node, 0), id);
spi-mpc52xx-psc.c:487:	flush_workqueue(mps->workqueue);
spi-mpc52xx-psc.c:488:	destroy_workqueue(mps->workqueue);
spi-mpc52xx-psc.c:490:	free_irq(mps->irq, mps);
spi-mpc52xx-psc.c:491:	if (mps->psc)
spi-mpc52xx-psc.c:492:		iounmap(mps->psc);
spi-mpc52xx-psc.c:499:	{ .compatible = "fsl,mpc5200-psc-spi", },
spi-mpc52xx-psc.c:500:	{ .compatible = "mpc5200-psc-spi", }, /* old */
spi-mpc52xx-psc.c:510:		.name = "mpc52xx-psc-spi",
spi-zmp.c:2:*  /driver/spi/spi-zmp.c
spi-zmp.c:27:#include <linux/dma-mapping.h>
spi-zmp.c:28:#include "spi-zmp.h"
spi-zmp.c:38: * zmp_spi_devstate - per device data
spi-zmp.c:72:    unsigned char		cap_highspeed;	/*spi high-speed controller flag.*/
spi-zmp.c:108:*  @date        2011-08-19
spi-zmp.c:115:	pr_debug("CON: \t0x%x\n", ioread32(hw->regs + ZMP_SPICON));
spi-zmp.c:116:	pr_debug("STA: \t0x%x\n", ioread32(hw->regs + ZMP_SPISTA));
spi-zmp.c:117:	pr_debug("INT: \t0x%x\n", ioread32(hw->regs + ZMP_SPIINT));
spi-zmp.c:118:	pr_debug("CNT: \t0x%x\n", ioread32(hw->regs + ZMP_SPICNT));
spi-zmp.c:119:	pr_debug("DOUT: \t0x%x\n", ioread32(hw->regs + ZMP_SPIOUT));
spi-zmp.c:120:	pr_debug("DIN: \t0x%x\n", ioread32(hw->regs + ZMP_SPIIN));
spi-zmp.c:150:	((m->bus_num == ZMPSPI_BUS_NUM1) ? ADDR_SPI0_TX : ADDR_SPI1_TX)
spi-zmp.c:153:	((m->bus_num == ZMPSPI_BUS_NUM1) ? ADDR_SPI0_RX : ADDR_SPI1_RX)
spi-zmp.c:158:	return spi_master_get_devdata(sdev->master);
spi-zmp.c:165:*  @date        2013-03-19
spi-zmp.c:177:		val |= (hw->tx[hw->count+i] << i*8);
spi-zmp.c:187:*  @date        2013-03-19
spi-zmp.c:197:	l = (hw->len - hw->count) > 4 ? 4 : (hw->len - hw->count);
spi-zmp.c:201:	hw->count += l;
spi-zmp.c:210:*  @date        2013-03-19
spi-zmp.c:220:		hw->rx[hw->count + i] = (val >> i*8) & 0xff;
spi-zmp.c:229:*  @date        2013-03-19
spi-zmp.c:237:	l = (hw->len - hw->count) > 4 ? 4 : (hw->len - hw->count);
spi-zmp.c:240:	hw->count += l;	
spi-zmp.c:246:	return (hw->len - hw->count);
spi-zmp.c:251:	return (hw->xfer_mode == ZMPSPI_XFER_MODE_DMA);
spi-zmp.c:257:		if (readl(hw->regs + ZMP_SPICNT) == 0)
spi-zmp.c:260:	}while(timeout--);
spi-zmp.c:262:	return (timeout > 0) ? 0 : -EBUSY;
spi-zmp.c:273:*  @date        2011-08-19
spi-zmp.c:280:	struct zmp_spi_devstate *cs = spi->controller_state;
spi-zmp.c:282:	unsigned int cspol = (spi->mode & SPI_CS_HIGH) ? 1 : 0;
spi-zmp.c:287:			if(spi->chip_select == ZMPSPI_ONCHIP_CS) {
spi-zmp.c:288:				cs->spcon = ioread32(hw->regs + ZMP_SPICON);
spi-zmp.c:289:				cs->spcon &= ~FORCE_CS;
spi-zmp.c:290:				iowrite32(cs->spcon, hw->regs + ZMP_SPICON);
spi-zmp.c:293:				zmp_spi_set_cs(hw, spi->chip_select, cspol^1);
spi-zmp.c:300:			if(spi->chip_select == ZMPSPI_ONCHIP_CS) {
spi-zmp.c:301:				cs->spcon = ioread32(hw->regs + ZMP_SPICON);
spi-zmp.c:302:				cs->spcon |= FORCE_CS; //by Shaohua			
spi-zmp.c:303:				iowrite32(cs->spcon, hw->regs + ZMP_SPICON);
spi-zmp.c:306:				zmp_spi_set_cs(hw, spi->chip_select, cspol);
spi-zmp.c:316:*  @date        2011-08-19
spi-zmp.c:324:	struct zmp_spi_devstate *cs = spi->controller_state;
spi-zmp.c:329:    unsigned long clk = clk_get_rate(hw->clk);
spi-zmp.c:331:	bpw = t ? t->bits_per_word : spi->bits_per_word;
spi-zmp.c:332:	typical_hz  = t ? t->speed_hz : spi->max_speed_hz;
spi-zmp.c:338:		dev_err(&spi->dev, "invalid bits-per-word (%d)\n", bpw);
spi-zmp.c:339:		return -EINVAL;
spi-zmp.c:343:	if (spi->mode != cs->mode) {
spi-zmp.c:344:		cs->spcon &= ~(ZMP_SPICON_CPHA|ZMP_SPICON_CPOL);
spi-zmp.c:346:		if ((spi->mode & SPI_CPHA) == SPI_CPHA)
spi-zmp.c:347:			cs->spcon |= ZMP_SPICON_CPHA;
spi-zmp.c:349:		if ((spi->mode & SPI_CPOL) == SPI_CPOL)
spi-zmp.c:350:			cs->spcon |= ZMP_SPICON_CPOL;
spi-zmp.c:352:		cs->mode = spi->mode;
spi-zmp.c:357:	if ((cs->hz != typical_hz)&& (!hw->cap_highspeed) ) {
spi-zmp.c:359:			typical_hz = spi->max_speed_hz;
spi-zmp.c:361:        div = clk / (typical_hz*2) - 1;
spi-zmp.c:372:        if((hz - typical_hz) > 0)
spi-zmp.c:375:        cs->hz = hz;
spi-zmp.c:376:        cs->spcon &= ~ZMP_SPICON_CLKDIV;
spi-zmp.c:377:        cs->spcon |= div << 8;
spi-zmp.c:379:        pr_info("spi%d new hz is %u, div is %u(%s).\n", hw->master->bus_num, cs->hz, div, div ?"change":"not change");
spi-zmp.c:391:*  @date        2011-08-19
spi-zmp.c:399:	struct zmp_spi_devstate *cs = spi->controller_state;
spi-zmp.c:404:	if(likely((cs->initialed == 1) && (spi == hw->curdev)))
spi-zmp.c:407:	cs->spcon = readl(hw->regs + ZMP_SPICON);
spi-zmp.c:413:	          was deranged. Shaohua @2012-3-23	           
spi-zmp.c:415:		writel(cs->spcon, hw->regs + ZMP_SPICON);
spi-zmp.c:416:	    //printk("zmp_spi_setupxfer,con:%08x.\n", cs->spcon);
spi-zmp.c:417:		cs->initialed = 1;
spi-zmp.c:418:		hw->curdev = spi;
spi-zmp.c:431:	struct zmp_spi_devstate *cs = spi->controller_state;
spi-zmp.c:439:			dev_err(&spi->dev, "no memory for controller state\n");
spi-zmp.c:440:			return -ENOMEM;
spi-zmp.c:443:		cs->spcon = DFT_CON;
spi-zmp.c:444:		cs->hz = -1;
spi-zmp.c:445:		spi->controller_state = cs;
spi-zmp.c:446:		cs->initialed = 0;
spi-zmp.c:449:	if (spi->mode & ~(hw->master->mode_bits)) {
spi-zmp.c:450:		dev_dbg(&spi->dev, "setup: unsupported mode bits %x\n",
spi-zmp.c:451:			spi->mode & ~(hw->master->mode_bits));
spi-zmp.c:452:		return -EINVAL;
spi-zmp.c:459:		writel(cs->spcon, hw->regs + ZMP_SPICON);
spi-zmp.c:461:		cs->initialed = 1;
spi-zmp.c:462:		hw->curdev = spi;
spi-zmp.c:469:	kfree(spi->controller_state);
spi-zmp.c:476:	newmask = readl(hw->regs + ZMP_SPIINT);
spi-zmp.c:479:	writel(newmask, hw->regs + ZMP_SPIINT);
spi-zmp.c:488:	newmask = readl(hw->regs + ZMP_SPIINT);
spi-zmp.c:491:	writel(newmask, hw->regs + ZMP_SPIINT);
spi-zmp.c:500:*  @date        2013-03-15
spi-zmp.c:508:	enum spi_xfer_dir dir = hw->xfer_dir;
spi-zmp.c:513:    reg_value = readl(hw->regs + ZMP_SPICON);
spi-zmp.c:535:	if(t->tx_nbits == SPI_NBITS_QUAD || t->rx_nbits == SPI_NBITS_QUAD)
spi-zmp.c:539:	else if(t->tx_nbits == SPI_NBITS_DUAL || t->rx_nbits == SPI_NBITS_DUAL)
spi-zmp.c:548:    writel(reg_value, hw->regs + ZMP_SPICON);
spi-zmp.c:555:*  @date        2013-03-15
spi-zmp.c:564:    reg_value = readl(hw->regs + ZMP_SPICON);
spi-zmp.c:566:    writel(reg_value, hw->regs + ZMP_SPICON);
spi-zmp.c:578:	reinit_completion(&hw->done);	
spi-zmp.c:582:	iowrite32(val, hw->regs + ZMP_SPIEXTX);
spi-zmp.c:583:	iowrite32(count, hw->regs + ZMP_SPICNT);
spi-zmp.c:587:	if((count < 256) || ((unsigned long)buf & 0x3) || (count & (64 - 1))) {
spi-zmp.c:588:		l2_combuf_cpu((unsigned long)buf, hw->l2buf_tid, count, MEM2BUF);
spi-zmp.c:592:		memcpy(hw->txbuffer, buf, count);
spi-zmp.c:595:		l2_combuf_dma(hw->txdma_buffer, hw->l2buf_tid, count, MEM2BUF, ZMP_FALSE);
spi-zmp.c:599:	ret = wait_for_completion_timeout(&hw->done, msecs_to_jiffies(SPI_TRANS_TIMEOUT));
spi-zmp.c:603:		ret = -EINVAL;
spi-zmp.c:607:	if (flags && (l2_combuf_wait_dma_finish(hw->l2buf_tid) == ZMP_FALSE))	{
spi-zmp.c:609:		ret = -EINVAL;
spi-zmp.c:616:		ret = -EINVAL;
spi-zmp.c:624:	iowrite32(0, hw->regs + ZMP_SPIEXTX);
spi-zmp.c:625:	l2_clr_status(hw->l2buf_tid);
spi-zmp.c:639:	reinit_completion(&hw->done);
spi-zmp.c:643:	iowrite32(val, hw->regs + ZMP_SPIEXRX);
spi-zmp.c:644:	iowrite32(count, hw->regs + ZMP_SPICNT);	
spi-zmp.c:646:	if(count < 256 || ((unsigned long)buf & 0x3) || (count & (64 - 1))) {
spi-zmp.c:647:		l2_combuf_cpu((unsigned long)buf, hw->l2buf_rid, count, BUF2MEM);
spi-zmp.c:651:		l2_combuf_dma(hw->rxdma_buffer, hw->l2buf_rid, count, BUF2MEM, ZMP_FALSE);
spi-zmp.c:655:	ret = wait_for_completion_timeout(&hw->done, msecs_to_jiffies(SPI_TRANS_TIMEOUT));
spi-zmp.c:659:		ret = -EINVAL;
spi-zmp.c:664:	if (flags && l2_combuf_wait_dma_finish(hw->l2buf_rid) ==  ZMP_FALSE)	{
spi-zmp.c:666:		ret = -EINVAL;
spi-zmp.c:674:		ret = -EINVAL;
spi-zmp.c:679:		memcpy(buf, hw->rxbuffer, count);
spi-zmp.c:684:	iowrite32(0, hw->regs + ZMP_SPIEXRX);
spi-zmp.c:685:	l2_clr_status(hw->l2buf_rid);
spi-zmp.c:697:	reinit_completion(&hw->done);	
spi-zmp.c:701:	iowrite32(val, hw->regs + ZMP_SPIEXTX);
spi-zmp.c:704:	iowrite32(val, hw->regs + ZMP_SPIEXRX);
spi-zmp.c:706:	iowrite32(count, hw->regs + ZMP_SPICNT);
spi-zmp.c:710:		l2_combuf_cpu((unsigned long)tx, hw->l2buf_tid, count, MEM2BUF);
spi-zmp.c:711:		l2_combuf_cpu((unsigned long)rx, hw->l2buf_rid, count, BUF2MEM);
spi-zmp.c:715:		memcpy(hw->txbuffer, tx, count);
spi-zmp.c:717:		l2_combuf_dma(hw->txdma_buffer, hw->l2buf_tid, count, MEM2BUF, ZMP_FALSE);
spi-zmp.c:719:		l2_combuf_dma(hw->rxdma_buffer, hw->l2buf_rid, count, BUF2MEM, ZMP_FALSE);
spi-zmp.c:722:	ret = wait_for_completion_timeout(&hw->done, msecs_to_jiffies(SPI_TRANS_TIMEOUT));
spi-zmp.c:726:		ret = -EINVAL;
spi-zmp.c:730:	if (flags && ((ZMP_FALSE == l2_combuf_wait_dma_finish(hw->l2buf_tid)) || 
spi-zmp.c:731:		(ZMP_FALSE == l2_combuf_wait_dma_finish(hw->l2buf_rid))))
spi-zmp.c:734:		ret = -EINVAL;
spi-zmp.c:741:		ret = -EINVAL;
spi-zmp.c:746:		memcpy(rx, hw->rxbuffer, count);
spi-zmp.c:752:	iowrite32(0, hw->regs + ZMP_SPIEXTX);
spi-zmp.c:753:	iowrite32(0, hw->regs + ZMP_SPIEXRX);
spi-zmp.c:754:	l2_clr_status(hw->l2buf_tid);
spi-zmp.c:755:	l2_clr_status(hw->l2buf_rid);
spi-zmp.c:764:*  @date        2013-03-15
spi-zmp.c:773:	u32 count = t->len;
spi-zmp.c:775:	hw->tx = (unsigned char*)t->tx_buf;
spi-zmp.c:776:	hw->rx = t->rx_buf;
spi-zmp.c:777:	hw->l2buf_tid = hw->l2buf_rid = BUF_NULL;
spi-zmp.c:780:	switch(hw->xfer_dir) {
spi-zmp.c:784:			hw->l2buf_tid = l2_alloc(SPI_L2_TXADDR(hw->master));
spi-zmp.c:785:			hw->l2buf_rid = l2_alloc(SPI_L2_RXADDR(hw->master));
spi-zmp.c:787:			if ((BUF_NULL == hw->l2buf_tid) || (BUF_NULL == hw->l2buf_rid))
spi-zmp.c:790:				ret = -EBUSY;
spi-zmp.c:795:				hw->count = 0;
spi-zmp.c:796:				hw->len = (count > MAX_XFER_LEN) ?	MAX_XFER_LEN : count;
spi-zmp.c:798:				retlen = spi_dma_duplex(hw, hw->tx, hw->rx, hw->len);
spi-zmp.c:801:					ret = -EBUSY;
spi-zmp.c:804:				hw->tx += retlen;
spi-zmp.c:805:				hw->rx += retlen;
spi-zmp.c:806:				count -= retlen;
spi-zmp.c:813:			hw->l2buf_tid = l2_alloc(SPI_L2_TXADDR(hw->master));
spi-zmp.c:814:			if (unlikely(BUF_NULL == hw->l2buf_tid)) {
spi-zmp.c:816:				return -EBUSY;
spi-zmp.c:820:				hw->count = 0;
spi-zmp.c:821:				hw->len = (count > MAX_XFER_LEN) ? MAX_XFER_LEN : count;
spi-zmp.c:823:				retlen = spi_dma_write(hw, hw->tx + hw->count, hw->len);
spi-zmp.c:826:					ret = -EBUSY;
spi-zmp.c:829:				hw->tx += retlen;
spi-zmp.c:830:				count -= retlen;
spi-zmp.c:837:			hw->l2buf_rid = l2_alloc(SPI_L2_RXADDR(hw->master));
spi-zmp.c:838:			if (unlikely(BUF_NULL == hw->l2buf_rid))
spi-zmp.c:840:				return -EBUSY;
spi-zmp.c:844:				hw->count = 0;
spi-zmp.c:845:				hw->len = (count > MAX_XFER_LEN) ? MAX_XFER_LEN : count;
spi-zmp.c:847:				retlen = spi_dma_read(hw, hw->rx, hw->len);
spi-zmp.c:850:					ret = -EBUSY;
spi-zmp.c:853:				hw->rx += retlen;
spi-zmp.c:854:				count -= retlen;
spi-zmp.c:861:	if(hw->l2buf_tid != BUF_NULL)
spi-zmp.c:862:		l2_free(SPI_L2_TXADDR(hw->master));
spi-zmp.c:863:	if(hw->l2buf_rid != BUF_NULL)
spi-zmp.c:864:		l2_free(SPI_L2_RXADDR(hw->master));
spi-zmp.c:866:	return ret ? ret : t->len;
spi-zmp.c:873:*  @date        2013-03-15
spi-zmp.c:890:	hw->len = (t->len > MAX_XFER_LEN) ? MAX_XFER_LEN : t->len;
spi-zmp.c:891:	tran_4_nbr = hw->len/4;
spi-zmp.c:892:	frac_nbr = hw->len%4;
spi-zmp.c:894:	hw->tx = (unsigned char*)t->tx_buf;
spi-zmp.c:895:	hw->rx = t->rx_buf;
spi-zmp.c:897:	buff_tx = hw->tx;
spi-zmp.c:898:	buff_rx = hw->rx;
spi-zmp.c:902:	if (hw->len >= MAX_XFER_LEN)
spi-zmp.c:905:		return -EINVAL;
spi-zmp.c:909:	writel(hw->len, hw->regs + ZMP_SPICNT);
spi-zmp.c:915:				status = ioread32(hw->regs + ZMP_SPISTA);
spi-zmp.c:928:			iowrite32(*(volatile u32 *)(buff_tx + off_set_write), hw->regs + ZMP_SPIOUT);
spi-zmp.c:933:		else if (off_set_write < hw->len) {			
spi-zmp.c:939:					status = ioread32(hw->regs + ZMP_SPISTA);
spi-zmp.c:958:				iowrite32(val, hw->regs + ZMP_SPIOUT); 
spi-zmp.c:964:		status = ioread32(hw->regs + ZMP_SPISTA);			
spi-zmp.c:968:				val = ioread32(hw->regs + ZMP_SPIIN);
spi-zmp.c:972:				val = ioread32(hw->regs + ZMP_SPIIN);
spi-zmp.c:978:				val = ioread32(hw->regs + ZMP_SPIIN);
spi-zmp.c:984:				val = ioread32(hw->regs + ZMP_SPIIN);
spi-zmp.c:995:				val = ioread32(hw->regs + ZMP_SPIIN);
spi-zmp.c:1011:	return hw->len;
spi-zmp.c:1031:*  @date        2013-03-15
spi-zmp.c:1040:	reinit_completion(&hw->done);
spi-zmp.c:1042:	writel(hw->len, hw->regs + ZMP_SPICNT);
spi-zmp.c:1043:	enable_imask(hw, pio_imasks[hw->xfer_dir]);
spi-zmp.c:1045:	ret = wait_for_completion_timeout(&hw->done, msecs_to_jiffies(SPI_TRANS_TIMEOUT));
spi-zmp.c:1049:		return -EINVAL;
spi-zmp.c:1052:	return hw->count;
spi-zmp.c:1066:		return -EINVAL;
spi-zmp.c:1069:	writel(count, hw->regs + ZMP_SPICNT);
spi-zmp.c:1072:		status = readl(hw->regs + ZMP_SPISTA);
spi-zmp.c:1074:			writel(hw_txdword(hw), hw->regs + ZMP_SPIOUT);
spi-zmp.c:1078:				return hw->count;
spi-zmp.c:1085:		status = readl(hw->regs + ZMP_SPISTA);		
spi-zmp.c:1091:			return hw->count;
spi-zmp.c:1098:	return hw->count;
spi-zmp.c:1105:*  @date        2011-08-19
spi-zmp.c:1119:		return -EINVAL;
spi-zmp.c:1123:	writel(count, hw->regs + ZMP_SPICNT);
spi-zmp.c:1126:		status = readl(hw->regs + ZMP_SPISTA);			
spi-zmp.c:1131:				hw_rxdword(hw, readl(hw->regs + ZMP_SPIIN));
spi-zmp.c:1132:				hw_rxdword(hw, readl(hw->regs + ZMP_SPIIN));
spi-zmp.c:1134:				hw_rxdword(hw, readl(hw->regs + ZMP_SPIIN));
spi-zmp.c:1138:				hw_rxdword(hw, readl(hw->regs + ZMP_SPIIN));
spi-zmp.c:1143:				hw_rxdword(hw, readl(hw->regs + ZMP_SPIIN));
spi-zmp.c:1148:					return hw->count;
spi-zmp.c:1156:	return hw->count;	
spi-zmp.c:1163:*  @date        2013-03-15
spi-zmp.c:1170:	int retlen = -1;
spi-zmp.c:1171:	u32 count = t->len;
spi-zmp.c:1173:	hw->tx = (unsigned char*)t->tx_buf;
spi-zmp.c:1174:	hw->rx = t->rx_buf;
spi-zmp.c:1177:	switch(hw->xfer_dir) {
spi-zmp.c:1181:				hw->count = 0;
spi-zmp.c:1182:				hw->len = (count > MAX_XFER_LEN) ? MAX_XFER_LEN : count;
spi-zmp.c:1184:				retlen = spi_pio_write(hw, hw->tx, hw->len);
spi-zmp.c:1189:				hw->tx += retlen;
spi-zmp.c:1190:				count -= retlen;
spi-zmp.c:1198:				hw->count = 0;
spi-zmp.c:1199:				hw->len = (count > MAX_XFER_LEN) ? MAX_XFER_LEN : count;
spi-zmp.c:1201:				retlen = spi_pio_read(hw, hw->rx, hw->len);
spi-zmp.c:1206:				hw->rx += retlen;
spi-zmp.c:1207:				count -= retlen;
spi-zmp.c:1215:	return (retlen<0) ? retlen : t->len;
spi-zmp.c:1224:*  @date        2011-08-19
spi-zmp.c:1235:		t->tx_buf, t->rx_buf, t->len);
spi-zmp.c:1237:	hw->xfer_mode = t->len < 256 ? ZMPSPI_XFER_MODE_CPU : ZMPSPI_XFER_MODE_DMA;
spi-zmp.c:1239:	hw->xfer_dir = (t->tx_buf && t->rx_buf) ? SPI_DIR_TXRX : 
spi-zmp.c:1240:				t->tx_buf ? SPI_DIR_TX : SPI_DIR_RX;
spi-zmp.c:1244:	if(hw->xfer_dir == SPI_DIR_TXRX) {		
spi-zmp.c:1264:*  @date        2011-08-19
spi-zmp.c:1274:	status = readl(hw->regs + ZMP_SPISTA);
spi-zmp.c:1282:			complete(&hw->done);
spi-zmp.c:1285:		switch(hw->xfer_dir) {	
spi-zmp.c:1291:						hw_rxdword(hw, readl(hw->regs + ZMP_SPIIN));						
spi-zmp.c:1292:					hw_rxdword(hw, readl(hw->regs + ZMP_SPIIN));
spi-zmp.c:1294:					if (hw->count >= hw->len) {
spi-zmp.c:1296:						complete(&hw->done);
spi-zmp.c:1304:					if (hw->count < hw->len) {
spi-zmp.c:1305:						if((status & ZMP_SPISTA_TXEMP) && ((hw->count - hw->len)>4))
spi-zmp.c:1306:							writel(hw_txdword(hw), hw->regs + ZMP_SPIOUT);
spi-zmp.c:1308:						writel(hw_txdword(hw), hw->regs + ZMP_SPIOUT);
spi-zmp.c:1311:						complete(&hw->done);
spi-zmp.c:1330:*  @date        2011-08-19
spi-zmp.c:1336:	BUG_ON(hw->master && hw->master->bus_num >= ZMPSPI_MAX_BUS_NUM);
spi-zmp.c:1339:	writel(DFT_DIV<<8 | DFT_CON | (1<<1),hw->regs + ZMP_SPICON);
spi-zmp.c:1341:	writel(0, hw->regs + ZMP_SPIINT);
spi-zmp.c:1347:* date:   2018-12-10
spi-zmp.c:1359:    if (transfer->len)
spi-zmp.c:1362:	if (status == transfer->len)
spi-zmp.c:1365:		status = -EREMOTEIO;
spi-zmp.c:1375:	enable = (!!(spi->mode & SPI_CS_HIGH) == enable);
spi-zmp.c:1386:*  @date        2011-08-19
spi-zmp.c:1396:	struct device_node *np = pdev->dev.of_node;
spi-zmp.c:1401:	master = spi_alloc_master(&pdev->dev, sizeof(struct zmp_spi));
spi-zmp.c:1404:		dev_err(&pdev->dev, "No memory for spi_master\n");
spi-zmp.c:1405:		err = -ENOMEM;
spi-zmp.c:1412:	hw->master = spi_master_get(master);
spi-zmp.c:1413:	hw->dev = &pdev->dev;
spi-zmp.c:1414:	hw->xfer_mode = ZMPSPI_XFER_MODE_DMA;
spi-zmp.c:1418:	init_completion(&hw->done);
spi-zmp.c:1421:	/* the spi->mode bits understood by this driver: */
spi-zmp.c:1422:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;
spi-zmp.c:1423:	master->num_chipselect = 1;
spi-zmp.c:1424:    master->setup  = zmp_spi_setup;
spi-zmp.c:1425:    master->cleanup = zmp_spi_cleanup;
spi-zmp.c:1426:    master->set_cs = zmp_spi_set_chipsel;
spi-zmp.c:1427:    master->transfer_one = zmp_spi_transfer_one;
spi-zmp.c:1428:	master->dev.of_node = pdev->dev.of_node;
spi-zmp.c:1429:	master->bus_num = of_alias_get_id(master->dev.of_node, "spi");
spi-zmp.c:1434:		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
spi-zmp.c:1435:		err = -ENOENT;
spi-zmp.c:1439:	hw->ioarea = request_mem_region(res->start, resource_size(res),
spi-zmp.c:1440:					pdev->name);
spi-zmp.c:1442:	if (hw->ioarea == NULL) {
spi-zmp.c:1443:		dev_err(&pdev->dev, "Cannot reserve region\n");
spi-zmp.c:1444:		err = -ENXIO;
spi-zmp.c:1448:	hw->regs = ioremap(res->start, resource_size(res));
spi-zmp.c:1449:	if (hw->regs == NULL) {
spi-zmp.c:1450:		dev_err(&pdev->dev, "Cannot map IO\n");
spi-zmp.c:1451:		err = -ENXIO;
spi-zmp.c:1455:	hw->irq = platform_get_irq(pdev, 0);
spi-zmp.c:1456:	if (hw->irq < 0) {
spi-zmp.c:1457:		dev_err(&pdev->dev, "No IRQ specified\n");
spi-zmp.c:1458:		err = -ENOENT;
spi-zmp.c:1462:	err = request_irq(hw->irq, zmp_spi_irq, 0, pdev->name, hw);
spi-zmp.c:1464:		dev_err(&pdev->dev, "Cannot claim IRQ\n");
spi-zmp.c:1468:    if(master->bus_num == 0){
spi-zmp.c:1469:        err = of_property_read_u32(pdev->dev.of_node, "spi-bus-frequency",
spi-zmp.c:1472:		     dev_warn(&pdev->dev,
spi-zmp.c:1473:			    "Could not read spi-bus-frequency property\n");
spi-zmp.c:1476:        hw->bus_clk = devm_clk_get(&pdev->dev, "spi0_bus");
spi-zmp.c:1477:	    if (IS_ERR(hw->bus_clk)) {
spi-zmp.c:1478:		    err = PTR_ERR(hw->bus_clk);
spi-zmp.c:1482:	    rc = clk_set_rate(hw->bus_clk, spi_bus_freq);
spi-zmp.c:1484:		    dev_err(&pdev->dev, "%s: clk_set_rate returned %d\n",
spi-zmp.c:1489:    hw->clk = clk_get(&pdev->dev, NULL);
spi-zmp.c:1490:	if (IS_ERR(hw->clk)) {
spi-zmp.c:1491:		dev_err(&pdev->dev, "No clock for device\n");
spi-zmp.c:1492:		err = PTR_ERR(hw->clk);
spi-zmp.c:1495:    clk_prepare_enable(hw->clk);
spi-zmp.c:1497:    /*spi high-speed controller cap */
spi-zmp.c:1498:	if (of_property_read_bool(np, "cap-spi-highspeed")){
spi-zmp.c:1499:		hw->cap_highspeed = 1;
spi-zmp.c:1501:		hw->cap_highspeed = 0;}
spi-zmp.c:1504:	err = dma_set_mask_and_coherent(hw->dev, DMA_BIT_MASK(32));
spi-zmp.c:1506:		dev_warn(hw->dev, "Unable to set dma mask\n");
spi-zmp.c:1509:    hw->txbuffer = dmam_alloc_coherent(hw->dev, SPI_DMA_MAX_LEN,
spi-zmp.c:1510:			&hw->txdma_buffer, GFP_KERNEL);
spi-zmp.c:1511:	if (!hw->txbuffer)
spi-zmp.c:1512:		return -ENOMEM;
spi-zmp.c:1514:    hw->rxbuffer = dmam_alloc_coherent(hw->dev, SPI_DMA_MAX_LEN,
spi-zmp.c:1515:			&hw->rxdma_buffer, GFP_KERNEL);
spi-zmp.c:1516:	if (!hw->rxbuffer)
spi-zmp.c:1517:		return -ENOMEM;
spi-zmp.c:1523:	err = devm_spi_register_master(&pdev->dev, master);
spi-zmp.c:1525:		dev_err(&pdev->dev, "Failed to register SPI master\n");
spi-zmp.c:1530:		master->bus_num, zmp_spi_use_dma(hw)?"DMA":"PIO");
spi-zmp.c:1535:	clk_disable(hw->clk);
spi-zmp.c:1536:	clk_put(hw->clk);
spi-zmp.c:1539:	free_irq(hw->irq, hw);
spi-zmp.c:1542:	iounmap(hw->regs);
spi-zmp.c:1545:	release_resource(hw->ioarea);
spi-zmp.c:1548:	spi_master_put(hw->master);
spi-zmp.c:1561:	spi_unregister_master(hw->master);
spi-zmp.c:1563:	clk_disable(hw->clk);
spi-zmp.c:1564:	clk_put(hw->clk);
spi-zmp.c:1566:	free_irq(hw->irq, hw);
spi-zmp.c:1567:	iounmap(hw->regs);
spi-zmp.c:1569:	release_resource(hw->ioarea);
spi-zmp.c:1571:	spi_master_put(hw->master);
spi-zmp.c:1582:	clk_disable(hw->clk);
spi-zmp.c:1605:	{ .compatible = "zlgmcu,zmp110x-spi0", },
spi-zmp.c:1606:	{ .compatible = "zlgmcu,zmp110x-spi1", },
spi-zmp.c:1611:MODULE_ALIAS("platform:zmp-spi");
spi-zmp.c:1616:		.name	= "zmp-spi",
spi-zmp.c:1635:MODULE_DESCRIPTION("ZMP On-Chip SPI controller driver");
spi-ppc4xx.c:44:#include <asm/dcr-regs.h>
spi-ppc4xx.c:46:/* bits in mode register - bit 0 is MSb */
spi-ppc4xx.c:59: * SPI_PPC4XX_MODE_RD = 0 means "MSB first" - this is the normal mode
spi-ppc4xx.c:60: * SPI_PPC4XX_MODE_RD = 1 means "LSB first" - this is bit-reversed mode
spi-ppc4xx.c:108:	 *    CDM = (OPBCLK/4*SCPClkOut) - 1
spi-ppc4xx.c:150:	dev_dbg(&spi->dev, "txrx: tx %p, rx %p, len %d\n",
spi-ppc4xx.c:151:		t->tx_buf, t->rx_buf, t->len);
spi-ppc4xx.c:153:	hw = spi_master_get_devdata(spi->master);
spi-ppc4xx.c:155:	hw->tx = t->tx_buf;
spi-ppc4xx.c:156:	hw->rx = t->rx_buf;
spi-ppc4xx.c:157:	hw->len = t->len;
spi-ppc4xx.c:158:	hw->count = 0;
spi-ppc4xx.c:161:	data = hw->tx ? hw->tx[0] : 0;
spi-ppc4xx.c:162:	out_8(&hw->regs->txd, data);
spi-ppc4xx.c:163:	out_8(&hw->regs->cr, SPI_PPC4XX_CR_STR);
spi-ppc4xx.c:164:	wait_for_completion(&hw->done);
spi-ppc4xx.c:166:	return hw->count;
spi-ppc4xx.c:171:	struct ppc4xx_spi *hw = spi_master_get_devdata(spi->master);
spi-ppc4xx.c:172:	struct spi_ppc4xx_cs *cs = spi->controller_state;
spi-ppc4xx.c:179:	bits_per_word = spi->bits_per_word;
spi-ppc4xx.c:180:	speed = spi->max_speed_hz;
spi-ppc4xx.c:187:		if (t->bits_per_word)
spi-ppc4xx.c:188:			bits_per_word = t->bits_per_word;
spi-ppc4xx.c:190:		if (t->speed_hz)
spi-ppc4xx.c:191:			speed = min(t->speed_hz, spi->max_speed_hz);
spi-ppc4xx.c:194:	if (!speed || (speed > spi->max_speed_hz)) {
spi-ppc4xx.c:195:		dev_err(&spi->dev, "invalid speed_hz (%d)\n", speed);
spi-ppc4xx.c:196:		return -EINVAL;
spi-ppc4xx.c:200:	out_8(&hw->regs->mode, cs->mode);
spi-ppc4xx.c:204:	scr = (hw->opb_freq / speed) - 1;
spi-ppc4xx.c:208:	dev_dbg(&spi->dev, "setting pre-scaler to %d (hz %d)\n", cdm, speed);
spi-ppc4xx.c:210:	if (in_8(&hw->regs->cdm) != cdm)
spi-ppc4xx.c:211:		out_8(&hw->regs->cdm, cdm);
spi-ppc4xx.c:213:	mutex_lock(&hw->bitbang.lock);
spi-ppc4xx.c:214:	if (!hw->bitbang.busy) {
spi-ppc4xx.c:215:		hw->bitbang.chipselect(spi, BITBANG_CS_INACTIVE);
spi-ppc4xx.c:218:	mutex_unlock(&hw->bitbang.lock);
spi-ppc4xx.c:225:	struct spi_ppc4xx_cs *cs = spi->controller_state;
spi-ppc4xx.c:227:	if (!spi->max_speed_hz) {
spi-ppc4xx.c:228:		dev_err(&spi->dev, "invalid max_speed_hz (must be non-zero)\n");
spi-ppc4xx.c:229:		return -EINVAL;
spi-ppc4xx.c:235:			return -ENOMEM;
spi-ppc4xx.c:236:		spi->controller_state = cs;
spi-ppc4xx.c:241:	 * no need to read-modify-write
spi-ppc4xx.c:243:	cs->mode = SPI_PPC4XX_MODE_SPE;
spi-ppc4xx.c:245:	switch (spi->mode & (SPI_CPHA | SPI_CPOL)) {
spi-ppc4xx.c:247:		cs->mode |= SPI_CLK_MODE0;
spi-ppc4xx.c:250:		cs->mode |= SPI_CLK_MODE1;
spi-ppc4xx.c:253:		cs->mode |= SPI_CLK_MODE2;
spi-ppc4xx.c:256:		cs->mode |= SPI_CLK_MODE3;
spi-ppc4xx.c:260:	if (spi->mode & SPI_LSB_FIRST)
spi-ppc4xx.c:261:		cs->mode |= SPI_PPC4XX_MODE_RD;
spi-ppc4xx.c:268:	struct ppc4xx_spi *hw = spi_master_get_devdata(spi->master);
spi-ppc4xx.c:269:	unsigned int cs = spi->chip_select;
spi-ppc4xx.c:274:	 * case of a non-existent (dummy) chip select, do nothing.
spi-ppc4xx.c:277:	if (!hw->master->num_chipselect || hw->gpios[cs] == -EEXIST)
spi-ppc4xx.c:280:	cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;
spi-ppc4xx.c:284:	gpio_set_value(hw->gpios[cs], cspol);
spi-ppc4xx.c:296:	status = in_8(&hw->regs->sr);
spi-ppc4xx.c:301:	 * BSY de-asserts one cycle after the transfer is complete.  The
spi-ppc4xx.c:310:		dev_dbg(hw->dev, "got interrupt but spi still busy?\n");
spi-ppc4xx.c:313:			lstatus = in_8(&hw->regs->sr);
spi-ppc4xx.c:317:			dev_err(hw->dev, "busywait: too many loops!\n");
spi-ppc4xx.c:318:			complete(&hw->done);
spi-ppc4xx.c:322:			status = in_8(&hw->regs->sr);
spi-ppc4xx.c:323:			dev_dbg(hw->dev, "loops %d status %x\n", cnt, status);
spi-ppc4xx.c:327:	count = hw->count;
spi-ppc4xx.c:328:	hw->count++;
spi-ppc4xx.c:331:	data = in_8(&hw->regs->rxd);
spi-ppc4xx.c:332:	if (hw->rx)
spi-ppc4xx.c:333:		hw->rx[count] = data;
spi-ppc4xx.c:337:	if (count < hw->len) {
spi-ppc4xx.c:338:		data = hw->tx ? hw->tx[count] : 0;
spi-ppc4xx.c:339:		out_8(&hw->regs->txd, data);
spi-ppc4xx.c:340:		out_8(&hw->regs->cr, SPI_PPC4XX_CR_STR);
spi-ppc4xx.c:342:		complete(&hw->done);
spi-ppc4xx.c:350:	kfree(spi->controller_state);
spi-ppc4xx.c:367:	if (hw->master->num_chipselect) {
spi-ppc4xx.c:369:		for (i = 0; i < hw->master->num_chipselect; i++)
spi-ppc4xx.c:370:			if (gpio_is_valid(hw->gpios[i]))
spi-ppc4xx.c:371:				gpio_free(hw->gpios[i]);
spi-ppc4xx.c:373:		kfree(hw->gpios);
spi-ppc4xx.c:374:		hw->gpios = NULL;
spi-ppc4xx.c:387:	struct device_node *np = op->dev.of_node;
spi-ppc4xx.c:388:	struct device *dev = &op->dev;
spi-ppc4xx.c:396:		return -ENOMEM;
spi-ppc4xx.c:397:	master->dev.of_node = np;
spi-ppc4xx.c:400:	hw->master = master;
spi-ppc4xx.c:401:	hw->dev = dev;
spi-ppc4xx.c:403:	init_completion(&hw->done);
spi-ppc4xx.c:406:	 * A count of zero implies a single SPI device without any chip-select.
spi-ppc4xx.c:414:		hw->gpios = kzalloc(sizeof(int) * num_gpios, GFP_KERNEL);
spi-ppc4xx.c:415:		if (!hw->gpios) {
spi-ppc4xx.c:416:			ret = -ENOMEM;
spi-ppc4xx.c:425:			hw->gpios[i] = gpio;
spi-ppc4xx.c:428:				/* Real CS - set the initial state. */
spi-ppc4xx.c:429:				ret = gpio_request(gpio, np->name);
spi-ppc4xx.c:438:			} else if (gpio == -EEXIST) {
spi-ppc4xx.c:442:				ret = -EINVAL;
spi-ppc4xx.c:449:	bbp = &hw->bitbang;
spi-ppc4xx.c:450:	bbp->master = hw->master;
spi-ppc4xx.c:451:	bbp->setup_transfer = spi_ppc4xx_setupxfer;
spi-ppc4xx.c:452:	bbp->chipselect = spi_ppc4xx_chipsel;
spi-ppc4xx.c:453:	bbp->txrx_bufs = spi_ppc4xx_txrx;
spi-ppc4xx.c:454:	bbp->use_dma = 0;
spi-ppc4xx.c:455:	bbp->master->setup = spi_ppc4xx_setup;
spi-ppc4xx.c:456:	bbp->master->cleanup = spi_ppc4xx_cleanup;
spi-ppc4xx.c:457:	bbp->master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-ppc4xx.c:459:	/* the spi->mode bits understood by this driver: */
spi-ppc4xx.c:460:	bbp->master->mode_bits =
spi-ppc4xx.c:464:	bbp->master->num_chipselect = num_gpios > 0 ? num_gpios : 0;
spi-ppc4xx.c:470:		ret = -ENODEV;
spi-ppc4xx.c:474:	clk = of_get_property(opbnp, "clock-frequency", NULL);
spi-ppc4xx.c:476:		dev_err(dev, "OPB: no clock-frequency property set\n");
spi-ppc4xx.c:478:		ret = -ENODEV;
spi-ppc4xx.c:481:	hw->opb_freq = *clk;
spi-ppc4xx.c:482:	hw->opb_freq >>= 2;
spi-ppc4xx.c:490:	hw->mapbase = resource.start;
spi-ppc4xx.c:491:	hw->mapsize = resource_size(&resource);
spi-ppc4xx.c:494:	if (hw->mapsize < sizeof(struct spi_ppc4xx_regs)) {
spi-ppc4xx.c:496:		ret = -EINVAL;
spi-ppc4xx.c:501:	hw->irqnum = irq_of_parse_and_map(np, 0);
spi-ppc4xx.c:502:	ret = request_irq(hw->irqnum, spi_ppc4xx_int,
spi-ppc4xx.c:509:	if (!request_mem_region(hw->mapbase, hw->mapsize, DRIVER_NAME)) {
spi-ppc4xx.c:511:		ret = -EBUSY;
spi-ppc4xx.c:515:	hw->regs = ioremap(hw->mapbase, sizeof(struct spi_ppc4xx_regs));
spi-ppc4xx.c:517:	if (!hw->regs) {
spi-ppc4xx.c:519:		ret = -ENXIO;
spi-ppc4xx.c:526:	dev->dma_mask = 0;
spi-ppc4xx.c:538:	iounmap(hw->regs);
spi-ppc4xx.c:540:	release_mem_region(hw->mapbase, hw->mapsize);
spi-ppc4xx.c:542:	free_irq(hw->irqnum, hw);
spi-ppc4xx.c:557:	spi_bitbang_stop(&hw->bitbang);
spi-ppc4xx.c:558:	release_mem_region(hw->mapbase, hw->mapsize);
spi-ppc4xx.c:559:	free_irq(hw->irqnum, hw);
spi-ppc4xx.c:560:	iounmap(hw->regs);
spi-ppc4xx.c:567:	{ .compatible = "ibm,ppc4xx-spi", },
spi-s3c24xx-fiq.h:6: * S3C24XX SPI - FIQ pseudo-DMA transfer support
spi-pxa2xx.h:109:	return __raw_readl(drv_data->ioaddr + reg);
spi-pxa2xx.h:115:	__raw_writel(val, drv_data->ioaddr + reg);
spi-pxa2xx.h:121:#define ERROR_STATE ((void *)-1)
spi-pxa2xx.h:128:	switch (drv_data->ssp_type) {
spi-pxa2xx.h:140:	if (drv_data->ssp_type == CE4100_SSP ||
spi-pxa2xx.h:141:	    drv_data->ssp_type == QUARK_X1000_SSP)
spi-pxa2xx.h:197:	return -ENODEV;
spi-topcliff-pch.c:87:#define MASK_SPBRR_SPBR_BITS	((1 << 10) - 1)
spi-topcliff-pch.c:132: * struct pch_spi_data - Holds the SPI channel specific details
spi-topcliff-pch.c:199: * struct pch_spi_board_data - Holds the SPI device specific details
spi-topcliff-pch.c:225: * pch_spi_writereg() - Performs  register writes
spi-topcliff-pch.c:233:	iowrite32(val, (data->io_remap_addr + idx));
spi-topcliff-pch.c:237: * pch_spi_readreg() - Performs register reads
spi-topcliff-pch.c:244:	return ioread32(data->io_remap_addr + idx);
spi-topcliff-pch.c:261: * pch_spi_clear_fifo() - Clears the Transmit and Receive FIFOs
spi-topcliff-pch.c:284:	if (data->transfer_active) {
spi-topcliff-pch.c:285:		rx_index = data->rx_index;
spi-topcliff-pch.c:286:		tx_index = data->tx_index;
spi-topcliff-pch.c:287:		bpw_len = data->bpw_len;
spi-topcliff-pch.c:288:		pkt_rx_buffer = data->pkt_rx_buff;
spi-topcliff-pch.c:289:		pkt_tx_buff = data->pkt_tx_buff;
spi-topcliff-pch.c:303:		if ((bpw_len - rx_index) <= PCH_MAX_FIFO_DEPTH) {
spi-topcliff-pch.c:315:		data->tx_index = tx_index;
spi-topcliff-pch.c:316:		data->rx_index = rx_index;
spi-topcliff-pch.c:322:				pch_spi_setclr_reg(data->master, PCH_SPCR, 0,
spi-topcliff-pch.c:327:				data->transfer_complete = true;
spi-topcliff-pch.c:328:				data->transfer_active = false;
spi-topcliff-pch.c:329:				wake_up(&data->wait);
spi-topcliff-pch.c:331:				dev_vdbg(&data->master->dev,
spi-topcliff-pch.c:340: * pch_spi_handler() - Interrupt handler
spi-topcliff-pch.c:351:	struct pch_spi_board_data *board_dat = data->board_dat;
spi-topcliff-pch.c:353:	if (board_dat->suspend_sts) {
spi-topcliff-pch.c:354:		dev_dbg(&board_dat->pdev->dev,
spi-topcliff-pch.c:359:	io_remap_addr = data->io_remap_addr;
spi-topcliff-pch.c:365:		dev_err(&board_dat->pdev->dev, "%s Over run error\n", __func__);
spi-topcliff-pch.c:366:		if (data->current_msg->complete) {
spi-topcliff-pch.c:367:			data->transfer_complete = true;
spi-topcliff-pch.c:368:			data->current_msg->status = -EIO;
spi-topcliff-pch.c:369:			data->current_msg->complete(data->current_msg->context);
spi-topcliff-pch.c:370:			data->bcurrent_msg_processing = false;
spi-topcliff-pch.c:371:			data->current_msg = NULL;
spi-topcliff-pch.c:372:			data->cur_trans = NULL;
spi-topcliff-pch.c:376:	if (data->use_dma)
spi-topcliff-pch.c:385:	dev_dbg(&board_dat->pdev->dev, "%s EXIT return value=%d\n",
spi-topcliff-pch.c:392: * pch_spi_set_baud_rate() - Sets SPBR field in SPBRR
spi-topcliff-pch.c:408: * pch_spi_set_bits_per_word() - Sets SIZE field in SPBRR
spi-topcliff-pch.c:422: * pch_spi_setup_transfer() - Configures the PCH SPI hardware for transfer
spi-topcliff-pch.c:429:	dev_dbg(&spi->dev, "%s SPBRR content =%x setting baud rate=%d\n",
spi-topcliff-pch.c:430:		__func__, pch_spi_readreg(spi->master, PCH_SPBRR),
spi-topcliff-pch.c:431:		spi->max_speed_hz);
spi-topcliff-pch.c:432:	pch_spi_set_baud_rate(spi->master, spi->max_speed_hz);
spi-topcliff-pch.c:435:	pch_spi_set_bits_per_word(spi->master, spi->bits_per_word);
spi-topcliff-pch.c:437:	if (!(spi->mode & SPI_LSB_FIRST))
spi-topcliff-pch.c:439:	if (spi->mode & SPI_CPOL)
spi-topcliff-pch.c:441:	if (spi->mode & SPI_CPHA)
spi-topcliff-pch.c:443:	pch_spi_setclr_reg(spi->master, PCH_SPCR, flags,
spi-topcliff-pch.c:447:	pch_spi_clear_fifo(spi->master);
spi-topcliff-pch.c:451: * pch_spi_reset() - Clears SPI registers
spi-topcliff-pch.c:467:	struct pch_spi_data *data = spi_master_get_devdata(pspi->master);
spi-topcliff-pch.c:471:	spin_lock_irqsave(&data->lock, flags);
spi-topcliff-pch.c:473:	list_for_each_entry(transfer, &pmsg->transfers, transfer_list) {
spi-topcliff-pch.c:474:		if (!transfer->tx_buf && !transfer->rx_buf) {
spi-topcliff-pch.c:475:			dev_err(&pspi->dev,
spi-topcliff-pch.c:477:			retval = -EINVAL;
spi-topcliff-pch.c:481:		if (!transfer->len) {
spi-topcliff-pch.c:482:			dev_err(&pspi->dev, "%s Transfer length invalid\n",
spi-topcliff-pch.c:484:			retval = -EINVAL;
spi-topcliff-pch.c:488:		dev_dbg(&pspi->dev,
spi-topcliff-pch.c:492:	spin_unlock_irqrestore(&data->lock, flags);
spi-topcliff-pch.c:495:	if (data->status == STATUS_EXITING) {
spi-topcliff-pch.c:496:		dev_err(&pspi->dev, "%s status = STATUS_EXITING.\n", __func__);
spi-topcliff-pch.c:497:		retval = -ESHUTDOWN;
spi-topcliff-pch.c:501:	/* If suspended ,return -EINVAL */
spi-topcliff-pch.c:502:	if (data->board_dat->suspend_sts) {
spi-topcliff-pch.c:503:		dev_err(&pspi->dev, "%s suspend; returning EINVAL\n", __func__);
spi-topcliff-pch.c:504:		retval = -EINVAL;
spi-topcliff-pch.c:509:	pmsg->actual_length = 0;
spi-topcliff-pch.c:510:	dev_dbg(&pspi->dev, "%s - pmsg->status =%d\n", __func__, pmsg->status);
spi-topcliff-pch.c:512:	pmsg->status = -EINPROGRESS;
spi-topcliff-pch.c:513:	spin_lock_irqsave(&data->lock, flags);
spi-topcliff-pch.c:515:	list_add_tail(&pmsg->queue, &data->queue);
spi-topcliff-pch.c:516:	spin_unlock_irqrestore(&data->lock, flags);
spi-topcliff-pch.c:518:	dev_dbg(&pspi->dev, "%s - Invoked list_add_tail\n", __func__);
spi-topcliff-pch.c:521:	queue_work(data->wk, &data->work);
spi-topcliff-pch.c:522:	dev_dbg(&pspi->dev, "%s - Invoked queue work\n", __func__);
spi-topcliff-pch.c:527:	dev_dbg(&pspi->dev, "%s RETURN=%d\n", __func__, retval);
spi-topcliff-pch.c:530:	dev_dbg(&pspi->dev, "%s RETURN=%d\n", __func__, retval);
spi-topcliff-pch.c:531:	spin_unlock_irqrestore(&data->lock, flags);
spi-topcliff-pch.c:538:	if (data->current_chip != NULL) {
spi-topcliff-pch.c:539:		if (pspi->chip_select != data->n_curnt_chip) {
spi-topcliff-pch.c:540:			dev_dbg(&pspi->dev, "%s : different slave\n", __func__);
spi-topcliff-pch.c:541:			data->current_chip = NULL;
spi-topcliff-pch.c:545:	data->current_chip = pspi;
spi-topcliff-pch.c:547:	data->n_curnt_chip = data->current_chip->chip_select;
spi-topcliff-pch.c:549:	dev_dbg(&pspi->dev, "%s :Invoking pch_spi_setup_transfer\n", __func__);
spi-topcliff-pch.c:563:	if (data->cur_trans->speed_hz) {
spi-topcliff-pch.c:564:		dev_dbg(&data->master->dev, "%s:setting baud rate\n", __func__);
spi-topcliff-pch.c:565:		pch_spi_set_baud_rate(data->master, data->cur_trans->speed_hz);
spi-topcliff-pch.c:569:	if (data->cur_trans->bits_per_word &&
spi-topcliff-pch.c:570:	    (data->current_msg->spi->bits_per_word != data->cur_trans->bits_per_word)) {
spi-topcliff-pch.c:571:		dev_dbg(&data->master->dev, "%s:set bits per word\n", __func__);
spi-topcliff-pch.c:572:		pch_spi_set_bits_per_word(data->master,
spi-topcliff-pch.c:573:					  data->cur_trans->bits_per_word);
spi-topcliff-pch.c:574:		*bpw = data->cur_trans->bits_per_word;
spi-topcliff-pch.c:576:		*bpw = data->current_msg->spi->bits_per_word;
spi-topcliff-pch.c:580:	data->tx_index = 0;
spi-topcliff-pch.c:581:	data->rx_index = 0;
spi-topcliff-pch.c:583:	data->bpw_len = data->cur_trans->len / (*bpw / 8);
spi-topcliff-pch.c:586:	size = data->cur_trans->len * sizeof(*data->pkt_tx_buff);
spi-topcliff-pch.c:589:	data->pkt_tx_buff = kzalloc(size, GFP_KERNEL);
spi-topcliff-pch.c:590:	if (data->pkt_tx_buff != NULL) {
spi-topcliff-pch.c:591:		data->pkt_rx_buff = kzalloc(size, GFP_KERNEL);
spi-topcliff-pch.c:592:		if (!data->pkt_rx_buff)
spi-topcliff-pch.c:593:			kfree(data->pkt_tx_buff);
spi-topcliff-pch.c:596:	if (!data->pkt_rx_buff) {
spi-topcliff-pch.c:597:		/* flush queue and set status of all transfers to -ENOMEM */
spi-topcliff-pch.c:598:		dev_err(&data->master->dev, "%s :kzalloc failed\n", __func__);
spi-topcliff-pch.c:599:		list_for_each_entry_safe(pmsg, tmp, data->queue.next, queue) {
spi-topcliff-pch.c:600:			pmsg->status = -ENOMEM;
spi-topcliff-pch.c:602:			if (pmsg->complete)
spi-topcliff-pch.c:603:				pmsg->complete(pmsg->context);
spi-topcliff-pch.c:606:			list_del_init(&pmsg->queue);
spi-topcliff-pch.c:612:	if (data->cur_trans->tx_buf != NULL) {
spi-topcliff-pch.c:614:			tx_buf = data->cur_trans->tx_buf;
spi-topcliff-pch.c:615:			for (j = 0; j < data->bpw_len; j++)
spi-topcliff-pch.c:616:				data->pkt_tx_buff[j] = *tx_buf++;
spi-topcliff-pch.c:618:			tx_sbuf = data->cur_trans->tx_buf;
spi-topcliff-pch.c:619:			for (j = 0; j < data->bpw_len; j++)
spi-topcliff-pch.c:620:				data->pkt_tx_buff[j] = *tx_sbuf++;
spi-topcliff-pch.c:625:	n_writes = data->bpw_len;
spi-topcliff-pch.c:629:	dev_dbg(&data->master->dev, "\n%s:Pulling down SSN low - writing "
spi-topcliff-pch.c:631:	pch_spi_writereg(data->master, PCH_SSNXCR, SSN_LOW);
spi-topcliff-pch.c:634:		pch_spi_writereg(data->master, PCH_SPDWR, data->pkt_tx_buff[j]);
spi-topcliff-pch.c:637:	data->tx_index = j;
spi-topcliff-pch.c:640:	data->transfer_complete = false;
spi-topcliff-pch.c:641:	data->transfer_active = true;
spi-topcliff-pch.c:647:	dev_dbg(&data->master->dev, "%s called\n", __func__);
spi-topcliff-pch.c:650:	data->current_msg->status = 0;
spi-topcliff-pch.c:652:	if (data->current_msg->complete) {
spi-topcliff-pch.c:653:		dev_dbg(&data->master->dev,
spi-topcliff-pch.c:655:		data->current_msg->complete(data->current_msg->context);
spi-topcliff-pch.c:659:	data->bcurrent_msg_processing = false;
spi-topcliff-pch.c:661:	dev_dbg(&data->master->dev,
spi-topcliff-pch.c:662:		"%s:data->bcurrent_msg_processing = false\n", __func__);
spi-topcliff-pch.c:664:	data->current_msg = NULL;
spi-topcliff-pch.c:665:	data->cur_trans = NULL;
spi-topcliff-pch.c:669:	if ((list_empty(&data->queue) == 0) &&
spi-topcliff-pch.c:670:	    (!data->board_dat->suspend_sts) &&
spi-topcliff-pch.c:671:	    (data->status != STATUS_EXITING)) {
spi-topcliff-pch.c:676:		dev_dbg(&data->master->dev, "%s:Invoke queue_work\n", __func__);
spi-topcliff-pch.c:677:		queue_work(data->wk, &data->work);
spi-topcliff-pch.c:678:	} else if (data->board_dat->suspend_sts ||
spi-topcliff-pch.c:679:		   data->status == STATUS_EXITING) {
spi-topcliff-pch.c:680:		dev_dbg(&data->master->dev,
spi-topcliff-pch.c:683:		list_for_each_entry_safe(pmsg, tmp, data->queue.next, queue) {
spi-topcliff-pch.c:684:			pmsg->status = -EIO;
spi-topcliff-pch.c:686:			if (pmsg->complete)
spi-topcliff-pch.c:687:				pmsg->complete(pmsg->context);
spi-topcliff-pch.c:690:			list_del_init(&pmsg->queue);
spi-topcliff-pch.c:698:	if ((data->bpw_len) > PCH_MAX_FIFO_DEPTH)
spi-topcliff-pch.c:700:		pch_spi_setclr_reg(data->master, PCH_SPCR,
spi-topcliff-pch.c:707:		pch_spi_setclr_reg(data->master, PCH_SPCR,
spi-topcliff-pch.c:715:	dev_dbg(&data->master->dev,
spi-topcliff-pch.c:718:	wait_event_interruptible(data->wait, data->transfer_complete);
spi-topcliff-pch.c:721:	pch_spi_writereg(data->master, PCH_SPSR,
spi-topcliff-pch.c:722:			 pch_spi_readreg(data->master, PCH_SPSR));
spi-topcliff-pch.c:724:	pch_spi_setclr_reg(data->master, PCH_SPCR, 0, PCH_ALL | SPCR_SPE_BIT);
spi-topcliff-pch.c:726:	pch_spi_clear_fifo(data->master);
spi-topcliff-pch.c:736:	if (!data->cur_trans->rx_buf)
spi-topcliff-pch.c:740:		rx_buf = data->cur_trans->rx_buf;
spi-topcliff-pch.c:741:		for (j = 0; j < data->bpw_len; j++)
spi-topcliff-pch.c:742:			*rx_buf++ = data->pkt_rx_buff[j] & 0xFF;
spi-topcliff-pch.c:744:		rx_sbuf = data->cur_trans->rx_buf;
spi-topcliff-pch.c:745:		for (j = 0; j < data->bpw_len; j++)
spi-topcliff-pch.c:746:			*rx_sbuf++ = data->pkt_rx_buff[j];
spi-topcliff-pch.c:759:	if (!data->cur_trans->rx_buf)
spi-topcliff-pch.c:763:		rx_buf = data->cur_trans->rx_buf;
spi-topcliff-pch.c:764:		rx_dma_buf = data->dma.rx_buf_virt;
spi-topcliff-pch.c:765:		for (j = 0; j < data->bpw_len; j++)
spi-topcliff-pch.c:767:		data->cur_trans->rx_buf = rx_buf;
spi-topcliff-pch.c:769:		rx_sbuf = data->cur_trans->rx_buf;
spi-topcliff-pch.c:770:		rx_dma_sbuf = data->dma.rx_buf_virt;
spi-topcliff-pch.c:771:		for (j = 0; j < data->bpw_len; j++)
spi-topcliff-pch.c:773:		data->cur_trans->rx_buf = rx_sbuf;
spi-topcliff-pch.c:783:	dma = &data->dma;
spi-topcliff-pch.c:785:	spin_lock_irqsave(&data->lock, flags);
spi-topcliff-pch.c:788:	pch_spi_setclr_reg(data->master, PCH_SPCR, SPCR_SPE_BIT, PCH_ALL);
spi-topcliff-pch.c:790:	spin_unlock_irqrestore(&data->lock, flags);
spi-topcliff-pch.c:794:	dev_dbg(&data->master->dev,
spi-topcliff-pch.c:796:	rtn = wait_event_interruptible_timeout(data->wait,
spi-topcliff-pch.c:797:					       data->transfer_complete,
spi-topcliff-pch.c:800:		dev_err(&data->master->dev,
spi-topcliff-pch.c:801:			"%s wait-event timeout\n", __func__);
spi-topcliff-pch.c:803:	dma_sync_sg_for_cpu(&data->master->dev, dma->sg_rx_p, dma->nent,
spi-topcliff-pch.c:806:	dma_sync_sg_for_cpu(&data->master->dev, dma->sg_tx_p, dma->nent,
spi-topcliff-pch.c:808:	memset(data->dma.tx_buf_virt, 0, PAGE_SIZE);
spi-topcliff-pch.c:810:	async_tx_ack(dma->desc_rx);
spi-topcliff-pch.c:811:	async_tx_ack(dma->desc_tx);
spi-topcliff-pch.c:812:	kfree(dma->sg_tx_p);
spi-topcliff-pch.c:813:	kfree(dma->sg_rx_p);
spi-topcliff-pch.c:815:	spin_lock_irqsave(&data->lock, flags);
spi-topcliff-pch.c:818:	pch_spi_setclr_reg(data->master, PCH_SPCR, 0,
spi-topcliff-pch.c:822:	pch_spi_writereg(data->master, PCH_SPSR,
spi-topcliff-pch.c:823:			 pch_spi_readreg(data->master, PCH_SPSR));
spi-topcliff-pch.c:825:	pch_spi_clear_fifo(data->master);
spi-topcliff-pch.c:827:	spin_unlock_irqrestore(&data->lock, flags);
spi-topcliff-pch.c:837:	data->transfer_complete = true;
spi-topcliff-pch.c:838:	wake_up_interruptible(&data->wait);
spi-topcliff-pch.c:845:	if ((chan->chan_id == param->chan_id) &&
spi-topcliff-pch.c:846:	    (param->dma_dev == chan->device->dev)) {
spi-topcliff-pch.c:847:		chan->private = param;
spi-topcliff-pch.c:868:	dma = &data->dma;
spi-topcliff-pch.c:873:	dma_dev = pci_get_slot(data->board_dat->pdev->bus,
spi-topcliff-pch.c:874:			PCI_DEVFN(PCI_SLOT(data->board_dat->pdev->devfn), 0));
spi-topcliff-pch.c:877:	param = &dma->param_tx;
spi-topcliff-pch.c:878:	param->dma_dev = &dma_dev->dev;
spi-topcliff-pch.c:879:	param->chan_id = data->ch * 2; /* Tx = 0, 2 */;
spi-topcliff-pch.c:880:	param->tx_reg = data->io_base_addr + PCH_SPDWR;
spi-topcliff-pch.c:881:	param->width = width;
spi-topcliff-pch.c:884:		dev_err(&data->master->dev,
spi-topcliff-pch.c:886:		data->use_dma = 0;
spi-topcliff-pch.c:889:	dma->chan_tx = chan;
spi-topcliff-pch.c:892:	param = &dma->param_rx;
spi-topcliff-pch.c:893:	param->dma_dev = &dma_dev->dev;
spi-topcliff-pch.c:894:	param->chan_id = data->ch * 2 + 1; /* Rx = Tx + 1 */;
spi-topcliff-pch.c:895:	param->rx_reg = data->io_base_addr + PCH_SPDRR;
spi-topcliff-pch.c:896:	param->width = width;
spi-topcliff-pch.c:899:		dev_err(&data->master->dev,
spi-topcliff-pch.c:901:		dma_release_channel(dma->chan_tx);
spi-topcliff-pch.c:902:		dma->chan_tx = NULL;
spi-topcliff-pch.c:903:		data->use_dma = 0;
spi-topcliff-pch.c:906:	dma->chan_rx = chan;
spi-topcliff-pch.c:913:	dma = &data->dma;
spi-topcliff-pch.c:914:	if (dma->chan_tx) {
spi-topcliff-pch.c:915:		dma_release_channel(dma->chan_tx);
spi-topcliff-pch.c:916:		dma->chan_tx = NULL;
spi-topcliff-pch.c:918:	if (dma->chan_rx) {
spi-topcliff-pch.c:919:		dma_release_channel(dma->chan_rx);
spi-topcliff-pch.c:920:		dma->chan_rx = NULL;
spi-topcliff-pch.c:942:	dma = &data->dma;
spi-topcliff-pch.c:945:	if (data->cur_trans->speed_hz) {
spi-topcliff-pch.c:946:		dev_dbg(&data->master->dev, "%s:setting baud rate\n", __func__);
spi-topcliff-pch.c:947:		spin_lock_irqsave(&data->lock, flags);
spi-topcliff-pch.c:948:		pch_spi_set_baud_rate(data->master, data->cur_trans->speed_hz);
spi-topcliff-pch.c:949:		spin_unlock_irqrestore(&data->lock, flags);
spi-topcliff-pch.c:953:	if (data->cur_trans->bits_per_word &&
spi-topcliff-pch.c:954:	    (data->current_msg->spi->bits_per_word !=
spi-topcliff-pch.c:955:	     data->cur_trans->bits_per_word)) {
spi-topcliff-pch.c:956:		dev_dbg(&data->master->dev, "%s:set bits per word\n", __func__);
spi-topcliff-pch.c:957:		spin_lock_irqsave(&data->lock, flags);
spi-topcliff-pch.c:958:		pch_spi_set_bits_per_word(data->master,
spi-topcliff-pch.c:959:					  data->cur_trans->bits_per_word);
spi-topcliff-pch.c:960:		spin_unlock_irqrestore(&data->lock, flags);
spi-topcliff-pch.c:961:		*bpw = data->cur_trans->bits_per_word;
spi-topcliff-pch.c:963:		*bpw = data->current_msg->spi->bits_per_word;
spi-topcliff-pch.c:965:	data->bpw_len = data->cur_trans->len / (*bpw / 8);
spi-topcliff-pch.c:967:	if (data->bpw_len > PCH_BUF_SIZE) {
spi-topcliff-pch.c:968:		data->bpw_len = PCH_BUF_SIZE;
spi-topcliff-pch.c:969:		data->cur_trans->len -= PCH_BUF_SIZE;
spi-topcliff-pch.c:973:	if (data->cur_trans->tx_buf != NULL) {
spi-topcliff-pch.c:975:			tx_buf = data->cur_trans->tx_buf;
spi-topcliff-pch.c:976:			tx_dma_buf = dma->tx_buf_virt;
spi-topcliff-pch.c:977:			for (i = 0; i < data->bpw_len; i++)
spi-topcliff-pch.c:980:			tx_sbuf = data->cur_trans->tx_buf;
spi-topcliff-pch.c:981:			tx_dma_sbuf = dma->tx_buf_virt;
spi-topcliff-pch.c:982:			for (i = 0; i < data->bpw_len; i++)
spi-topcliff-pch.c:988:	if (data->bpw_len > PCH_DMA_TRANS_SIZE) {
spi-topcliff-pch.c:989:		if (data->bpw_len % PCH_DMA_TRANS_SIZE) {
spi-topcliff-pch.c:990:			num = data->bpw_len / PCH_DMA_TRANS_SIZE + 1;
spi-topcliff-pch.c:991:			rem = data->bpw_len % PCH_DMA_TRANS_SIZE;
spi-topcliff-pch.c:993:			num = data->bpw_len / PCH_DMA_TRANS_SIZE;
spi-topcliff-pch.c:999:		size = data->bpw_len;
spi-topcliff-pch.c:1000:		rem = data->bpw_len;
spi-topcliff-pch.c:1002:	dev_dbg(&data->master->dev, "%s num=%d size=%d rem=%d\n",
spi-topcliff-pch.c:1004:	spin_lock_irqsave(&data->lock, flags);
spi-topcliff-pch.c:1007:	pch_spi_setclr_reg(data->master, PCH_SPCR,
spi-topcliff-pch.c:1008:			   ((size - 1) << SPCR_RFIC_FIELD) |
spi-topcliff-pch.c:1012:	spin_unlock_irqrestore(&data->lock, flags);
spi-topcliff-pch.c:1015:	dma->sg_rx_p = kzalloc(sizeof(struct scatterlist)*num, GFP_ATOMIC);
spi-topcliff-pch.c:1016:	sg_init_table(dma->sg_rx_p, num); /* Initialize SG table */
spi-topcliff-pch.c:1018:	sg = dma->sg_rx_p;
spi-topcliff-pch.c:1020:		if (i == (num - 2)) {
spi-topcliff-pch.c:1021:			sg->offset = size * i;
spi-topcliff-pch.c:1022:			sg->offset = sg->offset * (*bpw / 8);
spi-topcliff-pch.c:1023:			sg_set_page(sg, virt_to_page(dma->rx_buf_virt), rem,
spi-topcliff-pch.c:1024:				    sg->offset);
spi-topcliff-pch.c:1026:		} else if (i == (num - 1)) {
spi-topcliff-pch.c:1027:			sg->offset = size * (i - 1) + rem;
spi-topcliff-pch.c:1028:			sg->offset = sg->offset * (*bpw / 8);
spi-topcliff-pch.c:1029:			sg_set_page(sg, virt_to_page(dma->rx_buf_virt), size,
spi-topcliff-pch.c:1030:				    sg->offset);
spi-topcliff-pch.c:1033:			sg->offset = size * i;
spi-topcliff-pch.c:1034:			sg->offset = sg->offset * (*bpw / 8);
spi-topcliff-pch.c:1035:			sg_set_page(sg, virt_to_page(dma->rx_buf_virt), size,
spi-topcliff-pch.c:1036:				    sg->offset);
spi-topcliff-pch.c:1039:		sg_dma_address(sg) = dma->rx_buf_dma + sg->offset;
spi-topcliff-pch.c:1041:	sg = dma->sg_rx_p;
spi-topcliff-pch.c:1042:	desc_rx = dmaengine_prep_slave_sg(dma->chan_rx, sg,
spi-topcliff-pch.c:1046:		dev_err(&data->master->dev,
spi-topcliff-pch.c:1050:	dma_sync_sg_for_device(&data->master->dev, sg, num, DMA_FROM_DEVICE);
spi-topcliff-pch.c:1051:	desc_rx->callback = pch_dma_rx_complete;
spi-topcliff-pch.c:1052:	desc_rx->callback_param = data;
spi-topcliff-pch.c:1053:	dma->nent = num;
spi-topcliff-pch.c:1054:	dma->desc_rx = desc_rx;
spi-topcliff-pch.c:1057:	if (data->bpw_len > PCH_MAX_FIFO_DEPTH) {
spi-topcliff-pch.c:1058:		head = PCH_MAX_FIFO_DEPTH - PCH_DMA_TRANS_SIZE;
spi-topcliff-pch.c:1059:		if (data->bpw_len % PCH_DMA_TRANS_SIZE > 4) {
spi-topcliff-pch.c:1060:			num = data->bpw_len / PCH_DMA_TRANS_SIZE + 1;
spi-topcliff-pch.c:1061:			rem = data->bpw_len % PCH_DMA_TRANS_SIZE - head;
spi-topcliff-pch.c:1063:			num = data->bpw_len / PCH_DMA_TRANS_SIZE;
spi-topcliff-pch.c:1064:			rem = data->bpw_len % PCH_DMA_TRANS_SIZE +
spi-topcliff-pch.c:1065:			      PCH_DMA_TRANS_SIZE - head;
spi-topcliff-pch.c:1070:		size = data->bpw_len;
spi-topcliff-pch.c:1071:		rem = data->bpw_len;
spi-topcliff-pch.c:1075:	dma->sg_tx_p = kzalloc(sizeof(struct scatterlist)*num, GFP_ATOMIC);
spi-topcliff-pch.c:1076:	sg_init_table(dma->sg_tx_p, num); /* Initialize SG table */
spi-topcliff-pch.c:1078:	sg = dma->sg_tx_p;
spi-topcliff-pch.c:1081:			sg->offset = 0;
spi-topcliff-pch.c:1082:			sg_set_page(sg, virt_to_page(dma->tx_buf_virt), size + head,
spi-topcliff-pch.c:1083:				    sg->offset);
spi-topcliff-pch.c:1085:		} else if (i == (num - 1)) {
spi-topcliff-pch.c:1086:			sg->offset = head + size * i;
spi-topcliff-pch.c:1087:			sg->offset = sg->offset * (*bpw / 8);
spi-topcliff-pch.c:1088:			sg_set_page(sg, virt_to_page(dma->tx_buf_virt), rem,
spi-topcliff-pch.c:1089:				    sg->offset);
spi-topcliff-pch.c:1092:			sg->offset = head + size * i;
spi-topcliff-pch.c:1093:			sg->offset = sg->offset * (*bpw / 8);
spi-topcliff-pch.c:1094:			sg_set_page(sg, virt_to_page(dma->tx_buf_virt), size,
spi-topcliff-pch.c:1095:				    sg->offset);
spi-topcliff-pch.c:1098:		sg_dma_address(sg) = dma->tx_buf_dma + sg->offset;
spi-topcliff-pch.c:1100:	sg = dma->sg_tx_p;
spi-topcliff-pch.c:1101:	desc_tx = dmaengine_prep_slave_sg(dma->chan_tx,
spi-topcliff-pch.c:1105:		dev_err(&data->master->dev,
spi-topcliff-pch.c:1109:	dma_sync_sg_for_device(&data->master->dev, sg, num, DMA_TO_DEVICE);
spi-topcliff-pch.c:1110:	desc_tx->callback = NULL;
spi-topcliff-pch.c:1111:	desc_tx->callback_param = data;
spi-topcliff-pch.c:1112:	dma->nent = num;
spi-topcliff-pch.c:1113:	dma->desc_tx = desc_tx;
spi-topcliff-pch.c:1115:	dev_dbg(&data->master->dev, "%s:Pulling down SSN low - writing 0x2 to SSNXCR\n", __func__);
spi-topcliff-pch.c:1117:	spin_lock_irqsave(&data->lock, flags);
spi-topcliff-pch.c:1118:	pch_spi_writereg(data->master, PCH_SSNXCR, SSN_LOW);
spi-topcliff-pch.c:1119:	desc_rx->tx_submit(desc_rx);
spi-topcliff-pch.c:1120:	desc_tx->tx_submit(desc_tx);
spi-topcliff-pch.c:1121:	spin_unlock_irqrestore(&data->lock, flags);
spi-topcliff-pch.c:1124:	data->transfer_complete = false;
spi-topcliff-pch.c:1134:	dev_dbg(&data->master->dev, "%s data initialized\n", __func__);
spi-topcliff-pch.c:1136:	spin_lock(&data->lock);
spi-topcliff-pch.c:1138:	if (data->board_dat->suspend_sts || (data->status == STATUS_EXITING)) {
spi-topcliff-pch.c:1139:		dev_dbg(&data->master->dev,
spi-topcliff-pch.c:1141:		list_for_each_entry_safe(pmsg, tmp, data->queue.next, queue) {
spi-topcliff-pch.c:1142:			pmsg->status = -EIO;
spi-topcliff-pch.c:1144:			if (pmsg->complete) {
spi-topcliff-pch.c:1145:				spin_unlock(&data->lock);
spi-topcliff-pch.c:1146:				pmsg->complete(pmsg->context);
spi-topcliff-pch.c:1147:				spin_lock(&data->lock);
spi-topcliff-pch.c:1151:			list_del_init(&pmsg->queue);
spi-topcliff-pch.c:1154:		spin_unlock(&data->lock);
spi-topcliff-pch.c:1158:	data->bcurrent_msg_processing = true;
spi-topcliff-pch.c:1159:	dev_dbg(&data->master->dev,
spi-topcliff-pch.c:1160:		"%s Set data->bcurrent_msg_processing= true\n", __func__);
spi-topcliff-pch.c:1163:	data->current_msg = list_entry(data->queue.next, struct spi_message,
spi-topcliff-pch.c:1166:	list_del_init(&data->current_msg->queue);
spi-topcliff-pch.c:1168:	data->current_msg->status = 0;
spi-topcliff-pch.c:1170:	pch_spi_select_chip(data, data->current_msg->spi);
spi-topcliff-pch.c:1172:	spin_unlock(&data->lock);
spi-topcliff-pch.c:1174:	if (data->use_dma)
spi-topcliff-pch.c:1176:				    data->current_msg->spi->bits_per_word);
spi-topcliff-pch.c:1177:	pch_spi_writereg(data->master, PCH_SSNXCR, SSN_NO_CONTROL);
spi-topcliff-pch.c:1183:		spin_lock(&data->lock);
spi-topcliff-pch.c:1184:		if (data->cur_trans == NULL) {
spi-topcliff-pch.c:1185:			data->cur_trans =
spi-topcliff-pch.c:1186:				list_entry(data->current_msg->transfers.next,
spi-topcliff-pch.c:1188:			dev_dbg(&data->master->dev, "%s "
spi-topcliff-pch.c:1191:			data->cur_trans =
spi-topcliff-pch.c:1192:				list_entry(data->cur_trans->transfer_list.next,
spi-topcliff-pch.c:1194:			dev_dbg(&data->master->dev, "%s "
spi-topcliff-pch.c:1197:		spin_unlock(&data->lock);
spi-topcliff-pch.c:1199:		if (!data->cur_trans->len)
spi-topcliff-pch.c:1201:		cnt = (data->cur_trans->len - 1) / PCH_BUF_SIZE + 1;
spi-topcliff-pch.c:1202:		data->save_total_len = data->cur_trans->len;
spi-topcliff-pch.c:1203:		if (data->use_dma) {
spi-topcliff-pch.c:1205:			char *save_rx_buf = data->cur_trans->rx_buf;
spi-topcliff-pch.c:1209:					data->transfer_complete = true;
spi-topcliff-pch.c:1210:					data->current_msg->status = -EIO;
spi-topcliff-pch.c:1211:					data->current_msg->complete
spi-topcliff-pch.c:1212:						   (data->current_msg->context);
spi-topcliff-pch.c:1213:					data->bcurrent_msg_processing = false;
spi-topcliff-pch.c:1214:					data->current_msg = NULL;
spi-topcliff-pch.c:1215:					data->cur_trans = NULL;
spi-topcliff-pch.c:1220:			data->cur_trans->rx_buf = save_rx_buf;
spi-topcliff-pch.c:1225:			kfree(data->pkt_rx_buff);
spi-topcliff-pch.c:1226:			data->pkt_rx_buff = NULL;
spi-topcliff-pch.c:1227:			kfree(data->pkt_tx_buff);
spi-topcliff-pch.c:1228:			data->pkt_tx_buff = NULL;
spi-topcliff-pch.c:1231:		data->cur_trans->len = data->save_total_len;
spi-topcliff-pch.c:1232:		data->current_msg->actual_length += data->cur_trans->len;
spi-topcliff-pch.c:1234:		dev_dbg(&data->master->dev,
spi-topcliff-pch.c:1235:			"%s:data->current_msg->actual_length=%d\n",
spi-topcliff-pch.c:1236:			__func__, data->current_msg->actual_length);
spi-topcliff-pch.c:1239:		if (data->cur_trans->delay_usecs) {
spi-topcliff-pch.c:1240:			dev_dbg(&data->master->dev, "%s:"
spi-topcliff-pch.c:1242:				data->cur_trans->delay_usecs);
spi-topcliff-pch.c:1243:			udelay(data->cur_trans->delay_usecs);
spi-topcliff-pch.c:1246:		spin_lock(&data->lock);
spi-topcliff-pch.c:1249:		if ((data->cur_trans->transfer_list.next) ==
spi-topcliff-pch.c:1250:		    &(data->current_msg->transfers)) {
spi-topcliff-pch.c:1254:		spin_unlock(&data->lock);
spi-topcliff-pch.c:1256:	} while (data->cur_trans != NULL);
spi-topcliff-pch.c:1259:	pch_spi_writereg(data->master, PCH_SSNXCR, SSN_HIGH);
spi-topcliff-pch.c:1260:	if (data->use_dma)
spi-topcliff-pch.c:1267:	dev_dbg(&board_dat->pdev->dev, "%s ENTRY\n", __func__);
spi-topcliff-pch.c:1270:	if (data->wk != NULL) {
spi-topcliff-pch.c:1271:		destroy_workqueue(data->wk);
spi-topcliff-pch.c:1272:		data->wk = NULL;
spi-topcliff-pch.c:1273:		dev_dbg(&board_dat->pdev->dev,
spi-topcliff-pch.c:1284:	dev_dbg(&board_dat->pdev->dev, "%s ENTRY\n", __func__);
spi-topcliff-pch.c:1287:	data->wk = create_singlethread_workqueue(KBUILD_MODNAME);
spi-topcliff-pch.c:1288:	if (!data->wk) {
spi-topcliff-pch.c:1289:		dev_err(&board_dat->pdev->dev,
spi-topcliff-pch.c:1291:		retval = -EBUSY;
spi-topcliff-pch.c:1296:	pch_spi_reset(data->master);
spi-topcliff-pch.c:1297:	dev_dbg(&board_dat->pdev->dev,
spi-topcliff-pch.c:1300:	dev_dbg(&board_dat->pdev->dev, "%s data->irq_reg_sts=true\n", __func__);
spi-topcliff-pch.c:1304:		dev_err(&board_dat->pdev->dev,
spi-topcliff-pch.c:1309:	dev_dbg(&board_dat->pdev->dev, "%s Return=%d\n", __func__, retval);
spi-topcliff-pch.c:1319:	dma = &data->dma;
spi-topcliff-pch.c:1320:	if (dma->tx_buf_dma)
spi-topcliff-pch.c:1321:		dma_free_coherent(&board_dat->pdev->dev, PCH_BUF_SIZE,
spi-topcliff-pch.c:1322:				  dma->tx_buf_virt, dma->tx_buf_dma);
spi-topcliff-pch.c:1323:	if (dma->rx_buf_dma)
spi-topcliff-pch.c:1324:		dma_free_coherent(&board_dat->pdev->dev, PCH_BUF_SIZE,
spi-topcliff-pch.c:1325:				  dma->rx_buf_virt, dma->rx_buf_dma);
spi-topcliff-pch.c:1335:	dma = &data->dma;
spi-topcliff-pch.c:1338:	dma->tx_buf_virt = dma_alloc_coherent(&board_dat->pdev->dev,
spi-topcliff-pch.c:1339:				PCH_BUF_SIZE, &dma->tx_buf_dma, GFP_KERNEL);
spi-topcliff-pch.c:1340:	if (!dma->tx_buf_virt)
spi-topcliff-pch.c:1341:		ret = -ENOMEM;
spi-topcliff-pch.c:1344:	dma->rx_buf_virt = dma_alloc_coherent(&board_dat->pdev->dev,
spi-topcliff-pch.c:1345:				PCH_BUF_SIZE, &dma->rx_buf_dma, GFP_KERNEL);
spi-topcliff-pch.c:1346:	if (!dma->rx_buf_virt)
spi-topcliff-pch.c:1347:		ret = -ENOMEM;
spi-topcliff-pch.c:1356:	struct pch_spi_board_data *board_dat = dev_get_platdata(&plat_dev->dev);
spi-topcliff-pch.c:1359:	dev_dbg(&plat_dev->dev, "%s:debug\n", __func__);
spi-topcliff-pch.c:1361:	master = spi_alloc_master(&board_dat->pdev->dev,
spi-topcliff-pch.c:1364:		dev_err(&plat_dev->dev, "spi_alloc_master[%d] failed.\n",
spi-topcliff-pch.c:1365:			plat_dev->id);
spi-topcliff-pch.c:1366:		return -ENOMEM;
spi-topcliff-pch.c:1370:	data->master = master;
spi-topcliff-pch.c:1375:	data->io_base_addr = pci_resource_start(board_dat->pdev, 1) +
spi-topcliff-pch.c:1376:					 PCH_ADDRESS_SIZE * plat_dev->id;
spi-topcliff-pch.c:1377:	data->io_remap_addr = pci_iomap(board_dat->pdev, 1, 0);
spi-topcliff-pch.c:1378:	if (!data->io_remap_addr) {
spi-topcliff-pch.c:1379:		dev_err(&plat_dev->dev, "%s pci_iomap failed\n", __func__);
spi-topcliff-pch.c:1380:		ret = -ENOMEM;
spi-topcliff-pch.c:1383:	data->io_remap_addr += PCH_ADDRESS_SIZE * plat_dev->id;
spi-topcliff-pch.c:1385:	dev_dbg(&plat_dev->dev, "[ch%d] remap_addr=%p\n",
spi-topcliff-pch.c:1386:		plat_dev->id, data->io_remap_addr);
spi-topcliff-pch.c:1389:	master->num_chipselect = PCH_MAX_CS;
spi-topcliff-pch.c:1390:	master->transfer = pch_spi_transfer;
spi-topcliff-pch.c:1391:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;
spi-topcliff-pch.c:1392:	master->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);
spi-topcliff-pch.c:1393:	master->max_speed_hz = PCH_MAX_BAUDRATE;
spi-topcliff-pch.c:1395:	data->board_dat = board_dat;
spi-topcliff-pch.c:1396:	data->plat_dev = plat_dev;
spi-topcliff-pch.c:1397:	data->n_curnt_chip = 255;
spi-topcliff-pch.c:1398:	data->status = STATUS_RUNNING;
spi-topcliff-pch.c:1399:	data->ch = plat_dev->id;
spi-topcliff-pch.c:1400:	data->use_dma = use_dma;
spi-topcliff-pch.c:1402:	INIT_LIST_HEAD(&data->queue);
spi-topcliff-pch.c:1403:	spin_lock_init(&data->lock);
spi-topcliff-pch.c:1404:	INIT_WORK(&data->work, pch_spi_process_messages);
spi-topcliff-pch.c:1405:	init_waitqueue_head(&data->wait);
spi-topcliff-pch.c:1409:		dev_err(&plat_dev->dev, "%s fail(retval=%d)\n", __func__, ret);
spi-topcliff-pch.c:1413:	ret = request_irq(board_dat->pdev->irq, pch_spi_handler,
spi-topcliff-pch.c:1416:		dev_err(&plat_dev->dev,
spi-topcliff-pch.c:1420:	data->irq_reg_sts = true;
spi-topcliff-pch.c:1425:		dev_info(&plat_dev->dev, "Use DMA for data transfers\n");
spi-topcliff-pch.c:1433:		dev_err(&plat_dev->dev,
spi-topcliff-pch.c:1442:	free_irq(board_dat->pdev->irq, data);
spi-topcliff-pch.c:1446:	pci_iounmap(board_dat->pdev, data->io_remap_addr);
spi-topcliff-pch.c:1455:	struct pch_spi_board_data *board_dat = dev_get_platdata(&plat_dev->dev);
spi-topcliff-pch.c:1460:	dev_dbg(&plat_dev->dev, "%s:[ch%d] irq=%d\n",
spi-topcliff-pch.c:1461:		__func__, plat_dev->id, board_dat->pdev->irq);
spi-topcliff-pch.c:1469:	spin_lock_irqsave(&data->lock, flags);
spi-topcliff-pch.c:1470:	data->status = STATUS_EXITING;
spi-topcliff-pch.c:1471:	while ((list_empty(&data->queue) == 0) && --count) {
spi-topcliff-pch.c:1472:		dev_dbg(&board_dat->pdev->dev, "%s :queue not empty\n",
spi-topcliff-pch.c:1474:		spin_unlock_irqrestore(&data->lock, flags);
spi-topcliff-pch.c:1476:		spin_lock_irqsave(&data->lock, flags);
spi-topcliff-pch.c:1478:	spin_unlock_irqrestore(&data->lock, flags);
spi-topcliff-pch.c:1482:	if (data->irq_reg_sts) {
spi-topcliff-pch.c:1484:		pch_spi_setclr_reg(data->master, PCH_SPCR, 0, PCH_ALL);
spi-topcliff-pch.c:1485:		data->irq_reg_sts = false;
spi-topcliff-pch.c:1486:		free_irq(board_dat->pdev->irq, data);
spi-topcliff-pch.c:1489:	pci_iounmap(board_dat->pdev, data->io_remap_addr);
spi-topcliff-pch.c:1490:	spi_unregister_master(data->master);
spi-topcliff-pch.c:1499:	struct pch_spi_board_data *board_dat = dev_get_platdata(&pd_dev->dev);
spi-topcliff-pch.c:1502:	dev_dbg(&pd_dev->dev, "%s ENTRY\n", __func__);
spi-topcliff-pch.c:1505:		dev_err(&pd_dev->dev,
spi-topcliff-pch.c:1507:		return -EFAULT;
spi-topcliff-pch.c:1513:	while ((--count) > 0) {
spi-topcliff-pch.c:1514:		if (!(data->bcurrent_msg_processing))
spi-topcliff-pch.c:1520:	if (data->irq_reg_sts) {
spi-topcliff-pch.c:1522:		pch_spi_setclr_reg(data->master, PCH_SPCR, 0, PCH_ALL);
spi-topcliff-pch.c:1523:		pch_spi_reset(data->master);
spi-topcliff-pch.c:1524:		free_irq(board_dat->pdev->irq, data);
spi-topcliff-pch.c:1526:		data->irq_reg_sts = false;
spi-topcliff-pch.c:1527:		dev_dbg(&pd_dev->dev,
spi-topcliff-pch.c:1536:	struct pch_spi_board_data *board_dat = dev_get_platdata(&pd_dev->dev);
spi-topcliff-pch.c:1541:		dev_err(&pd_dev->dev,
spi-topcliff-pch.c:1543:		return -EFAULT;
spi-topcliff-pch.c:1546:	if (!data->irq_reg_sts) {
spi-topcliff-pch.c:1548:		retval = request_irq(board_dat->pdev->irq, pch_spi_handler,
spi-topcliff-pch.c:1551:			dev_err(&pd_dev->dev,
spi-topcliff-pch.c:1557:		pch_spi_reset(data->master);
spi-topcliff-pch.c:1558:		pch_spi_set_master_mode(data->master);
spi-topcliff-pch.c:1559:		data->irq_reg_sts = true;
spi-topcliff-pch.c:1570:		.name = "pch-spi",
spi-topcliff-pch.c:1588:		return -ENOMEM;
spi-topcliff-pch.c:1592:		retval = -ENOMEM;
spi-topcliff-pch.c:1598:		dev_err(&pdev->dev, "%s request_region failed\n", __func__);
spi-topcliff-pch.c:1602:	board_dat->pdev = pdev;
spi-topcliff-pch.c:1603:	board_dat->num = id->driver_data;
spi-topcliff-pch.c:1604:	pd_dev_save->num = id->driver_data;
spi-topcliff-pch.c:1605:	pd_dev_save->board_dat = board_dat;
spi-topcliff-pch.c:1609:		dev_err(&pdev->dev, "%s pci_enable_device failed\n", __func__);
spi-topcliff-pch.c:1613:	for (i = 0; i < board_dat->num; i++) {
spi-topcliff-pch.c:1614:		pd_dev = platform_device_alloc("pch-spi", i);
spi-topcliff-pch.c:1616:			dev_err(&pdev->dev, "platform_device_alloc failed\n");
spi-topcliff-pch.c:1617:			retval = -ENOMEM;
spi-topcliff-pch.c:1620:		pd_dev_save->pd_save[i] = pd_dev;
spi-topcliff-pch.c:1621:		pd_dev->dev.parent = &pdev->dev;
spi-topcliff-pch.c:1626:			dev_err(&pdev->dev,
spi-topcliff-pch.c:1634:			dev_err(&pdev->dev, "platform_device_add failed\n");
spi-topcliff-pch.c:1645:	while (--i >= 0)
spi-topcliff-pch.c:1646:		platform_device_unregister(pd_dev_save->pd_save[i]);
spi-topcliff-pch.c:1663:	dev_dbg(&pdev->dev, "%s ENTRY:pdev=%p\n", __func__, pdev);
spi-topcliff-pch.c:1665:	for (i = 0; i < pd_dev_save->num; i++)
spi-topcliff-pch.c:1666:		platform_device_unregister(pd_dev_save->pd_save[i]);
spi-topcliff-pch.c:1670:	kfree(pd_dev_save->board_dat);
spi-topcliff-pch.c:1680:	dev_dbg(&pdev->dev, "%s ENTRY\n", __func__);
spi-topcliff-pch.c:1682:	pd_dev_save->board_dat->suspend_sts = true;
spi-topcliff-pch.c:1691:		dev_err(&pdev->dev, "%s pci_save_state failed\n", __func__);
spi-topcliff-pch.c:1701:	dev_dbg(&pdev->dev, "%s ENTRY\n", __func__);
spi-topcliff-pch.c:1708:		dev_err(&pdev->dev,
spi-topcliff-pch.c:1714:		pd_dev_save->board_dat->suspend_sts = false;
spi-omap-100k.c:62:#define SPI_CTRL_WORD_SIZE(x)           (((x) - 1) << 2)
spi-omap-100k.c:96:	val = readw(spi100k->base + SPI_SETUP1);
spi-omap-100k.c:98:	writew(val, spi100k->base + SPI_SETUP1);
spi-omap-100k.c:107:	val = readw(spi100k->base + SPI_SETUP1);
spi-omap-100k.c:109:	writew(val, spi100k->base + SPI_SETUP1);
spi-omap-100k.c:116:	/* write 16-bit word, shifting 8-bit data if necessary */
spi-omap-100k.c:123:	writew(data , spi100k->base + SPI_TX_MSB);
spi-omap-100k.c:128:	       spi100k->base + SPI_CTRL);
spi-omap-100k.c:131:	while ((readw(spi100k->base + SPI_STATUS) & SPI_STATUS_WE) != SPI_STATUS_WE)
spi-omap-100k.c:151:	       spi100k->base + SPI_CTRL);
spi-omap-100k.c:153:	while ((readw(spi100k->base + SPI_STATUS) & SPI_STATUS_RD) != SPI_STATUS_RD)
spi-omap-100k.c:157:	dataL = readw(spi100k->base + SPI_RX_LSB);
spi-omap-100k.c:158:	dataH = readw(spi100k->base + SPI_RX_MSB);
spi-omap-100k.c:171:	       SPI_SETUP1_CLOCK_DIVISOR(0), spi100k->base + SPI_SETUP1);
spi-omap-100k.c:176:	       SPI_SETUP2_LEVEL_TRIGGER, spi100k->base + SPI_SETUP2);
spi-omap-100k.c:182:		writew(0x05fc, spi100k->base + SPI_CTRL);
spi-omap-100k.c:184:		writew(0x05fd, spi100k->base + SPI_CTRL);
spi-omap-100k.c:190:	struct omap1_spi100k_cs *cs = spi->controller_state;
spi-omap-100k.c:194:	count = xfer->len;
spi-omap-100k.c:196:	word_len = cs->word_len;
spi-omap-100k.c:202:		rx = xfer->rx_buf;
spi-omap-100k.c:203:		tx = xfer->tx_buf;
spi-omap-100k.c:205:			c -= 1;
spi-omap-100k.c:206:			if (xfer->tx_buf != NULL)
spi-omap-100k.c:207:				spi100k_write_data(spi->master, word_len, *tx++);
spi-omap-100k.c:208:			if (xfer->rx_buf != NULL)
spi-omap-100k.c:209:				*rx++ = spi100k_read_data(spi->master, word_len);
spi-omap-100k.c:215:		rx = xfer->rx_buf;
spi-omap-100k.c:216:		tx = xfer->tx_buf;
spi-omap-100k.c:218:			c -= 2;
spi-omap-100k.c:219:			if (xfer->tx_buf != NULL)
spi-omap-100k.c:220:				spi100k_write_data(spi->master, word_len, *tx++);
spi-omap-100k.c:221:			if (xfer->rx_buf != NULL)
spi-omap-100k.c:222:				*rx++ = spi100k_read_data(spi->master, word_len);
spi-omap-100k.c:228:		rx = xfer->rx_buf;
spi-omap-100k.c:229:		tx = xfer->tx_buf;
spi-omap-100k.c:231:			c -= 4;
spi-omap-100k.c:232:			if (xfer->tx_buf != NULL)
spi-omap-100k.c:233:				spi100k_write_data(spi->master, word_len, *tx);
spi-omap-100k.c:234:			if (xfer->rx_buf != NULL)
spi-omap-100k.c:235:				*rx = spi100k_read_data(spi->master, word_len);
spi-omap-100k.c:238:	return count - c;
spi-omap-100k.c:245:	struct omap1_spi100k *spi100k = spi_master_get_devdata(spi->master);
spi-omap-100k.c:246:	struct omap1_spi100k_cs *cs = spi->controller_state;
spi-omap-100k.c:250:		word_len = t->bits_per_word;
spi-omap-100k.c:252:		word_len = spi->bits_per_word;
spi-omap-100k.c:254:	if (spi->bits_per_word > 32)
spi-omap-100k.c:255:		return -EINVAL;
spi-omap-100k.c:256:	cs->word_len = word_len;
spi-omap-100k.c:259:	writew(0x3e , spi100k->base + SPI_SETUP1);
spi-omap-100k.c:260:	writew(0x00 , spi100k->base + SPI_STATUS);
spi-omap-100k.c:261:	writew(0x3e , spi100k->base + SPI_CTRL);
spi-omap-100k.c:266:/* the spi->mode bits understood by this driver: */
spi-omap-100k.c:273:	struct omap1_spi100k_cs *cs = spi->controller_state;
spi-omap-100k.c:275:	spi100k = spi_master_get_devdata(spi->master);
spi-omap-100k.c:278:		cs = devm_kzalloc(&spi->dev, sizeof(*cs), GFP_KERNEL);
spi-omap-100k.c:280:			return -ENOMEM;
spi-omap-100k.c:281:		cs->base = spi100k->base + spi->chip_select * 0x14;
spi-omap-100k.c:282:		spi->controller_state = cs;
spi-omap-100k.c:285:	spi100k_open(spi->master);
spi-omap-100k.c:287:	clk_prepare_enable(spi100k->ick);
spi-omap-100k.c:288:	clk_prepare_enable(spi100k->fck);
spi-omap-100k.c:292:	clk_disable_unprepare(spi100k->ick);
spi-omap-100k.c:293:	clk_disable_unprepare(spi100k->fck);
spi-omap-100k.c:302:	struct spi_device *spi = m->spi;
spi-omap-100k.c:307:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-omap-100k.c:308:		if (t->tx_buf == NULL && t->rx_buf == NULL && t->len) {
spi-omap-100k.c:309:			status = -EINVAL;
spi-omap-100k.c:321:		if (t->len) {
spi-omap-100k.c:325:			m->actual_length += count;
spi-omap-100k.c:327:			if (count != t->len) {
spi-omap-100k.c:328:				status = -EIO;
spi-omap-100k.c:333:		if (t->delay_usecs)
spi-omap-100k.c:334:			udelay(t->delay_usecs);
spi-omap-100k.c:338:		if (t->cs_change) {
spi-omap-100k.c:349:	m->status = status;
spi-omap-100k.c:362:	if (!pdev->id)
spi-omap-100k.c:363:		return -EINVAL;
spi-omap-100k.c:365:	master = spi_alloc_master(&pdev->dev, sizeof(*spi100k));
spi-omap-100k.c:367:		dev_dbg(&pdev->dev, "master allocation failed\n");
spi-omap-100k.c:368:		return -ENOMEM;
spi-omap-100k.c:371:	if (pdev->id != -1)
spi-omap-100k.c:372:		master->bus_num = pdev->id;
spi-omap-100k.c:374:	master->setup = omap1_spi100k_setup;
spi-omap-100k.c:375:	master->transfer_one_message = omap1_spi100k_transfer_one_message;
spi-omap-100k.c:376:	master->num_chipselect = 2;
spi-omap-100k.c:377:	master->mode_bits = MODEBITS;
spi-omap-100k.c:378:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);
spi-omap-100k.c:379:	master->min_speed_hz = OMAP1_SPI100K_MAX_FREQ/(1<<16);
spi-omap-100k.c:380:	master->max_speed_hz = OMAP1_SPI100K_MAX_FREQ;
spi-omap-100k.c:381:	master->auto_runtime_pm = true;
spi-omap-100k.c:390:	spi100k->base = (void __iomem *)dev_get_platdata(&pdev->dev);
spi-omap-100k.c:392:	spi100k->ick = devm_clk_get(&pdev->dev, "ick");
spi-omap-100k.c:393:	if (IS_ERR(spi100k->ick)) {
spi-omap-100k.c:394:		dev_dbg(&pdev->dev, "can't get spi100k_ick\n");
spi-omap-100k.c:395:		status = PTR_ERR(spi100k->ick);
spi-omap-100k.c:399:	spi100k->fck = devm_clk_get(&pdev->dev, "fck");
spi-omap-100k.c:400:	if (IS_ERR(spi100k->fck)) {
spi-omap-100k.c:401:		dev_dbg(&pdev->dev, "can't get spi100k_fck\n");
spi-omap-100k.c:402:		status = PTR_ERR(spi100k->fck);
spi-omap-100k.c:406:	status = clk_prepare_enable(spi100k->ick);
spi-omap-100k.c:408:		dev_err(&pdev->dev, "failed to enable ick: %d\n", status);
spi-omap-100k.c:412:	status = clk_prepare_enable(spi100k->fck);
spi-omap-100k.c:414:		dev_err(&pdev->dev, "failed to enable fck: %d\n", status);
spi-omap-100k.c:418:	pm_runtime_enable(&pdev->dev);
spi-omap-100k.c:419:	pm_runtime_set_active(&pdev->dev);
spi-omap-100k.c:421:	status = devm_spi_register_master(&pdev->dev, master);
spi-omap-100k.c:428:	clk_disable_unprepare(spi100k->fck);
spi-omap-100k.c:430:	clk_disable_unprepare(spi100k->ick);
spi-omap-100k.c:441:	pm_runtime_disable(&pdev->dev);
spi-omap-100k.c:443:	clk_disable_unprepare(spi100k->fck);
spi-omap-100k.c:444:	clk_disable_unprepare(spi100k->ick);
spi-omap-100k.c:455:	clk_disable_unprepare(spi100k->ick);
spi-omap-100k.c:456:	clk_disable_unprepare(spi100k->fck);
spi-omap-100k.c:467:	ret = clk_prepare_enable(spi100k->ick);
spi-omap-100k.c:473:	ret = clk_prepare_enable(spi100k->fck);
spi-omap-100k.c:476:		clk_disable_unprepare(spi100k->ick);
spidev.c:5: *	Andrea Paterniani <a.paterniani@swapp-eng.it>
spidev.c:62: *  - CS_HIGH ... this device will be active when it shouldn't be
spidev.c:63: *  - 3WIRE ... when active, it won't behave as it should
spidev.c:64: *  - NO_CS ... there will be no explicit message boundaries; this
spidev.c:66: *  - READY ... transfers may proceed when they shouldn't.
spidev.c:96:/*-------------------------------------------------------------------------*/
spidev.c:105:	spin_lock_irq(&spidev->spi_lock);
spidev.c:106:	spi = spidev->spi;
spidev.c:107:	spin_unlock_irq(&spidev->spi_lock);
spidev.c:110:		status = -ESHUTDOWN;
spidev.c:115:		status = message->actual_length;
spidev.c:124:			.tx_buf		= spidev->tx_buffer,
spidev.c:126:			.speed_hz	= spidev->speed_hz,
spidev.c:139:			.rx_buf		= spidev->rx_buffer,
spidev.c:141:			.speed_hz	= spidev->speed_hz,
spidev.c:150:/*-------------------------------------------------------------------------*/
spidev.c:152:/* Read-only message with current device setup */
spidev.c:161:		return -EMSGSIZE;
spidev.c:163:	spidev = filp->private_data;
spidev.c:165:	mutex_lock(&spidev->buf_lock);
spidev.c:170:		missing = copy_to_user(buf, spidev->rx_buffer, status);
spidev.c:172:			status = -EFAULT;
spidev.c:174:			status = status - missing;
spidev.c:176:	mutex_unlock(&spidev->buf_lock);
spidev.c:181:/* Write-only message with current device setup */
spidev.c:192:		return -EMSGSIZE;
spidev.c:194:	spidev = filp->private_data;
spidev.c:196:	mutex_lock(&spidev->buf_lock);
spidev.c:197:	missing = copy_from_user(spidev->tx_buffer, buf, count);
spidev.c:201:		status = -EFAULT;
spidev.c:202:	mutex_unlock(&spidev->buf_lock);
spidev.c:216:	int			status = -EFAULT;
spidev.c:221:		return -ENOMEM;
spidev.c:224:	 * We walk the array of user-provided transfers, using each one
spidev.c:227:	tx_buf = spidev->tx_buffer;
spidev.c:228:	rx_buf = spidev->rx_buffer;
spidev.c:234:			n--, k_tmp++, u_tmp++) {
spidev.c:235:		k_tmp->len = u_tmp->len;
spidev.c:237:		total += k_tmp->len;
spidev.c:243:		if (total > INT_MAX || k_tmp->len > INT_MAX) {
spidev.c:244:			status = -EMSGSIZE;
spidev.c:248:		if (u_tmp->rx_buf) {
spidev.c:250:			rx_total += k_tmp->len;
spidev.c:252:				status = -EMSGSIZE;
spidev.c:255:			k_tmp->rx_buf = rx_buf;
spidev.c:257:						(uintptr_t) u_tmp->rx_buf,
spidev.c:258:						u_tmp->len))
spidev.c:260:			rx_buf += k_tmp->len;
spidev.c:262:		if (u_tmp->tx_buf) {
spidev.c:264:			tx_total += k_tmp->len;
spidev.c:266:				status = -EMSGSIZE;
spidev.c:269:			k_tmp->tx_buf = tx_buf;
spidev.c:271:						(uintptr_t) u_tmp->tx_buf,
spidev.c:272:					u_tmp->len))
spidev.c:274:			tx_buf += k_tmp->len;
spidev.c:277:		k_tmp->cs_change = !!u_tmp->cs_change;
spidev.c:278:		k_tmp->tx_nbits = u_tmp->tx_nbits;
spidev.c:279:		k_tmp->rx_nbits = u_tmp->rx_nbits;
spidev.c:280:		k_tmp->bits_per_word = u_tmp->bits_per_word;
spidev.c:281:		k_tmp->delay_usecs = u_tmp->delay_usecs;
spidev.c:282:		k_tmp->speed_hz = u_tmp->speed_hz;
spidev.c:283:		if (!k_tmp->speed_hz)
spidev.c:284:			k_tmp->speed_hz = spidev->speed_hz;
spidev.c:286:		dev_dbg(&spidev->spi->dev,
spidev.c:288:			u_tmp->len,
spidev.c:289:			u_tmp->rx_buf ? "rx " : "",
spidev.c:290:			u_tmp->tx_buf ? "tx " : "",
spidev.c:291:			u_tmp->cs_change ? "cs " : "",
spidev.c:292:			u_tmp->bits_per_word ? : spidev->spi->bits_per_word,
spidev.c:293:			u_tmp->delay_usecs,
spidev.c:294:			u_tmp->speed_hz ? : spidev->spi->max_speed_hz);
spidev.c:304:	rx_buf = spidev->rx_buffer;
spidev.c:305:	for (n = n_xfers, u_tmp = u_xfers; n; n--, u_tmp++) {
spidev.c:306:		if (u_tmp->rx_buf) {
spidev.c:308:					(uintptr_t) u_tmp->rx_buf, rx_buf,
spidev.c:309:					u_tmp->len)) {
spidev.c:310:				status = -EFAULT;
spidev.c:313:			rx_buf += u_tmp->len;
spidev.c:334:		return ERR_PTR(-ENOTTY);
spidev.c:338:		return ERR_PTR(-EINVAL);
spidev.c:346:		return ERR_PTR(-ENOMEM);
spidev.c:349:		return ERR_PTR(-EFAULT);
spidev.c:367:		return -ENOTTY;
spidev.c:380:		return -EFAULT;
spidev.c:385:	spidev = filp->private_data;
spidev.c:386:	spin_lock_irq(&spidev->spi_lock);
spidev.c:387:	spi = spi_dev_get(spidev->spi);
spidev.c:388:	spin_unlock_irq(&spidev->spi_lock);
spidev.c:391:		return -ESHUTDOWN;
spidev.c:394:	 *  - prevent I/O (from us) so calling spi_setup() is safe;
spidev.c:395:	 *  - prevent concurrent SPI_IOC_WR_* from morphing
spidev.c:397:	 *  - SPI_IOC_MESSAGE needs the buffer locked "normally".
spidev.c:399:	mutex_lock(&spidev->buf_lock);
spidev.c:404:		retval = __put_user(spi->mode & SPI_MODE_MASK,
spidev.c:408:		retval = __put_user(spi->mode & SPI_MODE_MASK,
spidev.c:412:		retval = __put_user((spi->mode & SPI_LSB_FIRST) ?  1 : 0,
spidev.c:416:		retval = __put_user(spi->bits_per_word, (__u8 __user *)arg);
spidev.c:419:		retval = __put_user(spidev->speed_hz, (__u32 __user *)arg);
spidev.c:430:			u32	save = spi->mode;
spidev.c:433:				retval = -EINVAL;
spidev.c:437:			tmp |= spi->mode & ~SPI_MODE_MASK;
spidev.c:438:			spi->mode = (u16)tmp;
spidev.c:441:				spi->mode = save;
spidev.c:443:				dev_dbg(&spi->dev, "spi mode %x\n", tmp);
spidev.c:449:			u32	save = spi->mode;
spidev.c:452:				spi->mode |= SPI_LSB_FIRST;
spidev.c:454:				spi->mode &= ~SPI_LSB_FIRST;
spidev.c:457:				spi->mode = save;
spidev.c:459:				dev_dbg(&spi->dev, "%csb first\n",
spidev.c:466:			u8	save = spi->bits_per_word;
spidev.c:468:			spi->bits_per_word = tmp;
spidev.c:471:				spi->bits_per_word = save;
spidev.c:473:				dev_dbg(&spi->dev, "%d bits per word\n", tmp);
spidev.c:479:			u32	save = spi->max_speed_hz;
spidev.c:481:			spi->max_speed_hz = tmp;
spidev.c:484:				spidev->speed_hz = tmp;
spidev.c:486:				dev_dbg(&spi->dev, "%d Hz (max)\n", tmp);
spidev.c:487:			spi->max_speed_hz = save;
spidev.c:492:		/* segmented and/or full-duplex I/O request */
spidev.c:509:	mutex_unlock(&spidev->buf_lock);
spidev.c:528:		return -EFAULT;
spidev.c:533:	spidev = filp->private_data;
spidev.c:534:	spin_lock_irq(&spidev->spi_lock);
spidev.c:535:	spi = spi_dev_get(spidev->spi);
spidev.c:536:	spin_unlock_irq(&spidev->spi_lock);
spidev.c:539:		return -ESHUTDOWN;
spidev.c:542:	mutex_lock(&spidev->buf_lock);
spidev.c:564:	mutex_unlock(&spidev->buf_lock);
spidev.c:586:	int			status = -ENXIO;
spidev.c:591:		if (spidev->devt == inode->i_rdev) {
spidev.c:602:	if (!spidev->tx_buffer) {
spidev.c:603:		spidev->tx_buffer = kmalloc(bufsiz, GFP_KERNEL);
spidev.c:604:		if (!spidev->tx_buffer) {
spidev.c:605:			dev_dbg(&spidev->spi->dev, "open/ENOMEM\n");
spidev.c:606:			status = -ENOMEM;
spidev.c:611:	if (!spidev->rx_buffer) {
spidev.c:612:		spidev->rx_buffer = kmalloc(bufsiz, GFP_KERNEL);
spidev.c:613:		if (!spidev->rx_buffer) {
spidev.c:614:			dev_dbg(&spidev->spi->dev, "open/ENOMEM\n");
spidev.c:615:			status = -ENOMEM;
spidev.c:620:	spidev->users++;
spidev.c:621:	filp->private_data = spidev;
spidev.c:628:	kfree(spidev->tx_buffer);
spidev.c:629:	spidev->tx_buffer = NULL;
spidev.c:640:	spidev = filp->private_data;
spidev.c:641:	filp->private_data = NULL;
spidev.c:644:	spidev->users--;
spidev.c:645:	if (!spidev->users) {
spidev.c:648:		kfree(spidev->tx_buffer);
spidev.c:649:		spidev->tx_buffer = NULL;
spidev.c:651:		kfree(spidev->rx_buffer);
spidev.c:652:		spidev->rx_buffer = NULL;
spidev.c:654:		spin_lock_irq(&spidev->spi_lock);
spidev.c:655:		if (spidev->spi)
spidev.c:656:			spidev->speed_hz = spidev->spi->max_speed_hz;
spidev.c:659:		dofree = (spidev->spi == NULL);
spidev.c:660:		spin_unlock_irq(&spidev->spi_lock);
spidev.c:685:/*-------------------------------------------------------------------------*/
spidev.c:703:/*-------------------------------------------------------------------------*/
spidev.c:716:	if (spi->dev.of_node && !of_match_device(spidev_dt_ids, &spi->dev)) {
spidev.c:717:		dev_err(&spi->dev, "buggy DT: spidev listed directly in DT\n");
spidev.c:718:		WARN_ON(spi->dev.of_node &&
spidev.c:719:			!of_match_device(spidev_dt_ids, &spi->dev));
spidev.c:725:		return -ENOMEM;
spidev.c:728:	spidev->spi = spi;
spidev.c:729:	spin_lock_init(&spidev->spi_lock);
spidev.c:730:	mutex_init(&spidev->buf_lock);
spidev.c:732:	INIT_LIST_HEAD(&spidev->device_entry);
spidev.c:742:		spidev->devt = MKDEV(SPIDEV_MAJOR, minor);
spidev.c:743:		dev = device_create(spidev_class, &spi->dev, spidev->devt,
spidev.c:745:				    spi->master->bus_num, spi->chip_select);
spidev.c:748:		dev_dbg(&spi->dev, "no minor number available!\n");
spidev.c:749:		status = -ENODEV;
spidev.c:753:		list_add(&spidev->device_entry, &device_list);
spidev.c:757:	spidev->speed_hz = spi->max_speed_hz;
spidev.c:772:	spin_lock_irq(&spidev->spi_lock);
spidev.c:773:	spidev->spi = NULL;
spidev.c:774:	spin_unlock_irq(&spidev->spi_lock);
spidev.c:778:	list_del(&spidev->device_entry);
spidev.c:779:	device_destroy(spidev_class, spidev->devt);
spidev.c:780:	clear_bit(MINOR(spidev->devt), minors);
spidev.c:781:	if (spidev->users == 0)
spidev.c:803:/*-------------------------------------------------------------------------*/
spidev.c:841:MODULE_AUTHOR("Andrea Paterniani, <a.paterniani@swapp-eng.it>");
spi-fsl-espi.c:27:#include "spi-fsl-lib.h"
spi-fsl-espi.c:31:	__be32 mode;		/* 0x000 - eSPI mode register */
spi-fsl-espi.c:32:	__be32 event;		/* 0x004 - eSPI event register */
spi-fsl-espi.c:33:	__be32 mask;		/* 0x008 - eSPI mask register */
spi-fsl-espi.c:34:	__be32 command;		/* 0x00c - eSPI command register */
spi-fsl-espi.c:35:	__be32 transmit;	/* 0x010 - eSPI transmit FIFO access register*/
spi-fsl-espi.c:36:	__be32 receive;		/* 0x014 - eSPI receive FIFO access register*/
spi-fsl-espi.c:37:	u8 res[8];		/* 0x018 - 0x01c reserved */
spi-fsl-espi.c:38:	__be32 csmode[4];	/* 0x020 - 0x02c eSPI cs mode register */
spi-fsl-espi.c:93:	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
spi-fsl-espi.c:94:	struct spi_mpc8xxx_cs *cs = spi->controller_state;
spi-fsl-espi.c:95:	struct fsl_espi_reg *reg_base = mspi->reg_base;
spi-fsl-espi.c:96:	__be32 __iomem *mode = &reg_base->csmode[spi->chip_select];
spi-fsl-espi.c:97:	__be32 __iomem *espi_mode = &reg_base->mode;
spi-fsl-espi.c:107:	mpc8xxx_spi_write_reg(mode, cs->hw_mode);
spi-fsl-espi.c:118:	const u32 *tx = mpc8xxx_spi->tx;
spi-fsl-espi.c:123:	data = *tx++ << mpc8xxx_spi->tx_shift;
spi-fsl-espi.c:130:	mpc8xxx_spi->tx = tx;
spi-fsl-espi.c:137:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
spi-fsl-espi.c:141:	struct spi_mpc8xxx_cs *cs = spi->controller_state;
spi-fsl-espi.c:144:		bits_per_word = t->bits_per_word;
spi-fsl-espi.c:145:		hz = t->speed_hz;
spi-fsl-espi.c:148:	/* spi_transfer level calls that work per-word */
spi-fsl-espi.c:150:		bits_per_word = spi->bits_per_word;
spi-fsl-espi.c:153:		hz = spi->max_speed_hz;
spi-fsl-espi.c:155:	cs->rx_shift = 0;
spi-fsl-espi.c:156:	cs->tx_shift = 0;
spi-fsl-espi.c:157:	cs->get_rx = mpc8xxx_spi_rx_buf_u32;
spi-fsl-espi.c:158:	cs->get_tx = mpc8xxx_spi_tx_buf_u32;
spi-fsl-espi.c:160:		cs->rx_shift = 8 - bits_per_word;
spi-fsl-espi.c:162:		cs->rx_shift = 16 - bits_per_word;
spi-fsl-espi.c:163:		if (spi->mode & SPI_LSB_FIRST)
spi-fsl-espi.c:164:			cs->get_tx = fsl_espi_tx_buf_lsb;
spi-fsl-espi.c:167:	mpc8xxx_spi->rx_shift = cs->rx_shift;
spi-fsl-espi.c:168:	mpc8xxx_spi->tx_shift = cs->tx_shift;
spi-fsl-espi.c:169:	mpc8xxx_spi->get_rx = cs->get_rx;
spi-fsl-espi.c:170:	mpc8xxx_spi->get_tx = cs->get_tx;
spi-fsl-espi.c:172:	bits_per_word = bits_per_word - 1;
spi-fsl-espi.c:175:	cs->hw_mode &= ~(CSMODE_LEN(0xF) | CSMODE_DIV16 | CSMODE_PM(0xF));
spi-fsl-espi.c:177:	cs->hw_mode |= CSMODE_LEN(bits_per_word);
spi-fsl-espi.c:179:	if ((mpc8xxx_spi->spibrg / hz) > 64) {
spi-fsl-espi.c:180:		cs->hw_mode |= CSMODE_DIV16;
spi-fsl-espi.c:181:		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 16 * 4);
spi-fsl-espi.c:184:			  "Will use %d Hz instead.\n", dev_name(&spi->dev),
spi-fsl-espi.c:185:				hz, mpc8xxx_spi->spibrg / (4 * 16 * (32 + 1)));
spi-fsl-espi.c:189:		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 4);
spi-fsl-espi.c:192:		pm--;
spi-fsl-espi.c:196:	cs->hw_mode |= CSMODE_PM(pm);
spi-fsl-espi.c:206:	struct fsl_espi_reg *reg_base = mspi->reg_base;
spi-fsl-espi.c:208:	mspi->count = len;
spi-fsl-espi.c:211:	mpc8xxx_spi_write_reg(&reg_base->mask, SPIM_NE);
spi-fsl-espi.c:214:	word = mspi->get_tx(mspi);
spi-fsl-espi.c:215:	mpc8xxx_spi_write_reg(&reg_base->transmit, word);
spi-fsl-espi.c:222:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
spi-fsl-espi.c:223:	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
spi-fsl-espi.c:224:	unsigned int len = t->len;
spi-fsl-espi.c:227:	mpc8xxx_spi->len = t->len;
spi-fsl-espi.c:230:	mpc8xxx_spi->tx = t->tx_buf;
spi-fsl-espi.c:231:	mpc8xxx_spi->rx = t->rx_buf;
spi-fsl-espi.c:233:	reinit_completion(&mpc8xxx_spi->done);
spi-fsl-espi.c:236:	if ((t->len - 1) > SPCOM_TRANLEN_MAX) {
spi-fsl-espi.c:237:		dev_err(mpc8xxx_spi->dev, "Transaction length (%d)"
spi-fsl-espi.c:238:				" beyond the SPCOM[TRANLEN] field\n", t->len);
spi-fsl-espi.c:239:		return -EINVAL;
spi-fsl-espi.c:241:	mpc8xxx_spi_write_reg(&reg_base->command,
spi-fsl-espi.c:242:		(SPCOM_CS(spi->chip_select) | SPCOM_TRANLEN(t->len - 1)));
spi-fsl-espi.c:248:	wait_for_completion(&mpc8xxx_spi->done);
spi-fsl-espi.c:251:	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
spi-fsl-espi.c:253:	return mpc8xxx_spi->count;
spi-fsl-espi.c:276:	struct spi_device *spi = m->spi;
spi-fsl-espi.c:277:	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
spi-fsl-espi.c:286:	first = list_first_entry(&m->transfers, struct spi_transfer,
spi-fsl-espi.c:288:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-fsl-espi.c:289:		if ((first->bits_per_word != t->bits_per_word) ||
spi-fsl-espi.c:290:			(first->speed_hz != t->speed_hz)) {
spi-fsl-espi.c:291:			espi_trans->status = -EINVAL;
spi-fsl-espi.c:292:			dev_err(mspi->dev,
spi-fsl-espi.c:297:		trans.speed_hz = t->speed_hz;
spi-fsl-espi.c:298:		trans.bits_per_word = t->bits_per_word;
spi-fsl-espi.c:299:		trans.delay_usecs = max(first->delay_usecs, t->delay_usecs);
spi-fsl-espi.c:302:	trans.len = espi_trans->len;
spi-fsl-espi.c:303:	trans.tx_buf = espi_trans->tx_buf;
spi-fsl-espi.c:304:	trans.rx_buf = espi_trans->rx_buf;
spi-fsl-espi.c:308:		if (t->bits_per_word || t->speed_hz) {
spi-fsl-espi.c:309:			status = -EINVAL;
spi-fsl-espi.c:316:		if (t->len)
spi-fsl-espi.c:320:			status = -EMSGSIZE;
spi-fsl-espi.c:324:		if (t->delay_usecs)
spi-fsl-espi.c:325:			udelay(t->delay_usecs);
spi-fsl-espi.c:328:	espi_trans->status = status;
spi-fsl-espi.c:342:		espi_trans->status = -ENOMEM;
spi-fsl-espi.c:346:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-fsl-espi.c:347:		if (t->tx_buf) {
spi-fsl-espi.c:348:			memcpy(local_buf + i, t->tx_buf, t->len);
spi-fsl-espi.c:349:			i += t->len;
spi-fsl-espi.c:353:	espi_trans->tx_buf = local_buf;
spi-fsl-espi.c:354:	espi_trans->rx_buf = local_buf;
spi-fsl-espi.c:357:	espi_trans->actual_length = espi_trans->len;
spi-fsl-espi.c:365:	unsigned int total_len = espi_trans->len;
spi-fsl-espi.c:378:		espi_trans->status = -ENOMEM;
spi-fsl-espi.c:383:		trans_len = total_len - pos;
spi-fsl-espi.c:387:		list_for_each_entry(t, &m->transfers, transfer_list) {
spi-fsl-espi.c:388:			if (t->tx_buf) {
spi-fsl-espi.c:389:				memcpy(local_buf + i, t->tx_buf, t->len);
spi-fsl-espi.c:390:				i += t->len;
spi-fsl-espi.c:391:				if (!t->rx_buf)
spi-fsl-espi.c:392:					tx_only += t->len;
spi-fsl-espi.c:410:		espi_trans->len = trans_len;
spi-fsl-espi.c:411:		espi_trans->tx_buf = local_buf;
spi-fsl-espi.c:412:		espi_trans->rx_buf = local_buf;
spi-fsl-espi.c:417:			memcpy(rx_buf + rx_pos, espi_trans->rx_buf + tx_only,
spi-fsl-espi.c:418:					trans_len - tx_only);
spi-fsl-espi.c:420:		rx_pos += trans_len - tx_only;
spi-fsl-espi.c:423:			espi_trans->actual_length += espi_trans->len - tx_only;
spi-fsl-espi.c:425:			espi_trans->actual_length += espi_trans->len;
spi-fsl-espi.c:441:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-fsl-espi.c:442:		if (t->tx_buf)
spi-fsl-espi.c:443:			n_tx += t->len;
spi-fsl-espi.c:444:		if (t->rx_buf) {
spi-fsl-espi.c:445:			n_rx += t->len;
spi-fsl-espi.c:446:			rx_buf = t->rx_buf;
spi-fsl-espi.c:448:		if ((t->tx_buf) || (t->rx_buf))
spi-fsl-espi.c:449:			xfer_len += t->len;
spi-fsl-espi.c:463:	m->actual_length = espi_trans.actual_length;
spi-fsl-espi.c:464:	m->status = espi_trans.status;
spi-fsl-espi.c:478:	if (!spi->max_speed_hz)
spi-fsl-espi.c:479:		return -EINVAL;
spi-fsl-espi.c:484:			return -ENOMEM;
spi-fsl-espi.c:488:	mpc8xxx_spi = spi_master_get_devdata(spi->master);
spi-fsl-espi.c:489:	reg_base = mpc8xxx_spi->reg_base;
spi-fsl-espi.c:491:	pm_runtime_get_sync(mpc8xxx_spi->dev);
spi-fsl-espi.c:493:	hw_mode = cs->hw_mode; /* Save original settings */
spi-fsl-espi.c:494:	cs->hw_mode = mpc8xxx_spi_read_reg(
spi-fsl-espi.c:495:			&reg_base->csmode[spi->chip_select]);
spi-fsl-espi.c:497:	cs->hw_mode &= ~(CSMODE_CP_BEGIN_EDGECLK | CSMODE_CI_INACTIVEHIGH
spi-fsl-espi.c:500:	if (spi->mode & SPI_CPHA)
spi-fsl-espi.c:501:		cs->hw_mode |= CSMODE_CP_BEGIN_EDGECLK;
spi-fsl-espi.c:502:	if (spi->mode & SPI_CPOL)
spi-fsl-espi.c:503:		cs->hw_mode |= CSMODE_CI_INACTIVEHIGH;
spi-fsl-espi.c:504:	if (!(spi->mode & SPI_LSB_FIRST))
spi-fsl-espi.c:505:		cs->hw_mode |= CSMODE_REV;
spi-fsl-espi.c:508:	loop_mode = mpc8xxx_spi_read_reg(&reg_base->mode);
spi-fsl-espi.c:510:	if (spi->mode & SPI_LOOP)
spi-fsl-espi.c:512:	mpc8xxx_spi_write_reg(&reg_base->mode, loop_mode);
spi-fsl-espi.c:516:	pm_runtime_mark_last_busy(mpc8xxx_spi->dev);
spi-fsl-espi.c:517:	pm_runtime_put_autosuspend(mpc8xxx_spi->dev);
spi-fsl-espi.c:520:		cs->hw_mode = hw_mode; /* Restore settings */
spi-fsl-espi.c:536:	struct fsl_espi_reg *reg_base = mspi->reg_base;
spi-fsl-espi.c:544:		while (SPIE_RXCNT(events) < min(4, mspi->len)) {
spi-fsl-espi.c:546:			events = mpc8xxx_spi_read_reg(&reg_base->event);
spi-fsl-espi.c:549:		if (mspi->len >= 4) {
spi-fsl-espi.c:550:			rx_data = mpc8xxx_spi_read_reg(&reg_base->receive);
spi-fsl-espi.c:552:			tmp = mspi->len;
spi-fsl-espi.c:554:			while (tmp--) {
spi-fsl-espi.c:555:				rx_data_8 = in_8((u8 *)&reg_base->receive);
spi-fsl-espi.c:559:			rx_data <<= (4 - mspi->len) * 8;
spi-fsl-espi.c:562:		mspi->len -= 4;
spi-fsl-espi.c:564:		if (mspi->rx)
spi-fsl-espi.c:565:			mspi->get_rx(rx_data, mspi);
spi-fsl-espi.c:573:				&reg_base->event)) & SPIE_NF), 1000, 0);
spi-fsl-espi.c:575:			dev_err(mspi->dev, "tired waiting for SPIE_NF\n");
spi-fsl-espi.c:578:			mpc8xxx_spi_write_reg(&reg_base->event, events);
spi-fsl-espi.c:579:			complete(&mspi->done);
spi-fsl-espi.c:585:	mpc8xxx_spi_write_reg(&reg_base->event, events);
spi-fsl-espi.c:587:	mspi->count -= 1;
spi-fsl-espi.c:588:	if (mspi->count) {
spi-fsl-espi.c:589:		u32 word = mspi->get_tx(mspi);
spi-fsl-espi.c:591:		mpc8xxx_spi_write_reg(&reg_base->transmit, word);
spi-fsl-espi.c:593:		complete(&mspi->done);
spi-fsl-espi.c:600:	struct fsl_espi_reg *reg_base = mspi->reg_base;
spi-fsl-espi.c:605:	events = mpc8xxx_spi_read_reg(&reg_base->event);
spi-fsl-espi.c:609:	dev_vdbg(mspi->dev, "%s: events %x\n", __func__, events);
spi-fsl-espi.c:621:	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
spi-fsl-espi.c:624:	regval = mpc8xxx_spi_read_reg(&reg_base->mode);
spi-fsl-espi.c:626:	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
spi-fsl-espi.c:635:	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
spi-fsl-espi.c:638:	regval = mpc8xxx_spi_read_reg(&reg_base->mode);
spi-fsl-espi.c:640:	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
spi-fsl-espi.c:660:		ret = -ENOMEM;
spi-fsl-espi.c:668:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
spi-fsl-espi.c:669:	master->setup = fsl_espi_setup;
spi-fsl-espi.c:670:	master->cleanup = fsl_espi_cleanup;
spi-fsl-espi.c:671:	master->transfer_one_message = fsl_espi_do_one_msg;
spi-fsl-espi.c:672:	master->auto_runtime_pm = true;
spi-fsl-espi.c:676:	mpc8xxx_spi->reg_base = devm_ioremap_resource(dev, mem);
spi-fsl-espi.c:677:	if (IS_ERR(mpc8xxx_spi->reg_base)) {
spi-fsl-espi.c:678:		ret = PTR_ERR(mpc8xxx_spi->reg_base);
spi-fsl-espi.c:682:	reg_base = mpc8xxx_spi->reg_base;
spi-fsl-espi.c:685:	ret = devm_request_irq(dev, mpc8xxx_spi->irq, fsl_espi_irq,
spi-fsl-espi.c:690:	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE) {
spi-fsl-espi.c:691:		mpc8xxx_spi->rx_shift = 16;
spi-fsl-espi.c:692:		mpc8xxx_spi->tx_shift = 24;
spi-fsl-espi.c:696:	mpc8xxx_spi_write_reg(&reg_base->mode, 0);
spi-fsl-espi.c:697:	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
spi-fsl-espi.c:698:	mpc8xxx_spi_write_reg(&reg_base->command, 0);
spi-fsl-espi.c:699:	mpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);
spi-fsl-espi.c:702:	for_each_available_child_of_node(master->dev.of_node, nc) {
spi-fsl-espi.c:708:		if (i < 0 || i >= pdata->max_chipselect)
spi-fsl-espi.c:724:		mpc8xxx_spi_write_reg(&reg_base->csmode[i], csmode);
spi-fsl-espi.c:730:	regval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;
spi-fsl-espi.c:732:	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
spi-fsl-espi.c:744:	dev_info(dev, "at 0x%p (irq = %d)\n", reg_base, mpc8xxx_spi->irq);
spi-fsl-espi.c:763:	struct device_node *np = dev->of_node;
spi-fsl-espi.c:768:	prop = of_get_property(np, "fsl,espi-num-chipselects", &len);
spi-fsl-espi.c:770:		dev_err(dev, "No 'fsl,espi-num-chipselects' property\n");
spi-fsl-espi.c:771:		return -EINVAL;
spi-fsl-espi.c:774:	pdata->max_chipselect = *prop;
spi-fsl-espi.c:775:	pdata->cs_control = NULL;
spi-fsl-espi.c:782:	struct device *dev = &ofdev->dev;
spi-fsl-espi.c:783:	struct device_node *np = ofdev->dev.of_node;
spi-fsl-espi.c:787:	int ret = -ENOMEM;
spi-fsl-espi.c:803:		ret = -EINVAL;
spi-fsl-espi.c:821:	pm_runtime_disable(&dev->dev);
spi-fsl-espi.c:855:	reg_base = mpc8xxx_spi->reg_base;
spi-fsl-espi.c:858:	mpc8xxx_spi_write_reg(&reg_base->mode, 0);
spi-fsl-espi.c:859:	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
spi-fsl-espi.c:860:	mpc8xxx_spi_write_reg(&reg_base->command, 0);
spi-fsl-espi.c:861:	mpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);
spi-fsl-espi.c:864:	for (i = 0; i < pdata->max_chipselect; i++)
spi-fsl-espi.c:865:		mpc8xxx_spi_write_reg(&reg_base->csmode[i], CSMODE_INIT_VAL);
spi-fsl-espi.c:868:	regval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;
spi-fsl-espi.c:870:	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
spi-fsl-espi.c:887:	{ .compatible = "fsl,mpc8536-espi" },
spi-coldfire-qspi.c:79:	writew(val, mcfqspi->iobase + MCFQSPI_QMR);
spi-coldfire-qspi.c:84:	writew(val, mcfqspi->iobase + MCFQSPI_QDLYR);
spi-coldfire-qspi.c:89:	return readw(mcfqspi->iobase + MCFQSPI_QDLYR);
spi-coldfire-qspi.c:94:	writew(val, mcfqspi->iobase + MCFQSPI_QWR);
spi-coldfire-qspi.c:99:	writew(val, mcfqspi->iobase + MCFQSPI_QIR);
spi-coldfire-qspi.c:104:	writew(val, mcfqspi->iobase + MCFQSPI_QAR);
spi-coldfire-qspi.c:109:	writew(val, mcfqspi->iobase + MCFQSPI_QDR);
spi-coldfire-qspi.c:114:	return readw(mcfqspi->iobase + MCFQSPI_QDR);
spi-coldfire-qspi.c:120:	mcfqspi->cs_control->select(mcfqspi->cs_control, chip_select, cs_high);
spi-coldfire-qspi.c:126:	mcfqspi->cs_control->deselect(mcfqspi->cs_control, chip_select, cs_high);
spi-coldfire-qspi.c:131:	return (mcfqspi->cs_control->setup) ?
spi-coldfire-qspi.c:132:		mcfqspi->cs_control->setup(mcfqspi->cs_control) : 0;
spi-coldfire-qspi.c:137:	if (mcfqspi->cs_control->teardown)
spi-coldfire-qspi.c:138:		mcfqspi->cs_control->teardown(mcfqspi->cs_control);
spi-coldfire-qspi.c:143:	return clamp((MCFQSPI_BUSCLK + speed_hz - 1) / speed_hz, 2u, 255u);
spi-coldfire-qspi.c:157:	wake_up(&mcfqspi->waitq);
spi-coldfire-qspi.c:181:	count -= n;
spi-coldfire-qspi.c:188:			wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
spi-coldfire-qspi.c:204:			qwr = (offset ? 0x808 : 0) + ((n - 1) << 8);
spi-coldfire-qspi.c:206:			count -= n;
spi-coldfire-qspi.c:208:		wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
spi-coldfire-qspi.c:218:		mcfqspi_wr_qwr(mcfqspi, (n - 1) << 8);
spi-coldfire-qspi.c:221:	wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
spi-coldfire-qspi.c:248:	count -= n;
spi-coldfire-qspi.c:255:			wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
spi-coldfire-qspi.c:271:			qwr = (offset ? 0x808 : 0x000) + ((n - 1) << 8);
spi-coldfire-qspi.c:273:			count -= n;
spi-coldfire-qspi.c:275:		wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
spi-coldfire-qspi.c:285:		mcfqspi_wr_qwr(mcfqspi, (n - 1) << 8);
spi-coldfire-qspi.c:288:	wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
spi-coldfire-qspi.c:298:	struct mcfqspi *mcfqspi = spi_master_get_devdata(spi->master);
spi-coldfire-qspi.c:299:	bool cs_high = spi->mode & SPI_CS_HIGH;
spi-coldfire-qspi.c:302:		mcfqspi_cs_select(mcfqspi, spi->chip_select, cs_high);
spi-coldfire-qspi.c:304:		mcfqspi_cs_deselect(mcfqspi, spi->chip_select, cs_high);
spi-coldfire-qspi.c:314:	qmr |= t->bits_per_word << 10;
spi-coldfire-qspi.c:315:	if (spi->mode & SPI_CPHA)
spi-coldfire-qspi.c:317:	if (spi->mode & SPI_CPOL)
spi-coldfire-qspi.c:319:	qmr |= mcfqspi_qmr_baud(t->speed_hz);
spi-coldfire-qspi.c:323:	if (t->bits_per_word == 8)
spi-coldfire-qspi.c:324:		mcfqspi_transfer_msg8(mcfqspi, t->len, t->tx_buf, t->rx_buf);
spi-coldfire-qspi.c:326:		mcfqspi_transfer_msg16(mcfqspi, t->len / 2, t->tx_buf,
spi-coldfire-qspi.c:327:				       t->rx_buf);
spi-coldfire-qspi.c:335:	mcfqspi_cs_deselect(spi_master_get_devdata(spi->master),
spi-coldfire-qspi.c:336:			    spi->chip_select, spi->mode & SPI_CS_HIGH);
spi-coldfire-qspi.c:338:	dev_dbg(&spi->dev,
spi-coldfire-qspi.c:340:			spi->bits_per_word, spi->chip_select,
spi-coldfire-qspi.c:341:			(MCFQSPI_BUSCLK / mcfqspi_qmr_baud(spi->max_speed_hz))
spi-coldfire-qspi.c:355:	pdata = dev_get_platdata(&pdev->dev);
spi-coldfire-qspi.c:357:		dev_dbg(&pdev->dev, "platform data is missing\n");
spi-coldfire-qspi.c:358:		return -ENOENT;
spi-coldfire-qspi.c:361:	if (!pdata->cs_control) {
spi-coldfire-qspi.c:362:		dev_dbg(&pdev->dev, "pdata->cs_control is NULL\n");
spi-coldfire-qspi.c:363:		return -EINVAL;
spi-coldfire-qspi.c:366:	master = spi_alloc_master(&pdev->dev, sizeof(*mcfqspi));
spi-coldfire-qspi.c:368:		dev_dbg(&pdev->dev, "spi_alloc_master failed\n");
spi-coldfire-qspi.c:369:		return -ENOMEM;
spi-coldfire-qspi.c:375:	mcfqspi->iobase = devm_ioremap_resource(&pdev->dev, res);
spi-coldfire-qspi.c:376:	if (IS_ERR(mcfqspi->iobase)) {
spi-coldfire-qspi.c:377:		status = PTR_ERR(mcfqspi->iobase);
spi-coldfire-qspi.c:381:	mcfqspi->irq = platform_get_irq(pdev, 0);
spi-coldfire-qspi.c:382:	if (mcfqspi->irq < 0) {
spi-coldfire-qspi.c:383:		dev_dbg(&pdev->dev, "platform_get_irq failed\n");
spi-coldfire-qspi.c:384:		status = -ENXIO;
spi-coldfire-qspi.c:388:	status = devm_request_irq(&pdev->dev, mcfqspi->irq, mcfqspi_irq_handler,
spi-coldfire-qspi.c:389:				0, pdev->name, mcfqspi);
spi-coldfire-qspi.c:391:		dev_dbg(&pdev->dev, "request_irq failed\n");
spi-coldfire-qspi.c:395:	mcfqspi->clk = devm_clk_get(&pdev->dev, "qspi_clk");
spi-coldfire-qspi.c:396:	if (IS_ERR(mcfqspi->clk)) {
spi-coldfire-qspi.c:397:		dev_dbg(&pdev->dev, "clk_get failed\n");
spi-coldfire-qspi.c:398:		status = PTR_ERR(mcfqspi->clk);
spi-coldfire-qspi.c:401:	clk_enable(mcfqspi->clk);
spi-coldfire-qspi.c:403:	master->bus_num = pdata->bus_num;
spi-coldfire-qspi.c:404:	master->num_chipselect = pdata->num_chipselect;
spi-coldfire-qspi.c:406:	mcfqspi->cs_control = pdata->cs_control;
spi-coldfire-qspi.c:409:		dev_dbg(&pdev->dev, "error initializing cs_control\n");
spi-coldfire-qspi.c:413:	init_waitqueue_head(&mcfqspi->waitq);
spi-coldfire-qspi.c:415:	master->mode_bits = SPI_CS_HIGH | SPI_CPOL | SPI_CPHA;
spi-coldfire-qspi.c:416:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 16);
spi-coldfire-qspi.c:417:	master->setup = mcfqspi_setup;
spi-coldfire-qspi.c:418:	master->set_cs = mcfqspi_set_cs;
spi-coldfire-qspi.c:419:	master->transfer_one = mcfqspi_transfer_one;
spi-coldfire-qspi.c:420:	master->auto_runtime_pm = true;
spi-coldfire-qspi.c:423:	pm_runtime_enable(&pdev->dev);
spi-coldfire-qspi.c:425:	status = devm_spi_register_master(&pdev->dev, master);
spi-coldfire-qspi.c:427:		dev_dbg(&pdev->dev, "spi_register_master failed\n");
spi-coldfire-qspi.c:431:	dev_info(&pdev->dev, "Coldfire QSPI bus driver\n");
spi-coldfire-qspi.c:436:	pm_runtime_disable(&pdev->dev);
spi-coldfire-qspi.c:439:	clk_disable(mcfqspi->clk);
spi-coldfire-qspi.c:443:	dev_dbg(&pdev->dev, "Coldfire QSPI probe failed\n");
spi-coldfire-qspi.c:453:	pm_runtime_disable(&pdev->dev);
spi-coldfire-qspi.c:458:	clk_disable(mcfqspi->clk);
spi-coldfire-qspi.c:474:	clk_disable(mcfqspi->clk);
spi-coldfire-qspi.c:484:	clk_enable(mcfqspi->clk);
spi-coldfire-qspi.c:496:	clk_disable(mcfqspi->clk);
spi-coldfire-qspi.c:506:	clk_enable(mcfqspi->clk);
spi-s3c24xx.c:3: * Copyright 2006-2009 Simtec Electronics
spi-s3c24xx.c:28:#include <plat/regs-spi.h>
spi-s3c24xx.c:32:#include "spi-s3c24xx-fiq.h"
spi-s3c24xx.c:35: * s3c24xx_spi_devstate - per device data
spi-s3c24xx.c:89:	return spi_master_get_devdata(sdev->master);
spi-s3c24xx.c:94:	gpio_set_value(spi->pin_cs, pol);
spi-s3c24xx.c:99:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
spi-s3c24xx.c:101:	unsigned int cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;
spi-s3c24xx.c:107:		hw->set_cs(hw->pdata, spi->chip_select, cspol^1);
spi-s3c24xx.c:108:		writeb(cs->spcon, hw->regs + S3C2410_SPCON);
spi-s3c24xx.c:112:		writeb(cs->spcon | S3C2410_SPCON_ENSCK,
spi-s3c24xx.c:113:		       hw->regs + S3C2410_SPCON);
spi-s3c24xx.c:114:		hw->set_cs(hw->pdata, spi->chip_select, cspol);
spi-s3c24xx.c:123:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
spi-s3c24xx.c:128:	hz  = t ? t->speed_hz : spi->max_speed_hz;
spi-s3c24xx.c:131:		hz = spi->max_speed_hz;
spi-s3c24xx.c:133:	if (spi->mode != cs->mode) {
spi-s3c24xx.c:136:		if (spi->mode & SPI_CPHA)
spi-s3c24xx.c:139:		if (spi->mode & SPI_CPOL)
spi-s3c24xx.c:142:		cs->mode = spi->mode;
spi-s3c24xx.c:143:		cs->spcon = spcon;
spi-s3c24xx.c:146:	if (cs->hz != hz) {
spi-s3c24xx.c:147:		clk = clk_get_rate(hw->clk);
spi-s3c24xx.c:148:		div = DIV_ROUND_UP(clk, hz * 2) - 1;
spi-s3c24xx.c:153:		dev_dbg(&spi->dev, "pre-scaler=%d (wanted %d, got %ld)\n",
spi-s3c24xx.c:156:		cs->hz = hz;
spi-s3c24xx.c:157:		cs->sppre = div;
spi-s3c24xx.c:166:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
spi-s3c24xx.c:172:		writeb(cs->sppre, hw->regs + S3C2410_SPPRE);
spi-s3c24xx.c:179:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
spi-s3c24xx.c:185:		cs = devm_kzalloc(&spi->dev,
spi-s3c24xx.c:189:			return -ENOMEM;
spi-s3c24xx.c:191:		cs->spcon = SPCON_DEFAULT;
spi-s3c24xx.c:192:		cs->hz = -1;
spi-s3c24xx.c:193:		spi->controller_state = cs;
spi-s3c24xx.c:201:	mutex_lock(&hw->bitbang.lock);
spi-s3c24xx.c:202:	if (!hw->bitbang.busy) {
spi-s3c24xx.c:203:		hw->bitbang.chipselect(spi, BITBANG_CS_INACTIVE);
spi-s3c24xx.c:206:	mutex_unlock(&hw->bitbang.lock);
spi-s3c24xx.c:213:	return hw->tx ? hw->tx[count] : 0;
spi-s3c24xx.c:217:/* Support for FIQ based pseudo-DMA to improve the transfer speed.
spi-s3c24xx.c:226: * struct spi_fiq_code - FIQ code and header
spi-s3c24xx.c:242: * ack_bit - turn IRQ into IRQ acknowledgement bit
spi-s3c24xx.c:249:	return 1 << (irq - IRQ_EINT0);
spi-s3c24xx.c:253: * s3c24xx_spi_tryfiq - attempt to claim and setup FIQ for transfer
spi-s3c24xx.c:261: * as normal, since the IRQ will have been re-routed to the FIQ handler.
spi-s3c24xx.c:270:	if (!hw->fiq_claimed) {
spi-s3c24xx.c:274:		ret = claim_fiq(&hw->fiq_handler);
spi-s3c24xx.c:279:	if (hw->tx && !hw->rx)
spi-s3c24xx.c:281:	else if (hw->rx && !hw->tx)
spi-s3c24xx.c:286:	regs.uregs[fiq_rspi] = (long)hw->regs;
spi-s3c24xx.c:287:	regs.uregs[fiq_rrx]  = (long)hw->rx;
spi-s3c24xx.c:288:	regs.uregs[fiq_rtx]  = (long)hw->tx + 1;
spi-s3c24xx.c:289:	regs.uregs[fiq_rcount] = hw->len - 1;
spi-s3c24xx.c:294:	if (hw->fiq_mode != mode) {
spi-s3c24xx.c:297:		hw->fiq_mode = mode;
spi-s3c24xx.c:315:		ack_ptr = (u32 *)&code->data[code->ack_offset];
spi-s3c24xx.c:316:		*ack_ptr = ack_bit(hw->irq);
spi-s3c24xx.c:318:		set_fiq_handler(&code->data, code->length);
spi-s3c24xx.c:321:	s3c24xx_set_fiq(hw->irq, true);
spi-s3c24xx.c:323:	hw->fiq_mode = mode;
spi-s3c24xx.c:324:	hw->fiq_inuse = 1;
spi-s3c24xx.c:328: * s3c24xx_spi_fiqop - FIQ core code callback
spi-s3c24xx.c:342:		if (hw->fiq_inuse)
spi-s3c24xx.c:343:			ret = -EBUSY;
spi-s3c24xx.c:346:		 * vector code de-routes it to signal the end of transfer */
spi-s3c24xx.c:348:		hw->fiq_mode = FIQ_MODE_NONE;
spi-s3c24xx.c:349:		hw->fiq_claimed = 0;
spi-s3c24xx.c:351:		hw->fiq_claimed = 1;
spi-s3c24xx.c:358: * s3c24xx_spi_initfiq - setup the information for the FIQ core
spi-s3c24xx.c:365:	hw->fiq_handler.dev_id = hw;
spi-s3c24xx.c:366:	hw->fiq_handler.name = dev_name(hw->dev);
spi-s3c24xx.c:367:	hw->fiq_handler.fiq_op = s3c24xx_spi_fiqop;
spi-s3c24xx.c:371: * s3c24xx_spi_usefiq - return if we should be using FIQ.
spi-s3c24xx.c:379:	return hw->pdata->use_fiq;
spi-s3c24xx.c:383: * s3c24xx_spi_usingfiq - return if channel is using FIQ
spi-s3c24xx.c:391:	return spi->fiq_inuse;
spi-s3c24xx.c:406:	hw->tx = t->tx_buf;
spi-s3c24xx.c:407:	hw->rx = t->rx_buf;
spi-s3c24xx.c:408:	hw->len = t->len;
spi-s3c24xx.c:409:	hw->count = 0;
spi-s3c24xx.c:411:	init_completion(&hw->done);
spi-s3c24xx.c:413:	hw->fiq_inuse = 0;
spi-s3c24xx.c:414:	if (s3c24xx_spi_usefiq(hw) && t->len >= 3)
spi-s3c24xx.c:418:	writeb(hw_txbyte(hw, 0), hw->regs + S3C2410_SPTDAT);
spi-s3c24xx.c:420:	wait_for_completion(&hw->done);
spi-s3c24xx.c:421:	return hw->count;
spi-s3c24xx.c:427:	unsigned int spsta = readb(hw->regs + S3C2410_SPSTA);
spi-s3c24xx.c:428:	unsigned int count = hw->count;
spi-s3c24xx.c:431:		dev_dbg(hw->dev, "data-collision\n");
spi-s3c24xx.c:432:		complete(&hw->done);
spi-s3c24xx.c:437:		dev_dbg(hw->dev, "spi not ready for tx?\n");
spi-s3c24xx.c:438:		complete(&hw->done);
spi-s3c24xx.c:443:		hw->count++;
spi-s3c24xx.c:445:		if (hw->rx)
spi-s3c24xx.c:446:			hw->rx[count] = readb(hw->regs + S3C2410_SPRDAT);
spi-s3c24xx.c:450:		if (count < hw->len)
spi-s3c24xx.c:451:			writeb(hw_txbyte(hw, count), hw->regs + S3C2410_SPTDAT);
spi-s3c24xx.c:453:			complete(&hw->done);
spi-s3c24xx.c:455:		hw->count = hw->len;
spi-s3c24xx.c:456:		hw->fiq_inuse = 0;
spi-s3c24xx.c:458:		if (hw->rx)
spi-s3c24xx.c:459:			hw->rx[hw->len-1] = readb(hw->regs + S3C2410_SPRDAT);
spi-s3c24xx.c:461:		complete(&hw->done);
spi-s3c24xx.c:472:	clk_enable(hw->clk);
spi-s3c24xx.c:476:	writeb(0xff, hw->regs + S3C2410_SPPRE);
spi-s3c24xx.c:477:	writeb(SPPIN_DEFAULT, hw->regs + S3C2410_SPPIN);
spi-s3c24xx.c:478:	writeb(SPCON_DEFAULT, hw->regs + S3C2410_SPCON);
spi-s3c24xx.c:480:	if (hw->pdata) {
spi-s3c24xx.c:481:		if (hw->set_cs == s3c24xx_spi_gpiocs)
spi-s3c24xx.c:482:			gpio_direction_output(hw->pdata->pin_cs, 1);
spi-s3c24xx.c:484:		if (hw->pdata->gpio_setup)
spi-s3c24xx.c:485:			hw->pdata->gpio_setup(hw->pdata, 1);
spi-s3c24xx.c:497:	master = spi_alloc_master(&pdev->dev, sizeof(struct s3c24xx_spi));
spi-s3c24xx.c:499:		dev_err(&pdev->dev, "No memory for spi_master\n");
spi-s3c24xx.c:500:		return -ENOMEM;
spi-s3c24xx.c:505:	hw->master = master;
spi-s3c24xx.c:506:	hw->pdata = pdata = dev_get_platdata(&pdev->dev);
spi-s3c24xx.c:507:	hw->dev = &pdev->dev;
spi-s3c24xx.c:510:		dev_err(&pdev->dev, "No platform data supplied\n");
spi-s3c24xx.c:511:		err = -ENOENT;
spi-s3c24xx.c:516:	init_completion(&hw->done);
spi-s3c24xx.c:524:	/* the spi->mode bits understood by this driver: */
spi-s3c24xx.c:525:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-s3c24xx.c:527:	master->num_chipselect = hw->pdata->num_cs;
spi-s3c24xx.c:528:	master->bus_num = pdata->bus_num;
spi-s3c24xx.c:529:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-s3c24xx.c:533:	hw->bitbang.master         = hw->master;
spi-s3c24xx.c:534:	hw->bitbang.setup_transfer = s3c24xx_spi_setupxfer;
spi-s3c24xx.c:535:	hw->bitbang.chipselect     = s3c24xx_spi_chipsel;
spi-s3c24xx.c:536:	hw->bitbang.txrx_bufs      = s3c24xx_spi_txrx;
spi-s3c24xx.c:538:	hw->master->setup  = s3c24xx_spi_setup;
spi-s3c24xx.c:540:	dev_dbg(hw->dev, "bitbang at %p\n", &hw->bitbang);
spi-s3c24xx.c:544:	hw->regs = devm_ioremap_resource(&pdev->dev, res);
spi-s3c24xx.c:545:	if (IS_ERR(hw->regs)) {
spi-s3c24xx.c:546:		err = PTR_ERR(hw->regs);
spi-s3c24xx.c:550:	hw->irq = platform_get_irq(pdev, 0);
spi-s3c24xx.c:551:	if (hw->irq < 0) {
spi-s3c24xx.c:552:		dev_err(&pdev->dev, "No IRQ specified\n");
spi-s3c24xx.c:553:		err = -ENOENT;
spi-s3c24xx.c:557:	err = devm_request_irq(&pdev->dev, hw->irq, s3c24xx_spi_irq, 0,
spi-s3c24xx.c:558:				pdev->name, hw);
spi-s3c24xx.c:560:		dev_err(&pdev->dev, "Cannot claim IRQ\n");
spi-s3c24xx.c:564:	hw->clk = devm_clk_get(&pdev->dev, "spi");
spi-s3c24xx.c:565:	if (IS_ERR(hw->clk)) {
spi-s3c24xx.c:566:		dev_err(&pdev->dev, "No clock for device\n");
spi-s3c24xx.c:567:		err = PTR_ERR(hw->clk);
spi-s3c24xx.c:573:	if (!pdata->set_cs) {
spi-s3c24xx.c:574:		if (pdata->pin_cs < 0) {
spi-s3c24xx.c:575:			dev_err(&pdev->dev, "No chipselect pin\n");
spi-s3c24xx.c:576:			err = -EINVAL;
spi-s3c24xx.c:580:		err = devm_gpio_request(&pdev->dev, pdata->pin_cs,
spi-s3c24xx.c:581:					dev_name(&pdev->dev));
spi-s3c24xx.c:583:			dev_err(&pdev->dev, "Failed to get gpio for cs\n");
spi-s3c24xx.c:587:		hw->set_cs = s3c24xx_spi_gpiocs;
spi-s3c24xx.c:588:		gpio_direction_output(pdata->pin_cs, 1);
spi-s3c24xx.c:590:		hw->set_cs = pdata->set_cs;
spi-s3c24xx.c:596:	err = spi_bitbang_start(&hw->bitbang);
spi-s3c24xx.c:598:		dev_err(&pdev->dev, "Failed to register SPI master\n");
spi-s3c24xx.c:605:	clk_disable(hw->clk);
spi-s3c24xx.c:608:	spi_master_put(hw->master);
spi-s3c24xx.c:616:	spi_bitbang_stop(&hw->bitbang);
spi-s3c24xx.c:617:	clk_disable(hw->clk);
spi-s3c24xx.c:618:	spi_master_put(hw->master);
spi-s3c24xx.c:630:	ret = spi_master_suspend(hw->master);
spi-s3c24xx.c:634:	if (hw->pdata && hw->pdata->gpio_setup)
spi-s3c24xx.c:635:		hw->pdata->gpio_setup(hw->pdata, 0);
spi-s3c24xx.c:637:	clk_disable(hw->clk);
spi-s3c24xx.c:646:	return spi_master_resume(hw->master);
spi-s3c24xx.c:659:MODULE_ALIAS("platform:s3c2410-spi");
spi-s3c24xx.c:664:		.name	= "s3c2410-spi",
spi-pxa2xx.c:36:#include "spi-pxa2xx.h"
spi-pxa2xx.c:41:MODULE_ALIAS("platform:pxa2xx-spi");
spi-pxa2xx.c:74:	/* LPSS offset from drv_data->ioaddr */
spi-pxa2xx.c:76:	/* Register offsets from drv_data->lpss_base or -1 */
spi-pxa2xx.c:94:		.reg_capabilities = -1,
spi-pxa2xx.c:104:		.reg_capabilities = -1,
spi-pxa2xx.c:111:		.reg_general = -1,
spi-pxa2xx.c:114:		.reg_capabilities = -1,
spi-pxa2xx.c:121:		.reg_general = -1,
spi-pxa2xx.c:134:	return &lpss_platforms[drv_data->ssp_type - LPSS_LPT_SSP];
spi-pxa2xx.c:139:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:152:	return drv_data->ssp_type == QUARK_X1000_SSP;
spi-pxa2xx.c:157:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:168:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:180:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:197:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:211:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:224:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:233:			| SSCR0_DataSize(bits > 16 ? bits - 16 : bits)
spi-pxa2xx.c:245:	WARN_ON(!drv_data->lpss_base);
spi-pxa2xx.c:246:	return readl(drv_data->lpss_base + offset);
spi-pxa2xx.c:252:	WARN_ON(!drv_data->lpss_base);
spi-pxa2xx.c:253:	writel(value, drv_data->lpss_base + offset);
spi-pxa2xx.c:257: * lpss_ssp_setup - perform LPSS SSP specific setup
spi-pxa2xx.c:269:	drv_data->lpss_base = drv_data->ioaddr + config->offset;
spi-pxa2xx.c:272:	value = __lpss_ssp_read_priv(drv_data, config->reg_cs_ctrl);
spi-pxa2xx.c:275:	__lpss_ssp_write_priv(drv_data, config->reg_cs_ctrl, value);
spi-pxa2xx.c:278:	if (drv_data->master_info->enable_dma) {
spi-pxa2xx.c:279:		__lpss_ssp_write_priv(drv_data, config->reg_ssp, 1);
spi-pxa2xx.c:281:		if (config->reg_general >= 0) {
spi-pxa2xx.c:283:						     config->reg_general);
spi-pxa2xx.c:286:					      config->reg_general, value);
spi-pxa2xx.c:298:	value = __lpss_ssp_read_priv(drv_data, config->reg_cs_ctrl);
spi-pxa2xx.c:300:		cs = drv_data->cur_msg->spi->chip_select;
spi-pxa2xx.c:314:					      config->reg_cs_ctrl, value);
spi-pxa2xx.c:316:			       (drv_data->master->max_speed_hz / 2));
spi-pxa2xx.c:322:	__lpss_ssp_write_priv(drv_data, config->reg_cs_ctrl, value);
spi-pxa2xx.c:327:	struct chip_data *chip = drv_data->cur_chip;
spi-pxa2xx.c:329:	if (drv_data->ssp_type == CE4100_SSP) {
spi-pxa2xx.c:330:		pxa2xx_spi_write(drv_data, SSSR, drv_data->cur_chip->frm);
spi-pxa2xx.c:334:	if (chip->cs_control) {
spi-pxa2xx.c:335:		chip->cs_control(PXA2XX_CS_ASSERT);
spi-pxa2xx.c:339:	if (gpio_is_valid(chip->gpio_cs)) {
spi-pxa2xx.c:340:		gpio_set_value(chip->gpio_cs, chip->gpio_cs_inverted);
spi-pxa2xx.c:350:	struct chip_data *chip = drv_data->cur_chip;
spi-pxa2xx.c:352:	if (drv_data->ssp_type == CE4100_SSP)
spi-pxa2xx.c:355:	if (chip->cs_control) {
spi-pxa2xx.c:356:		chip->cs_control(PXA2XX_CS_DEASSERT);
spi-pxa2xx.c:360:	if (gpio_is_valid(chip->gpio_cs)) {
spi-pxa2xx.c:361:		gpio_set_value(chip->gpio_cs, !chip->gpio_cs_inverted);
spi-pxa2xx.c:376:	} while ((pxa2xx_spi_read(drv_data, SSSR) & SSSR_BSY) && --limit);
spi-pxa2xx.c:384:	u8 n_bytes = drv_data->n_bytes;
spi-pxa2xx.c:387:		|| (drv_data->tx == drv_data->tx_end))
spi-pxa2xx.c:391:	drv_data->tx += n_bytes;
spi-pxa2xx.c:398:	u8 n_bytes = drv_data->n_bytes;
spi-pxa2xx.c:401:	       && (drv_data->rx < drv_data->rx_end)) {
spi-pxa2xx.c:403:		drv_data->rx += n_bytes;
spi-pxa2xx.c:406:	return drv_data->rx == drv_data->rx_end;
spi-pxa2xx.c:412:		|| (drv_data->tx == drv_data->tx_end))
spi-pxa2xx.c:415:	pxa2xx_spi_write(drv_data, SSDR, *(u8 *)(drv_data->tx));
spi-pxa2xx.c:416:	++drv_data->tx;
spi-pxa2xx.c:424:	       && (drv_data->rx < drv_data->rx_end)) {
spi-pxa2xx.c:425:		*(u8 *)(drv_data->rx) = pxa2xx_spi_read(drv_data, SSDR);
spi-pxa2xx.c:426:		++drv_data->rx;
spi-pxa2xx.c:429:	return drv_data->rx == drv_data->rx_end;
spi-pxa2xx.c:435:		|| (drv_data->tx == drv_data->tx_end))
spi-pxa2xx.c:438:	pxa2xx_spi_write(drv_data, SSDR, *(u16 *)(drv_data->tx));
spi-pxa2xx.c:439:	drv_data->tx += 2;
spi-pxa2xx.c:447:	       && (drv_data->rx < drv_data->rx_end)) {
spi-pxa2xx.c:448:		*(u16 *)(drv_data->rx) = pxa2xx_spi_read(drv_data, SSDR);
spi-pxa2xx.c:449:		drv_data->rx += 2;
spi-pxa2xx.c:452:	return drv_data->rx == drv_data->rx_end;
spi-pxa2xx.c:458:		|| (drv_data->tx == drv_data->tx_end))
spi-pxa2xx.c:461:	pxa2xx_spi_write(drv_data, SSDR, *(u32 *)(drv_data->tx));
spi-pxa2xx.c:462:	drv_data->tx += 4;
spi-pxa2xx.c:470:	       && (drv_data->rx < drv_data->rx_end)) {
spi-pxa2xx.c:471:		*(u32 *)(drv_data->rx) = pxa2xx_spi_read(drv_data, SSDR);
spi-pxa2xx.c:472:		drv_data->rx += 4;
spi-pxa2xx.c:475:	return drv_data->rx == drv_data->rx_end;
spi-pxa2xx.c:480:	struct spi_message *msg = drv_data->cur_msg;
spi-pxa2xx.c:481:	struct spi_transfer *trans = drv_data->cur_transfer;
spi-pxa2xx.c:484:	if (trans->transfer_list.next != &msg->transfers) {
spi-pxa2xx.c:485:		drv_data->cur_transfer =
spi-pxa2xx.c:486:			list_entry(trans->transfer_list.next,
spi-pxa2xx.c:494:/* caller already set message->status; dma and pio irqs are blocked */
spi-pxa2xx.c:500:	msg = drv_data->cur_msg;
spi-pxa2xx.c:501:	drv_data->cur_msg = NULL;
spi-pxa2xx.c:502:	drv_data->cur_transfer = NULL;
spi-pxa2xx.c:504:	last_transfer = list_last_entry(&msg->transfers, struct spi_transfer,
spi-pxa2xx.c:508:	if (last_transfer->delay_usecs)
spi-pxa2xx.c:509:		udelay(last_transfer->delay_usecs);
spi-pxa2xx.c:514:	if (!last_transfer->cs_change)
spi-pxa2xx.c:524:		 * after calling msg->complete (below) the driver that
spi-pxa2xx.c:530:		next_msg = spi_get_next_queued_message(drv_data->master);
spi-pxa2xx.c:535:		if (next_msg && next_msg->spi != msg->spi)
spi-pxa2xx.c:537:		if (!next_msg || msg->state == ERROR_STATE)
spi-pxa2xx.c:541:	drv_data->cur_chip = NULL;
spi-pxa2xx.c:542:	spi_finalize_current_message(drv_data->master);
spi-pxa2xx.c:547:	struct chip_data *chip = drv_data->cur_chip;
spi-pxa2xx.c:550:	sccr1_reg = pxa2xx_spi_read(drv_data, SSCR1) & ~drv_data->int_cr1;
spi-pxa2xx.c:551:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:559:	sccr1_reg |= chip->threshold;
spi-pxa2xx.c:566:	write_SSSR_CS(drv_data, drv_data->clear_sr);
spi-pxa2xx.c:574:	dev_err(&drv_data->pdev->dev, "%s\n", msg);
spi-pxa2xx.c:576:	drv_data->cur_msg->state = ERROR_STATE;
spi-pxa2xx.c:577:	tasklet_schedule(&drv_data->pump_transfers);
spi-pxa2xx.c:583:	write_SSSR_CS(drv_data, drv_data->clear_sr);
spi-pxa2xx.c:589:	drv_data->cur_msg->actual_length += drv_data->len -
spi-pxa2xx.c:590:				(drv_data->rx_end - drv_data->rx);
spi-pxa2xx.c:597:	drv_data->cur_msg->state = pxa2xx_spi_next_transfer(drv_data);
spi-pxa2xx.c:600:	tasklet_schedule(&drv_data->pump_transfers);
spi-pxa2xx.c:606:		       drv_data->mask_sr : drv_data->mask_sr & ~SSSR_TFS;
spi-pxa2xx.c:617:		if (drv_data->read(drv_data)) {
spi-pxa2xx.c:625:		if (drv_data->read(drv_data)) {
spi-pxa2xx.c:629:	} while (drv_data->write(drv_data));
spi-pxa2xx.c:631:	if (drv_data->read(drv_data)) {
spi-pxa2xx.c:636:	if (drv_data->tx == drv_data->tx_end) {
spi-pxa2xx.c:652:			bytes_left = drv_data->rx_end - drv_data->rx;
spi-pxa2xx.c:653:			switch (drv_data->n_bytes) {
spi-pxa2xx.c:677:	u32 mask = drv_data->mask_sr;
spi-pxa2xx.c:686:	if (pm_runtime_suspended(&drv_data->pdev->dev))
spi-pxa2xx.c:712:	if (!drv_data->cur_msg) {
spi-pxa2xx.c:719:				 & ~drv_data->int_cr1);
spi-pxa2xx.c:722:		write_SSSR_CS(drv_data, drv_data->clear_sr);
spi-pxa2xx.c:724:		dev_err(&drv_data->pdev->dev,
spi-pxa2xx.c:731:	return drv_data->transfer_handler(drv_data);
spi-pxa2xx.c:790:		scale = fls_long(q1 - 1);
spi-pxa2xx.c:792:			q1 >>= scale - 9;
spi-pxa2xx.c:793:			mul >>= scale - 9;
spi-pxa2xx.c:806:	r1 = abs(fref1 / (1 << (24 - fls_long(mul))) / q1 - rate);
spi-pxa2xx.c:811:	r2 = abs(fref2 / q2 - rate);
spi-pxa2xx.c:841:		r1 = abs(fssp - rate);
spi-pxa2xx.c:852:	return q - 1;
spi-pxa2xx.c:857:	unsigned long ssp_clk = drv_data->master->max_speed_hz;
spi-pxa2xx.c:858:	const struct ssp_device *ssp = drv_data->ssp;
spi-pxa2xx.c:866:	if (ssp->type == PXA25x_SSP || ssp->type == CE4100_SSP)
spi-pxa2xx.c:867:		return (DIV_ROUND_UP(ssp_clk, 2 * rate) - 1) & 0xff;
spi-pxa2xx.c:869:		return (DIV_ROUND_UP(ssp_clk, rate) - 1)  & 0xfff;
spi-pxa2xx.c:875:	struct chip_data *chip = drv_data->cur_chip;
spi-pxa2xx.c:878:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:880:		clk_div = quark_x1000_get_clk_div(rate, &chip->dds_rate);
spi-pxa2xx.c:901:	u32 dma_thresh = drv_data->cur_chip->dma_threshold;
spi-pxa2xx.c:902:	u32 dma_burst = drv_data->cur_chip->dma_burst_size;
spi-pxa2xx.c:906:	message = drv_data->cur_msg;
spi-pxa2xx.c:907:	transfer = drv_data->cur_transfer;
spi-pxa2xx.c:908:	chip = drv_data->cur_chip;
spi-pxa2xx.c:911:	if (message->state == ERROR_STATE) {
spi-pxa2xx.c:912:		message->status = -EIO;
spi-pxa2xx.c:918:	if (message->state == DONE_STATE) {
spi-pxa2xx.c:919:		message->status = 0;
spi-pxa2xx.c:925:	if (message->state == RUNNING_STATE) {
spi-pxa2xx.c:926:		previous = list_entry(transfer->transfer_list.prev,
spi-pxa2xx.c:929:		if (previous->delay_usecs)
spi-pxa2xx.c:930:			udelay(previous->delay_usecs);
spi-pxa2xx.c:933:		if (previous->cs_change)
spi-pxa2xx.c:938:	if (!pxa2xx_spi_dma_is_possible(transfer->len) && chip->enable_dma) {
spi-pxa2xx.c:940:		/* reject already-mapped transfers; PIO won't always work */
spi-pxa2xx.c:941:		if (message->is_dma_mapped
spi-pxa2xx.c:942:				|| transfer->rx_dma || transfer->tx_dma) {
spi-pxa2xx.c:943:			dev_err(&drv_data->pdev->dev,
spi-pxa2xx.c:946:				transfer->len, MAX_DMA_LEN);
spi-pxa2xx.c:947:			message->status = -EINVAL;
spi-pxa2xx.c:953:		dev_warn_ratelimited(&message->spi->dev,
spi-pxa2xx.c:956:				     (long)drv_data->len, MAX_DMA_LEN);
spi-pxa2xx.c:961:		dev_err(&drv_data->pdev->dev, "pump_transfers: flush failed\n");
spi-pxa2xx.c:962:		message->status = -EIO;
spi-pxa2xx.c:966:	drv_data->n_bytes = chip->n_bytes;
spi-pxa2xx.c:967:	drv_data->tx = (void *)transfer->tx_buf;
spi-pxa2xx.c:968:	drv_data->tx_end = drv_data->tx + transfer->len;
spi-pxa2xx.c:969:	drv_data->rx = transfer->rx_buf;
spi-pxa2xx.c:970:	drv_data->rx_end = drv_data->rx + transfer->len;
spi-pxa2xx.c:971:	drv_data->rx_dma = transfer->rx_dma;
spi-pxa2xx.c:972:	drv_data->tx_dma = transfer->tx_dma;
spi-pxa2xx.c:973:	drv_data->len = transfer->len;
spi-pxa2xx.c:974:	drv_data->write = drv_data->tx ? chip->write : null_writer;
spi-pxa2xx.c:975:	drv_data->read = drv_data->rx ? chip->read : null_reader;
spi-pxa2xx.c:978:	bits = transfer->bits_per_word;
spi-pxa2xx.c:979:	speed = transfer->speed_hz;
spi-pxa2xx.c:984:		drv_data->n_bytes = 1;
spi-pxa2xx.c:985:		drv_data->read = drv_data->read != null_reader ?
spi-pxa2xx.c:987:		drv_data->write = drv_data->write != null_writer ?
spi-pxa2xx.c:990:		drv_data->n_bytes = 2;
spi-pxa2xx.c:991:		drv_data->read = drv_data->read != null_reader ?
spi-pxa2xx.c:993:		drv_data->write = drv_data->write != null_writer ?
spi-pxa2xx.c:996:		drv_data->n_bytes = 4;
spi-pxa2xx.c:997:		drv_data->read = drv_data->read != null_reader ?
spi-pxa2xx.c:999:		drv_data->write = drv_data->write != null_writer ?
spi-pxa2xx.c:1006:	if (chip->enable_dma) {
spi-pxa2xx.c:1008:						message->spi,
spi-pxa2xx.c:1011:			dev_warn_ratelimited(&message->spi->dev,
spi-pxa2xx.c:1018:		dev_dbg(&message->spi->dev, "%u Hz actual, %s\n",
spi-pxa2xx.c:1019:			drv_data->master->max_speed_hz
spi-pxa2xx.c:1021:			chip->enable_dma ? "DMA" : "PIO");
spi-pxa2xx.c:1023:		dev_dbg(&message->spi->dev, "%u Hz actual, %s\n",
spi-pxa2xx.c:1024:			drv_data->master->max_speed_hz / 2
spi-pxa2xx.c:1026:			chip->enable_dma ? "DMA" : "PIO");
spi-pxa2xx.c:1028:	message->state = RUNNING_STATE;
spi-pxa2xx.c:1030:	drv_data->dma_mapped = 0;
spi-pxa2xx.c:1031:	if (pxa2xx_spi_dma_is_possible(drv_data->len))
spi-pxa2xx.c:1032:		drv_data->dma_mapped = pxa2xx_spi_map_dma_buffers(drv_data);
spi-pxa2xx.c:1033:	if (drv_data->dma_mapped) {
spi-pxa2xx.c:1036:		drv_data->transfer_handler = pxa2xx_spi_dma_transfer;
spi-pxa2xx.c:1041:		cr1 = chip->cr1 | dma_thresh | drv_data->dma_cr1;
spi-pxa2xx.c:1042:		pxa2xx_spi_write(drv_data, SSSR, drv_data->clear_sr);
spi-pxa2xx.c:1047:		drv_data->transfer_handler = interrupt_transfer;
spi-pxa2xx.c:1050:		cr1 = chip->cr1 | chip->threshold | drv_data->int_cr1;
spi-pxa2xx.c:1051:		write_SSSR_CS(drv_data, drv_data->clear_sr);
spi-pxa2xx.c:1056:		    != chip->lpss_rx_threshold)
spi-pxa2xx.c:1058:					 chip->lpss_rx_threshold);
spi-pxa2xx.c:1060:		    != chip->lpss_tx_threshold)
spi-pxa2xx.c:1062:					 chip->lpss_tx_threshold);
spi-pxa2xx.c:1066:	    (pxa2xx_spi_read(drv_data, DDS_RATE) != chip->dds_rate))
spi-pxa2xx.c:1067:		pxa2xx_spi_write(drv_data, DDS_RATE, chip->dds_rate);
spi-pxa2xx.c:1076:			pxa2xx_spi_write(drv_data, SSTO, chip->timeout);
spi-pxa2xx.c:1084:			pxa2xx_spi_write(drv_data, SSTO, chip->timeout);
spi-pxa2xx.c:1099:	drv_data->cur_msg = msg;
spi-pxa2xx.c:1101:	drv_data->cur_msg->state = START_STATE;
spi-pxa2xx.c:1102:	drv_data->cur_transfer = list_entry(drv_data->cur_msg->transfers.next,
spi-pxa2xx.c:1108:	drv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);
spi-pxa2xx.c:1111:	tasklet_schedule(&drv_data->pump_transfers);
spi-pxa2xx.c:1137:	if (gpio_is_valid(chip->gpio_cs))
spi-pxa2xx.c:1138:		gpio_free(chip->gpio_cs);
spi-pxa2xx.c:1141:	if (chip_info->cs_control) {
spi-pxa2xx.c:1142:		chip->cs_control = chip_info->cs_control;
spi-pxa2xx.c:1146:	if (gpio_is_valid(chip_info->gpio_cs)) {
spi-pxa2xx.c:1147:		err = gpio_request(chip_info->gpio_cs, "SPI_CS");
spi-pxa2xx.c:1149:			dev_err(&spi->dev, "failed to request chip select GPIO%d\n",
spi-pxa2xx.c:1150:				chip_info->gpio_cs);
spi-pxa2xx.c:1154:		chip->gpio_cs = chip_info->gpio_cs;
spi-pxa2xx.c:1155:		chip->gpio_cs_inverted = spi->mode & SPI_CS_HIGH;
spi-pxa2xx.c:1157:		err = gpio_direction_output(chip->gpio_cs,
spi-pxa2xx.c:1158:					!chip->gpio_cs_inverted);
spi-pxa2xx.c:1169:	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
spi-pxa2xx.c:1172:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:1183:		tx_thres = config->tx_threshold_lo;
spi-pxa2xx.c:1184:		tx_hi_thres = config->tx_threshold_hi;
spi-pxa2xx.c:1185:		rx_thres = config->rx_threshold;
spi-pxa2xx.c:1199:			return -ENOMEM;
spi-pxa2xx.c:1201:		if (drv_data->ssp_type == CE4100_SSP) {
spi-pxa2xx.c:1202:			if (spi->chip_select > 4) {
spi-pxa2xx.c:1203:				dev_err(&spi->dev,
spi-pxa2xx.c:1206:				return -EINVAL;
spi-pxa2xx.c:1209:			chip->frm = spi->chip_select;
spi-pxa2xx.c:1211:			chip->gpio_cs = -1;
spi-pxa2xx.c:1212:		chip->enable_dma = 0;
spi-pxa2xx.c:1213:		chip->timeout = TIMOUT_DFLT;
spi-pxa2xx.c:1218:	chip_info = spi->controller_data;
spi-pxa2xx.c:1221:	chip->cr1 = 0;
spi-pxa2xx.c:1223:		if (chip_info->timeout)
spi-pxa2xx.c:1224:			chip->timeout = chip_info->timeout;
spi-pxa2xx.c:1225:		if (chip_info->tx_threshold)
spi-pxa2xx.c:1226:			tx_thres = chip_info->tx_threshold;
spi-pxa2xx.c:1227:		if (chip_info->tx_hi_threshold)
spi-pxa2xx.c:1228:			tx_hi_thres = chip_info->tx_hi_threshold;
spi-pxa2xx.c:1229:		if (chip_info->rx_threshold)
spi-pxa2xx.c:1230:			rx_thres = chip_info->rx_threshold;
spi-pxa2xx.c:1231:		chip->enable_dma = drv_data->master_info->enable_dma;
spi-pxa2xx.c:1232:		chip->dma_threshold = 0;
spi-pxa2xx.c:1233:		if (chip_info->enable_loopback)
spi-pxa2xx.c:1234:			chip->cr1 = SSCR1_LBM;
spi-pxa2xx.c:1235:	} else if (ACPI_HANDLE(&spi->dev)) {
spi-pxa2xx.c:1241:		chip->enable_dma = drv_data->master_info->enable_dma;
spi-pxa2xx.c:1244:	chip->lpss_rx_threshold = SSIRF_RxThresh(rx_thres);
spi-pxa2xx.c:1245:	chip->lpss_tx_threshold = SSITF_TxLoThresh(tx_thres)
spi-pxa2xx.c:1249:	 * chip_info goes away after setting chip->enable_dma, the
spi-pxa2xx.c:1251:	if (chip->enable_dma) {
spi-pxa2xx.c:1254:						spi->bits_per_word,
spi-pxa2xx.c:1255:						&chip->dma_burst_size,
spi-pxa2xx.c:1256:						&chip->dma_threshold)) {
spi-pxa2xx.c:1257:			dev_warn(&spi->dev,
spi-pxa2xx.c:1262:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:1264:		chip->threshold = (QUARK_X1000_SSCR1_RxTresh(rx_thres)
spi-pxa2xx.c:1270:		chip->threshold = (SSCR1_RxTresh(rx_thres) & SSCR1_RFT) |
spi-pxa2xx.c:1275:	chip->cr1 &= ~(SSCR1_SPO | SSCR1_SPH);
spi-pxa2xx.c:1276:	chip->cr1 |= (((spi->mode & SPI_CPHA) != 0) ? SSCR1_SPH : 0)
spi-pxa2xx.c:1277:			| (((spi->mode & SPI_CPOL) != 0) ? SSCR1_SPO : 0);
spi-pxa2xx.c:1279:	if (spi->mode & SPI_LOOP)
spi-pxa2xx.c:1280:		chip->cr1 |= SSCR1_LBM;
spi-pxa2xx.c:1282:	if (spi->bits_per_word <= 8) {
spi-pxa2xx.c:1283:		chip->n_bytes = 1;
spi-pxa2xx.c:1284:		chip->read = u8_reader;
spi-pxa2xx.c:1285:		chip->write = u8_writer;
spi-pxa2xx.c:1286:	} else if (spi->bits_per_word <= 16) {
spi-pxa2xx.c:1287:		chip->n_bytes = 2;
spi-pxa2xx.c:1288:		chip->read = u16_reader;
spi-pxa2xx.c:1289:		chip->write = u16_writer;
spi-pxa2xx.c:1290:	} else if (spi->bits_per_word <= 32) {
spi-pxa2xx.c:1291:		chip->n_bytes = 4;
spi-pxa2xx.c:1292:		chip->read = u32_reader;
spi-pxa2xx.c:1293:		chip->write = u32_writer;
spi-pxa2xx.c:1298:	if (drv_data->ssp_type == CE4100_SSP)
spi-pxa2xx.c:1307:	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
spi-pxa2xx.c:1312:	if (drv_data->ssp_type != CE4100_SSP && gpio_is_valid(chip->gpio_cs))
spi-pxa2xx.c:1313:		gpio_free(chip->gpio_cs);
spi-pxa2xx.c:1335:	int port_id = -1;
spi-pxa2xx.c:1337:	if (adev && adev->pnp.unique_id &&
spi-pxa2xx.c:1338:	    !kstrtouint(adev->pnp.unique_id, 0, &devid))
spi-pxa2xx.c:1345:	return -1;
spi-pxa2xx.c:1355:	/* SPT-LP */
spi-pxa2xx.c:1358:	/* SPT-H */
spi-pxa2xx.c:1374:	return param == chan->device->dev;
spi-pxa2xx.c:1388:	adev = ACPI_COMPANION(&pdev->dev);
spi-pxa2xx.c:1390:	if (dev_is_pci(pdev->dev.parent))
spi-pxa2xx.c:1392:					 to_pci_dev(pdev->dev.parent));
spi-pxa2xx.c:1394:		adev_id = acpi_match_device(pdev->dev.driver->acpi_match_table,
spi-pxa2xx.c:1395:					    &pdev->dev);
spi-pxa2xx.c:1400:		type = (int)adev_id->driver_data;
spi-pxa2xx.c:1402:		type = (int)pcidev_id->driver_data;
spi-pxa2xx.c:1406:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
spi-pxa2xx.c:1414:	ssp = &pdata->ssp;
spi-pxa2xx.c:1416:	ssp->phys_base = res->start;
spi-pxa2xx.c:1417:	ssp->mmio_base = devm_ioremap_resource(&pdev->dev, res);
spi-pxa2xx.c:1418:	if (IS_ERR(ssp->mmio_base))
spi-pxa2xx.c:1422:		pdata->tx_param = pdev->dev.parent;
spi-pxa2xx.c:1423:		pdata->rx_param = pdev->dev.parent;
spi-pxa2xx.c:1424:		pdata->dma_filter = pxa2xx_spi_idma_filter;
spi-pxa2xx.c:1427:	ssp->clk = devm_clk_get(&pdev->dev, NULL);
spi-pxa2xx.c:1428:	ssp->irq = platform_get_irq(pdev, 0);
spi-pxa2xx.c:1429:	ssp->type = type;
spi-pxa2xx.c:1430:	ssp->pdev = pdev;
spi-pxa2xx.c:1431:	ssp->port_id = pxa2xx_spi_get_port_id(adev);
spi-pxa2xx.c:1433:	pdata->num_chipselect = 1;
spi-pxa2xx.c:1434:	pdata->enable_dma = true;
spi-pxa2xx.c:1449:	struct device *dev = &pdev->dev;
spi-pxa2xx.c:1462:			dev_err(&pdev->dev, "missing platform data\n");
spi-pxa2xx.c:1463:			return -ENODEV;
spi-pxa2xx.c:1467:	ssp = pxa_ssp_request(pdev->id, pdev->name);
spi-pxa2xx.c:1469:		ssp = &platform_info->ssp;
spi-pxa2xx.c:1471:	if (!ssp->mmio_base) {
spi-pxa2xx.c:1472:		dev_err(&pdev->dev, "failed to get ssp\n");
spi-pxa2xx.c:1473:		return -ENODEV;
spi-pxa2xx.c:1478:		dev_err(&pdev->dev, "cannot alloc spi_master\n");
spi-pxa2xx.c:1480:		return -ENOMEM;
spi-pxa2xx.c:1483:	drv_data->master = master;
spi-pxa2xx.c:1484:	drv_data->master_info = platform_info;
spi-pxa2xx.c:1485:	drv_data->pdev = pdev;
spi-pxa2xx.c:1486:	drv_data->ssp = ssp;
spi-pxa2xx.c:1488:	master->dev.parent = &pdev->dev;
spi-pxa2xx.c:1489:	master->dev.of_node = pdev->dev.of_node;
spi-pxa2xx.c:1490:	/* the spi->mode bits understood by this driver: */
spi-pxa2xx.c:1491:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;
spi-pxa2xx.c:1493:	master->bus_num = ssp->port_id;
spi-pxa2xx.c:1494:	master->dma_alignment = DMA_ALIGNMENT;
spi-pxa2xx.c:1495:	master->cleanup = cleanup;
spi-pxa2xx.c:1496:	master->setup = setup;
spi-pxa2xx.c:1497:	master->transfer_one_message = pxa2xx_spi_transfer_one_message;
spi-pxa2xx.c:1498:	master->unprepare_transfer_hardware = pxa2xx_spi_unprepare_transfer;
spi-pxa2xx.c:1499:	master->auto_runtime_pm = true;
spi-pxa2xx.c:1501:	drv_data->ssp_type = ssp->type;
spi-pxa2xx.c:1503:	drv_data->ioaddr = ssp->mmio_base;
spi-pxa2xx.c:1504:	drv_data->ssdr_physical = ssp->phys_base + SSDR;
spi-pxa2xx.c:1506:		switch (drv_data->ssp_type) {
spi-pxa2xx.c:1508:			master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);
spi-pxa2xx.c:1511:			master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
spi-pxa2xx.c:1515:		drv_data->int_cr1 = SSCR1_TIE | SSCR1_RIE;
spi-pxa2xx.c:1516:		drv_data->dma_cr1 = 0;
spi-pxa2xx.c:1517:		drv_data->clear_sr = SSSR_ROR;
spi-pxa2xx.c:1518:		drv_data->mask_sr = SSSR_RFS | SSSR_TFS | SSSR_ROR;
spi-pxa2xx.c:1520:		master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);
spi-pxa2xx.c:1521:		drv_data->int_cr1 = SSCR1_TIE | SSCR1_RIE | SSCR1_TINTE;
spi-pxa2xx.c:1522:		drv_data->dma_cr1 = DEFAULT_DMA_CR1;
spi-pxa2xx.c:1523:		drv_data->clear_sr = SSSR_ROR | SSSR_TINT;
spi-pxa2xx.c:1524:		drv_data->mask_sr = SSSR_TINT | SSSR_RFS | SSSR_TFS | SSSR_ROR;
spi-pxa2xx.c:1527:	status = request_irq(ssp->irq, ssp_int, IRQF_SHARED, dev_name(dev),
spi-pxa2xx.c:1530:		dev_err(&pdev->dev, "cannot get IRQ %d\n", ssp->irq);
spi-pxa2xx.c:1535:	if (platform_info->enable_dma) {
spi-pxa2xx.c:1539:			platform_info->enable_dma = false;
spi-pxa2xx.c:1544:	clk_prepare_enable(ssp->clk);
spi-pxa2xx.c:1546:	master->max_speed_hz = clk_get_rate(ssp->clk);
spi-pxa2xx.c:1550:	switch (drv_data->ssp_type) {
spi-pxa2xx.c:1582:		if (config->reg_capabilities >= 0) {
spi-pxa2xx.c:1584:						   config->reg_capabilities);
spi-pxa2xx.c:1587:			platform_info->num_chipselect = ffz(tmp);
spi-pxa2xx.c:1590:	master->num_chipselect = platform_info->num_chipselect;
spi-pxa2xx.c:1592:	tasklet_init(&drv_data->pump_transfers, pump_transfers,
spi-pxa2xx.c:1595:	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
spi-pxa2xx.c:1596:	pm_runtime_use_autosuspend(&pdev->dev);
spi-pxa2xx.c:1597:	pm_runtime_set_active(&pdev->dev);
spi-pxa2xx.c:1598:	pm_runtime_enable(&pdev->dev);
spi-pxa2xx.c:1602:	status = devm_spi_register_master(&pdev->dev, master);
spi-pxa2xx.c:1604:		dev_err(&pdev->dev, "problem registering spi master\n");
spi-pxa2xx.c:1611:	clk_disable_unprepare(ssp->clk);
spi-pxa2xx.c:1613:	free_irq(ssp->irq, drv_data);
spi-pxa2xx.c:1628:	ssp = drv_data->ssp;
spi-pxa2xx.c:1630:	pm_runtime_get_sync(&pdev->dev);
spi-pxa2xx.c:1634:	clk_disable_unprepare(ssp->clk);
spi-pxa2xx.c:1637:	if (drv_data->master_info->enable_dma)
spi-pxa2xx.c:1640:	pm_runtime_put_noidle(&pdev->dev);
spi-pxa2xx.c:1641:	pm_runtime_disable(&pdev->dev);
spi-pxa2xx.c:1644:	free_irq(ssp->irq, drv_data);
spi-pxa2xx.c:1657:		dev_err(&pdev->dev, "shutdown failed with %d\n", status);
spi-pxa2xx.c:1664:	struct ssp_device *ssp = drv_data->ssp;
spi-pxa2xx.c:1667:	status = spi_master_suspend(drv_data->master);
spi-pxa2xx.c:1673:		clk_disable_unprepare(ssp->clk);
spi-pxa2xx.c:1681:	struct ssp_device *ssp = drv_data->ssp;
spi-pxa2xx.c:1686:		clk_prepare_enable(ssp->clk);
spi-pxa2xx.c:1693:	status = spi_master_resume(drv_data->master);
spi-pxa2xx.c:1708:	clk_disable_unprepare(drv_data->ssp->clk);
spi-pxa2xx.c:1716:	clk_prepare_enable(drv_data->ssp->clk);
spi-pxa2xx.c:1729:		.name	= "pxa2xx-spi",
spi-cadence.c:4: * Copyright (C) 2008 - 2014 Xilinx, Inc.
spi-cadence.c:6: * based on Blackfin On-Chip SPI Driver (spi_bfin5xx.c)
spi-cadence.c:25:#define CDNS_SPI_NAME		"cdns-spi"
spi-cadence.c:62: * SPI Configuration Register - Baud rate and slave select
spi-cadence.c:103: * struct cdns_spi - This definition defines spi driver instance
spi-cadence.c:131:	return readl_relaxed(xspi->regs + offset);
spi-cadence.c:136:	writel_relaxed(val, xspi->regs + offset);
spi-cadence.c:140: * cdns_spi_init_hw - Initialize the hardware and configure the SPI controller
spi-cadence.c:154:	if (xspi->is_decoded_cs)
spi-cadence.c:175: * cdns_spi_chipselect - Select or deselect the chip select line
spi-cadence.c:181:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
spi-cadence.c:192:		if (!(xspi->is_decoded_cs))
spi-cadence.c:193:			ctrl_reg |= ((~(CDNS_SPI_SS0 << spi->chip_select)) <<
spi-cadence.c:197:			ctrl_reg |= (spi->chip_select << CDNS_SPI_SS_SHIFT) &
spi-cadence.c:205: * cdns_spi_config_clock_mode - Sets clock polarity and phase
spi-cadence.c:212:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
spi-cadence.c:219:	if (spi->mode & SPI_CPHA)
spi-cadence.c:221:	if (spi->mode & SPI_CPOL)
spi-cadence.c:240: * cdns_spi_config_clock_freq - Sets clock frequency
spi-cadence.c:256:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
spi-cadence.c:260:	frequency = clk_get_rate(xspi->ref_clk);
spi-cadence.c:265:	if (xspi->speed_hz != transfer->speed_hz) {
spi-cadence.c:269:		       (frequency / (2 << baud_rate_val)) > transfer->speed_hz)
spi-cadence.c:275:		xspi->speed_hz = frequency / (2 << baud_rate_val);
spi-cadence.c:281: * cdns_spi_setup_transfer - Configure SPI controller for specified transfer
spi-cadence.c:294:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
spi-cadence.c:298:	dev_dbg(&spi->dev, "%s, mode %d, %u bits/w, %u clock speed\n",
spi-cadence.c:299:		__func__, spi->mode, spi->bits_per_word,
spi-cadence.c:300:		xspi->speed_hz);
spi-cadence.c:306: * cdns_spi_fill_tx_fifo - Fills the TX FIFO with as many bytes as possible
spi-cadence.c:314:	       (xspi->tx_bytes > 0)) {
spi-cadence.c:315:		if (xspi->txbuf)
spi-cadence.c:317:				       *xspi->txbuf++);
spi-cadence.c:321:		xspi->tx_bytes--;
spi-cadence.c:327: * cdns_spi_irq - Interrupt service routine of the SPI controller
spi-cadence.c:336: * transferred is non-zero.
spi-cadence.c:353:		 * transferred is non-zero
spi-cadence.c:362:		trans_cnt = xspi->rx_bytes - xspi->tx_bytes;
spi-cadence.c:369:			if (xspi->rxbuf)
spi-cadence.c:370:				*xspi->rxbuf++ = data;
spi-cadence.c:372:			xspi->rx_bytes--;
spi-cadence.c:373:			trans_cnt--;
spi-cadence.c:376:		if (xspi->tx_bytes) {
spi-cadence.c:393:	cdns_spi_config_clock_mode(msg->spi);
spi-cadence.c:398: * cdns_transfer_one - Initiates the SPI transfer
spi-cadence.c:415:	xspi->txbuf = transfer->tx_buf;
spi-cadence.c:416:	xspi->rxbuf = transfer->rx_buf;
spi-cadence.c:417:	xspi->tx_bytes = transfer->len;
spi-cadence.c:418:	xspi->rx_bytes = transfer->len;
spi-cadence.c:426:	return transfer->len;
spi-cadence.c:430: * cdns_prepare_transfer_hardware - Prepares hardware for transfer.
spi-cadence.c:449: * cdns_unprepare_transfer_hardware - Relaxes hardware after transfer
spi-cadence.c:468: * cdns_spi_probe - Probe method for the SPI driver
spi-cadence.c:483:	master = spi_alloc_master(&pdev->dev, sizeof(*xspi));
spi-cadence.c:485:		return -ENOMEM;
spi-cadence.c:488:	master->dev.of_node = pdev->dev.of_node;
spi-cadence.c:492:	xspi->regs = devm_ioremap_resource(&pdev->dev, res);
spi-cadence.c:493:	if (IS_ERR(xspi->regs)) {
spi-cadence.c:494:		ret = PTR_ERR(xspi->regs);
spi-cadence.c:498:	xspi->pclk = devm_clk_get(&pdev->dev, "pclk");
spi-cadence.c:499:	if (IS_ERR(xspi->pclk)) {
spi-cadence.c:500:		dev_err(&pdev->dev, "pclk clock not found.\n");
spi-cadence.c:501:		ret = PTR_ERR(xspi->pclk);
spi-cadence.c:505:	xspi->ref_clk = devm_clk_get(&pdev->dev, "ref_clk");
spi-cadence.c:506:	if (IS_ERR(xspi->ref_clk)) {
spi-cadence.c:507:		dev_err(&pdev->dev, "ref_clk clock not found.\n");
spi-cadence.c:508:		ret = PTR_ERR(xspi->ref_clk);
spi-cadence.c:512:	ret = clk_prepare_enable(xspi->pclk);
spi-cadence.c:514:		dev_err(&pdev->dev, "Unable to enable APB clock.\n");
spi-cadence.c:518:	ret = clk_prepare_enable(xspi->ref_clk);
spi-cadence.c:520:		dev_err(&pdev->dev, "Unable to enable device clock.\n");
spi-cadence.c:524:	ret = of_property_read_u32(pdev->dev.of_node, "num-cs", &num_cs);
spi-cadence.c:526:		master->num_chipselect = CDNS_SPI_DEFAULT_NUM_CS;
spi-cadence.c:528:		master->num_chipselect = num_cs;
spi-cadence.c:530:	ret = of_property_read_u32(pdev->dev.of_node, "is-decoded-cs",
spi-cadence.c:531:				   &xspi->is_decoded_cs);
spi-cadence.c:533:		xspi->is_decoded_cs = 0;
spi-cadence.c:540:		ret = -ENXIO;
spi-cadence.c:541:		dev_err(&pdev->dev, "irq number is invalid\n");
spi-cadence.c:545:	ret = devm_request_irq(&pdev->dev, irq, cdns_spi_irq,
spi-cadence.c:546:			       0, pdev->name, master);
spi-cadence.c:548:		ret = -ENXIO;
spi-cadence.c:549:		dev_err(&pdev->dev, "request_irq failed\n");
spi-cadence.c:553:	master->prepare_transfer_hardware = cdns_prepare_transfer_hardware;
spi-cadence.c:554:	master->prepare_message = cdns_prepare_message;
spi-cadence.c:555:	master->transfer_one = cdns_transfer_one;
spi-cadence.c:556:	master->unprepare_transfer_hardware = cdns_unprepare_transfer_hardware;
spi-cadence.c:557:	master->set_cs = cdns_spi_chipselect;
spi-cadence.c:558:	master->mode_bits = SPI_CPOL | SPI_CPHA;
spi-cadence.c:561:	master->max_speed_hz = clk_get_rate(xspi->ref_clk) / 4;
spi-cadence.c:562:	xspi->speed_hz = master->max_speed_hz;
spi-cadence.c:564:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-cadence.c:568:		dev_err(&pdev->dev, "spi_register_master failed\n");
spi-cadence.c:575:	clk_disable_unprepare(xspi->ref_clk);
spi-cadence.c:577:	clk_disable_unprepare(xspi->pclk);
spi-cadence.c:584: * cdns_spi_remove - Remove method for the SPI driver
spi-cadence.c:601:	clk_disable_unprepare(xspi->ref_clk);
spi-cadence.c:602:	clk_disable_unprepare(xspi->pclk);
spi-cadence.c:610: * cdns_spi_suspend - Suspend method for the SPI driver
spi-cadence.c:627:	clk_disable_unprepare(xspi->ref_clk);
spi-cadence.c:629:	clk_disable_unprepare(xspi->pclk);
spi-cadence.c:635: * cdns_spi_resume - Resume method for the SPI driver
spi-cadence.c:650:	ret = clk_prepare_enable(xspi->pclk);
spi-cadence.c:656:	ret = clk_prepare_enable(xspi->ref_clk);
spi-cadence.c:659:		clk_disable(xspi->pclk);
spi-cadence.c:671:	{ .compatible = "xlnx,zynq-spi-r1p6" },
spi-cadence.c:672:	{ .compatible = "cdns,spi-r1p6" },
spi-cadence.c:677:/* cdns_spi_driver - This structure defines the SPI subsystem platform driver */
spi-dw.h:146:	return __raw_readl(dws->regs + offset);
spi-dw.h:151:	return __raw_readw(dws->regs + offset);
spi-dw.h:156:	__raw_writel(val, dws->regs + offset);
spi-dw.h:161:	__raw_writew(val, dws->regs + offset);
spi-dw.h:166:	switch (dws->reg_io_width) {
spi-dw.h:177:	switch (dws->reg_io_width) {
spi-dw.h:217: * This does disable the SPI controller, interrupts, and re-enable the
spi-orion.c:5: * Copyright (C) 2007-2008 Marvell Ltd.
spi-orion.c:71:	 * have both is for managing the armada-370-spi case with old
spi-orion.c:90:	return orion_spi->base + reg;
spi-orion.c:124:	orion_spi = spi_master_get_devdata(spi->master);
spi-orion.c:125:	devdata = orion_spi->devdata;
spi-orion.c:127:	tclk_hz = clk_get_rate(orion_spi->clk);
spi-orion.c:129:	if (devdata->typ == ARMADA_SPI) {
spi-orion.c:157:			sppr = fls(divider) - 4;
spi-orion.c:164:			divider = (divider + two_pow_sppr - 1) & -two_pow_sppr;
spi-orion.c:173:			sppr = fls(divider) - 4;
spi-orion.c:182:				return -EINVAL;
spi-orion.c:196:			return -EINVAL;
spi-orion.c:206:	reg = ((reg & ~devdata->prescale_mask) | prescale);
spi-orion.c:218:	orion_spi = spi_master_get_devdata(spi->master);
spi-orion.c:222:	if (spi->mode & SPI_CPOL)
spi-orion.c:224:	if (spi->mode & SPI_CPHA)
spi-orion.c:235:	orion_spi = spi_master_get_devdata(spi->master);
spi-orion.c:238:	 * Erratum description: (Erratum NO. FE-9144572) The device
spi-orion.c:254:	if (clk_get_rate(orion_spi->clk) == 250000000 &&
spi-orion.c:255:			speed == 50000000 && spi->mode & SPI_CPOL &&
spi-orion.c:256:			spi->mode & SPI_CPHA)
spi-orion.c:271:	unsigned int speed = spi->max_speed_hz;
spi-orion.c:272:	unsigned int bits_per_word = spi->bits_per_word;
spi-orion.c:275:	orion_spi = spi_master_get_devdata(spi->master);
spi-orion.c:277:	if ((t != NULL) && t->speed_hz)
spi-orion.c:278:		speed = t->speed_hz;
spi-orion.c:280:	if ((t != NULL) && t->bits_per_word)
spi-orion.c:281:		bits_per_word = t->bits_per_word;
spi-orion.c:285:	if (orion_spi->devdata->is_errata_50mhz_ac)
spi-orion.c:306:	orion_spi = spi_master_get_devdata(spi->master);
spi-orion.c:310:				ORION_SPI_CS(spi->chip_select));
spi-orion.c:330:	return -1;
spi-orion.c:340:	orion_spi = spi_master_get_devdata(spi->master);
spi-orion.c:354:		dev_err(&spi->dev, "TXS timed out\n");
spi-orion.c:355:		return -1;
spi-orion.c:371:	orion_spi = spi_master_get_devdata(spi->master);
spi-orion.c:385:		dev_err(&spi->dev, "TXS timed out\n");
spi-orion.c:386:		return -1;
spi-orion.c:401:	word_len = spi->bits_per_word;
spi-orion.c:402:	count = xfer->len;
spi-orion.c:405:		const u8 *tx = xfer->tx_buf;
spi-orion.c:406:		u8 *rx = xfer->rx_buf;
spi-orion.c:411:			count--;
spi-orion.c:414:		const u16 *tx = xfer->tx_buf;
spi-orion.c:415:		u16 *rx = xfer->rx_buf;
spi-orion.c:420:			count -= 2;
spi-orion.c:425:	return xfer->len - count;
spi-orion.c:438:	if (t->len)
spi-orion.c:495:		.compatible = "marvell,orion-spi",
spi-orion.c:499:		.compatible = "marvell,armada-370-spi",
spi-orion.c:503:		.compatible = "marvell,armada-375-spi",
spi-orion.c:507:		.compatible = "marvell,armada-380-spi",
spi-orion.c:511:		.compatible = "marvell,armada-390-spi",
spi-orion.c:515:		.compatible = "marvell,armada-xp-spi",
spi-orion.c:533:	master = spi_alloc_master(&pdev->dev, sizeof(*spi));
spi-orion.c:535:		dev_dbg(&pdev->dev, "master allocation failed\n");
spi-orion.c:536:		return -ENOMEM;
spi-orion.c:539:	if (pdev->id != -1)
spi-orion.c:540:		master->bus_num = pdev->id;
spi-orion.c:541:	if (pdev->dev.of_node) {
spi-orion.c:544:		if (!of_property_read_u32(pdev->dev.of_node, "cell-index",
spi-orion.c:546:			master->bus_num = cell_index;
spi-orion.c:550:	master->mode_bits = SPI_CPHA | SPI_CPOL;
spi-orion.c:551:	master->set_cs = orion_spi_set_cs;
spi-orion.c:552:	master->transfer_one = orion_spi_transfer_one;
spi-orion.c:553:	master->num_chipselect = ORION_NUM_CHIPSELECTS;
spi-orion.c:554:	master->setup = orion_spi_setup;
spi-orion.c:555:	master->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);
spi-orion.c:556:	master->auto_runtime_pm = true;
spi-orion.c:561:	spi->master = master;
spi-orion.c:563:	of_id = of_match_device(orion_spi_of_match_table, &pdev->dev);
spi-orion.c:564:	devdata = (of_id) ? of_id->data : &orion_spi_dev_data;
spi-orion.c:565:	spi->devdata = devdata;
spi-orion.c:567:	spi->clk = devm_clk_get(&pdev->dev, NULL);
spi-orion.c:568:	if (IS_ERR(spi->clk)) {
spi-orion.c:569:		status = PTR_ERR(spi->clk);
spi-orion.c:573:	status = clk_prepare_enable(spi->clk);
spi-orion.c:577:	tclk_hz = clk_get_rate(spi->clk);
spi-orion.c:580:	 * With old device tree, armada-370-spi could be used with
spi-orion.c:586:	if (of_device_is_compatible(pdev->dev.of_node,
spi-orion.c:587:					"marvell,armada-370-spi"))
spi-orion.c:588:		master->max_speed_hz = min(devdata->max_hz,
spi-orion.c:589:				DIV_ROUND_UP(tclk_hz, devdata->min_divisor));
spi-orion.c:590:	else if (devdata->min_divisor)
spi-orion.c:591:		master->max_speed_hz =
spi-orion.c:592:			DIV_ROUND_UP(tclk_hz, devdata->min_divisor);
spi-orion.c:594:		master->max_speed_hz = devdata->max_hz;
spi-orion.c:595:	master->min_speed_hz = DIV_ROUND_UP(tclk_hz, devdata->max_divisor);
spi-orion.c:598:	spi->base = devm_ioremap_resource(&pdev->dev, r);
spi-orion.c:599:	if (IS_ERR(spi->base)) {
spi-orion.c:600:		status = PTR_ERR(spi->base);
spi-orion.c:604:	pm_runtime_set_active(&pdev->dev);
spi-orion.c:605:	pm_runtime_use_autosuspend(&pdev->dev);
spi-orion.c:606:	pm_runtime_set_autosuspend_delay(&pdev->dev, SPI_AUTOSUSPEND_TIMEOUT);
spi-orion.c:607:	pm_runtime_enable(&pdev->dev);
spi-orion.c:613:	pm_runtime_mark_last_busy(&pdev->dev);
spi-orion.c:614:	pm_runtime_put_autosuspend(&pdev->dev);
spi-orion.c:616:	master->dev.of_node = pdev->dev.of_node;
spi-orion.c:624:	pm_runtime_disable(&pdev->dev);
spi-orion.c:626:	clk_disable_unprepare(spi->clk);
spi-orion.c:638:	pm_runtime_get_sync(&pdev->dev);
spi-orion.c:639:	clk_disable_unprepare(spi->clk);
spi-orion.c:642:	pm_runtime_disable(&pdev->dev);
spi-orion.c:655:	clk_disable_unprepare(spi->clk);
spi-orion.c:664:	return clk_prepare_enable(spi->clk);
spi-dw-mmio.c:2: * Memory-mapped interface driver for DW SPI Core
spi-dw-mmio.c:24:#include "spi-dw.h"
spi-dw-mmio.c:41:	dwsmmio = devm_kzalloc(&pdev->dev, sizeof(struct dw_spi_mmio),
spi-dw-mmio.c:44:		return -ENOMEM;
spi-dw-mmio.c:46:	dws = &dwsmmio->dws;
spi-dw-mmio.c:51:		dev_err(&pdev->dev, "no mem resource?\n");
spi-dw-mmio.c:52:		return -EINVAL;
spi-dw-mmio.c:55:	dws->regs = devm_ioremap_resource(&pdev->dev, mem);
spi-dw-mmio.c:56:	if (IS_ERR(dws->regs)) {
spi-dw-mmio.c:57:		dev_err(&pdev->dev, "SPI region map failed\n");
spi-dw-mmio.c:58:		return PTR_ERR(dws->regs);
spi-dw-mmio.c:61:	dws->irq = platform_get_irq(pdev, 0);
spi-dw-mmio.c:62:	if (dws->irq < 0) {
spi-dw-mmio.c:63:		dev_err(&pdev->dev, "no irq resource?\n");
spi-dw-mmio.c:64:		return dws->irq; /* -ENXIO */
spi-dw-mmio.c:67:	dwsmmio->clk = devm_clk_get(&pdev->dev, NULL);
spi-dw-mmio.c:68:	if (IS_ERR(dwsmmio->clk))
spi-dw-mmio.c:69:		return PTR_ERR(dwsmmio->clk);
spi-dw-mmio.c:70:	ret = clk_prepare_enable(dwsmmio->clk);
spi-dw-mmio.c:74:	dws->bus_num = pdev->id;
spi-dw-mmio.c:76:	dws->max_freq = clk_get_rate(dwsmmio->clk);
spi-dw-mmio.c:78:	device_property_read_u32(&pdev->dev, "reg-io-width", &dws->reg_io_width);
spi-dw-mmio.c:82:	device_property_read_u32(&pdev->dev, "num-cs", &num_cs);
spi-dw-mmio.c:84:	dws->num_cs = num_cs;
spi-dw-mmio.c:86:	if (pdev->dev.of_node) {
spi-dw-mmio.c:89:		for (i = 0; i < dws->num_cs; i++) {
spi-dw-mmio.c:90:			int cs_gpio = of_get_named_gpio(pdev->dev.of_node,
spi-dw-mmio.c:91:					"cs-gpios", i);
spi-dw-mmio.c:93:			if (cs_gpio == -EPROBE_DEFER) {
spi-dw-mmio.c:99:				ret = devm_gpio_request(&pdev->dev, cs_gpio,
spi-dw-mmio.c:100:						dev_name(&pdev->dev));
spi-dw-mmio.c:107:	ret = dw_spi_add_host(&pdev->dev, dws);
spi-dw-mmio.c:115:	clk_disable_unprepare(dwsmmio->clk);
spi-dw-mmio.c:123:	dw_spi_remove_host(&dwsmmio->dws);
spi-dw-mmio.c:124:	clk_disable_unprepare(dwsmmio->clk);
spi-dw-mmio.c:130:	{ .compatible = "snps,dw-apb-ssi", },
spi-dw-mmio.c:145:MODULE_AUTHOR("Jean-Hugues Deschenes <jean-hugues.deschenes@octasic.com>");
spi-dw-mmio.c:146:MODULE_DESCRIPTION("Memory-mapped I/O interface driver for DW SPI Core");
spi-bcm63xx-hsspi.c:4: * Copyright 2000-2010 Broadcom Corporation
spi-bcm63xx-hsspi.c:5: * Copyright 2012-2013 Jonas Gorski <jogo@openwrt.org>
spi-bcm63xx-hsspi.c:17:#include <linux/dma-mapping.h>
spi-bcm63xx-hsspi.c:114:	mutex_lock(&bs->bus_mutex);
spi-bcm63xx-hsspi.c:115:	reg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);
spi-bcm63xx-hsspi.c:118:	if (active == !(bs->cs_polarity & BIT(cs)))
spi-bcm63xx-hsspi.c:121:	__raw_writel(reg, bs->regs + HSSPI_GLOBAL_CTRL_REG);
spi-bcm63xx-hsspi.c:122:	mutex_unlock(&bs->bus_mutex);
spi-bcm63xx-hsspi.c:128:	unsigned profile = spi->chip_select;
spi-bcm63xx-hsspi.c:131:	reg = DIV_ROUND_UP(2048, DIV_ROUND_UP(bs->speed_hz, hz));
spi-bcm63xx-hsspi.c:133:		     bs->regs + HSSPI_PROFILE_CLK_CTRL_REG(profile));
spi-bcm63xx-hsspi.c:135:	reg = __raw_readl(bs->regs + HSSPI_PROFILE_SIGNAL_CTRL_REG(profile));
spi-bcm63xx-hsspi.c:140:	__raw_writel(reg, bs->regs + HSSPI_PROFILE_SIGNAL_CTRL_REG(profile));
spi-bcm63xx-hsspi.c:142:	mutex_lock(&bs->bus_mutex);
spi-bcm63xx-hsspi.c:144:	reg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);
spi-bcm63xx-hsspi.c:146:	if (spi->mode & SPI_CPOL)
spi-bcm63xx-hsspi.c:148:	__raw_writel(reg, bs->regs + HSSPI_GLOBAL_CTRL_REG);
spi-bcm63xx-hsspi.c:149:	mutex_unlock(&bs->bus_mutex);
spi-bcm63xx-hsspi.c:154:	struct bcm63xx_hsspi *bs = spi_master_get_devdata(spi->master);
spi-bcm63xx-hsspi.c:155:	unsigned chip_select = spi->chip_select;
spi-bcm63xx-hsspi.c:157:	int pending = t->len;
spi-bcm63xx-hsspi.c:159:	const u8 *tx = t->tx_buf;
spi-bcm63xx-hsspi.c:160:	u8 *rx = t->rx_buf;
spi-bcm63xx-hsspi.c:162:	bcm63xx_hsspi_set_clk(bs, spi, t->speed_hz);
spi-bcm63xx-hsspi.c:163:	bcm63xx_hsspi_set_cs(bs, spi->chip_select, true);
spi-bcm63xx-hsspi.c:173:		step_size -= HSSPI_OPCODE_LEN;
spi-bcm63xx-hsspi.c:175:	if ((opcode == HSSPI_OP_READ && t->rx_nbits == SPI_NBITS_DUAL) ||
spi-bcm63xx-hsspi.c:176:	    (opcode == HSSPI_OP_WRITE && t->tx_nbits == SPI_NBITS_DUAL))
spi-bcm63xx-hsspi.c:181:		     bs->regs + HSSPI_PROFILE_MODE_CTRL_REG(chip_select));
spi-bcm63xx-hsspi.c:186:		reinit_completion(&bs->done);
spi-bcm63xx-hsspi.c:188:			memcpy_toio(bs->fifo + HSSPI_OPCODE_LEN, tx, curr_step);
spi-bcm63xx-hsspi.c:192:		__raw_writew(opcode | curr_step, bs->fifo);
spi-bcm63xx-hsspi.c:196:			     bs->regs + HSSPI_INT_MASK_REG);
spi-bcm63xx-hsspi.c:202:			     bs->regs + HSSPI_PINGPONG_COMMAND_REG(0));
spi-bcm63xx-hsspi.c:204:		if (wait_for_completion_timeout(&bs->done, HZ) == 0) {
spi-bcm63xx-hsspi.c:205:			dev_err(&bs->pdev->dev, "transfer timed out!\n");
spi-bcm63xx-hsspi.c:206:			return -ETIMEDOUT;
spi-bcm63xx-hsspi.c:210:			memcpy_fromio(rx, bs->fifo, curr_step);
spi-bcm63xx-hsspi.c:214:		pending -= curr_step;
spi-bcm63xx-hsspi.c:222:	struct bcm63xx_hsspi *bs = spi_master_get_devdata(spi->master);
spi-bcm63xx-hsspi.c:225:	reg = __raw_readl(bs->regs +
spi-bcm63xx-hsspi.c:226:			  HSSPI_PROFILE_SIGNAL_CTRL_REG(spi->chip_select));
spi-bcm63xx-hsspi.c:228:	if (spi->mode & SPI_CPHA)
spi-bcm63xx-hsspi.c:232:	__raw_writel(reg, bs->regs +
spi-bcm63xx-hsspi.c:233:		     HSSPI_PROFILE_SIGNAL_CTRL_REG(spi->chip_select));
spi-bcm63xx-hsspi.c:235:	mutex_lock(&bs->bus_mutex);
spi-bcm63xx-hsspi.c:236:	reg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);
spi-bcm63xx-hsspi.c:239:	if ((reg & GLOBAL_CTRL_CS_POLARITY_MASK) == bs->cs_polarity) {
spi-bcm63xx-hsspi.c:240:		if (spi->mode & SPI_CS_HIGH)
spi-bcm63xx-hsspi.c:241:			reg |= BIT(spi->chip_select);
spi-bcm63xx-hsspi.c:243:			reg &= ~BIT(spi->chip_select);
spi-bcm63xx-hsspi.c:244:		__raw_writel(reg, bs->regs + HSSPI_GLOBAL_CTRL_REG);
spi-bcm63xx-hsspi.c:247:	if (spi->mode & SPI_CS_HIGH)
spi-bcm63xx-hsspi.c:248:		bs->cs_polarity |= BIT(spi->chip_select);
spi-bcm63xx-hsspi.c:250:		bs->cs_polarity &= ~BIT(spi->chip_select);
spi-bcm63xx-hsspi.c:252:	mutex_unlock(&bs->bus_mutex);
spi-bcm63xx-hsspi.c:262:	struct spi_device *spi = msg->spi;
spi-bcm63xx-hsspi.c:263:	int status = -EINVAL;
spi-bcm63xx-hsspi.c:281:	dummy_cs = !spi->chip_select;
spi-bcm63xx-hsspi.c:284:	list_for_each_entry(t, &msg->transfers, transfer_list) {
spi-bcm63xx-hsspi.c:289:		msg->actual_length += t->len;
spi-bcm63xx-hsspi.c:291:		if (t->delay_usecs)
spi-bcm63xx-hsspi.c:292:			udelay(t->delay_usecs);
spi-bcm63xx-hsspi.c:294:		if (t->cs_change)
spi-bcm63xx-hsspi.c:295:			bcm63xx_hsspi_set_cs(bs, spi->chip_select, false);
spi-bcm63xx-hsspi.c:298:	mutex_lock(&bs->bus_mutex);
spi-bcm63xx-hsspi.c:299:	reg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);
spi-bcm63xx-hsspi.c:301:	reg |= bs->cs_polarity;
spi-bcm63xx-hsspi.c:302:	__raw_writel(reg, bs->regs + HSSPI_GLOBAL_CTRL_REG);
spi-bcm63xx-hsspi.c:303:	mutex_unlock(&bs->bus_mutex);
spi-bcm63xx-hsspi.c:305:	msg->status = status;
spi-bcm63xx-hsspi.c:315:	if (__raw_readl(bs->regs + HSSPI_INT_STATUS_MASKED_REG) == 0)
spi-bcm63xx-hsspi.c:318:	__raw_writel(HSSPI_INT_CLEAR_ALL, bs->regs + HSSPI_INT_STATUS_REG);
spi-bcm63xx-hsspi.c:319:	__raw_writel(0, bs->regs + HSSPI_INT_MASK_REG);
spi-bcm63xx-hsspi.c:321:	complete(&bs->done);
spi-bcm63xx-hsspi.c:332:	struct device *dev = &pdev->dev;
spi-bcm63xx-hsspi.c:355:		return -EINVAL;
spi-bcm63xx-hsspi.c:361:	master = spi_alloc_master(&pdev->dev, sizeof(*bs));
spi-bcm63xx-hsspi.c:363:		ret = -ENOMEM;
spi-bcm63xx-hsspi.c:368:	bs->pdev = pdev;
spi-bcm63xx-hsspi.c:369:	bs->clk = clk;
spi-bcm63xx-hsspi.c:370:	bs->regs = regs;
spi-bcm63xx-hsspi.c:371:	bs->speed_hz = rate;
spi-bcm63xx-hsspi.c:372:	bs->fifo = (u8 __iomem *)(bs->regs + HSSPI_FIFO_REG(0));
spi-bcm63xx-hsspi.c:374:	mutex_init(&bs->bus_mutex);
spi-bcm63xx-hsspi.c:375:	init_completion(&bs->done);
spi-bcm63xx-hsspi.c:377:	master->bus_num = HSSPI_BUS_NUM;
spi-bcm63xx-hsspi.c:378:	master->num_chipselect = 8;
spi-bcm63xx-hsspi.c:379:	master->setup = bcm63xx_hsspi_setup;
spi-bcm63xx-hsspi.c:380:	master->transfer_one_message = bcm63xx_hsspi_transfer_one;
spi-bcm63xx-hsspi.c:381:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH |
spi-bcm63xx-hsspi.c:383:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-bcm63xx-hsspi.c:384:	master->auto_runtime_pm = true;
spi-bcm63xx-hsspi.c:389:	__raw_writel(0, bs->regs + HSSPI_INT_MASK_REG);
spi-bcm63xx-hsspi.c:392:	__raw_writel(HSSPI_INT_CLEAR_ALL, bs->regs + HSSPI_INT_STATUS_REG);
spi-bcm63xx-hsspi.c:395:	reg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);
spi-bcm63xx-hsspi.c:396:	bs->cs_polarity = reg & GLOBAL_CTRL_CS_POLARITY_MASK;
spi-bcm63xx-hsspi.c:398:		     bs->regs + HSSPI_GLOBAL_CTRL_REG);
spi-bcm63xx-hsspi.c:401:			       pdev->name, bs);
spi-bcm63xx-hsspi.c:427:	__raw_writel(0, bs->regs + HSSPI_INT_MASK_REG);
spi-bcm63xx-hsspi.c:428:	clk_disable_unprepare(bs->clk);
spi-bcm63xx-hsspi.c:440:	clk_disable_unprepare(bs->clk);
spi-bcm63xx-hsspi.c:451:	ret = clk_prepare_enable(bs->clk);
spi-bcm63xx-hsspi.c:466:		.name	= "bcm63xx-hsspi",
spi-mpc512x-psc.c:6: *	Hongjun Chen <hong-jun.chen@freescale.com>
spi-mpc512x-psc.c:44:	switch (mps->type) {						\
spi-mpc512x-psc.c:46:			struct mpc52xx_psc __iomem *psc = mps->psc;	\
spi-mpc512x-psc.c:47:			__ret = &psc->regname;				\
spi-mpc512x-psc.c:51:			struct mpc5125_psc __iomem *psc = mps->psc;	\
spi-mpc512x-psc.c:52:			__ret = &psc->regname;				\
spi-mpc512x-psc.c:86:	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
spi-mpc512x-psc.c:88:	cs->speed_hz = (t && t->speed_hz)
spi-mpc512x-psc.c:89:	    ? t->speed_hz : spi->max_speed_hz;
spi-mpc512x-psc.c:90:	cs->bits_per_word = (t && t->bits_per_word)
spi-mpc512x-psc.c:91:	    ? t->bits_per_word : spi->bits_per_word;
spi-mpc512x-psc.c:92:	cs->bits_per_word = ((cs->bits_per_word + 7) / 8) * 8;
spi-mpc512x-psc.c:98:	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
spi-mpc512x-psc.c:99:	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
spi-mpc512x-psc.c:108:	if (spi->mode & SPI_CPHA)
spi-mpc512x-psc.c:113:	if (spi->mode & SPI_CPOL)
spi-mpc512x-psc.c:118:	if (spi->mode & SPI_LSB_FIRST)
spi-mpc512x-psc.c:126:	speed = cs->speed_hz;
spi-mpc512x-psc.c:129:	bclkdiv = (mps->mclk_rate / speed) - 1;
spi-mpc512x-psc.c:133:	mps->bits_per_word = cs->bits_per_word;
spi-mpc512x-psc.c:135:	if (mps->cs_control && gpio_is_valid(spi->cs_gpio))
spi-mpc512x-psc.c:136:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 1 : 0);
spi-mpc512x-psc.c:141:	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
spi-mpc512x-psc.c:143:	if (mps->cs_control && gpio_is_valid(spi->cs_gpio))
spi-mpc512x-psc.c:144:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 0 : 1);
spi-mpc512x-psc.c:156:	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
spi-mpc512x-psc.c:157:	struct mpc512x_psc_fifo __iomem *fifo = mps->fifo;
spi-mpc512x-psc.c:158:	size_t tx_len = t->len;
spi-mpc512x-psc.c:159:	size_t rx_len = t->len;
spi-mpc512x-psc.c:160:	u8 *tx_buf = (u8 *)t->tx_buf;
spi-mpc512x-psc.c:161:	u8 *rx_buf = (u8 *)t->rx_buf;
spi-mpc512x-psc.c:163:	if (!tx_buf && !rx_buf && t->len)
spi-mpc512x-psc.c:164:		return -EINVAL;
spi-mpc512x-psc.c:177:		fifosz = MPC512x_PSC_FIFO_SZ(in_be32(&fifo->txsz));
spi-mpc512x-psc.c:179:		fifosz = MPC512x_PSC_FIFO_SZ(in_be32(&fifo->rxsz));
spi-mpc512x-psc.c:180:		fifosz -= in_be32(&fifo->rxcnt) + 1;
spi-mpc512x-psc.c:185:			while (txcount-- > 0) {
spi-mpc512x-psc.c:187:				if (tx_len == EOFBYTE && t->cs_change)
spi-mpc512x-psc.c:188:					setbits32(&fifo->txcmd,
spi-mpc512x-psc.c:190:				out_8(&fifo->txdata_8, data);
spi-mpc512x-psc.c:191:				tx_len--;
spi-mpc512x-psc.c:195:			reinit_completion(&mps->txisrdone);
spi-mpc512x-psc.c:196:			out_be32(&fifo->txisr, MPC512x_PSC_FIFO_EMPTY);
spi-mpc512x-psc.c:197:			out_be32(&fifo->tximr, MPC512x_PSC_FIFO_EMPTY);
spi-mpc512x-psc.c:198:			wait_for_completion(&mps->txisrdone);
spi-mpc512x-psc.c:216:			 * the FIFO while we read from it -- we'll return
spi-mpc512x-psc.c:220:			fifosz = in_be32(&fifo->rxcnt);
spi-mpc512x-psc.c:222:			while (rxcount-- > 0) {
spi-mpc512x-psc.c:223:				data = in_8(&fifo->rxdata_8);
spi-mpc512x-psc.c:226:				rx_len--;
spi-mpc512x-psc.c:242:			 * is still pending -- that's a transient situation
spi-mpc512x-psc.c:267:		} while (--rxtries > 0);
spi-mpc512x-psc.c:273:			rxcount = in_be32(&fifo->rxcnt);
spi-mpc512x-psc.c:274:			dev_warn(&spi->dev,
spi-mpc512x-psc.c:285:			while (in_be32(&fifo->rxcnt))
spi-mpc512x-psc.c:286:				in_8(&fifo->rxdata_8);
spi-mpc512x-psc.c:301:	spi = m->spi;
spi-mpc512x-psc.c:304:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-mpc512x-psc.c:311:		cs_change = t->cs_change;
spi-mpc512x-psc.c:316:		m->actual_length += t->len;
spi-mpc512x-psc.c:318:		if (t->delay_usecs)
spi-mpc512x-psc.c:319:			udelay(t->delay_usecs);
spi-mpc512x-psc.c:325:	m->status = status;
spi-mpc512x-psc.c:326:	if (m->complete)
spi-mpc512x-psc.c:327:		m->complete(m->context);
spi-mpc512x-psc.c:342:	dev_dbg(&master->dev, "%s()\n", __func__);
spi-mpc512x-psc.c:357:	struct mpc512x_psc_fifo __iomem *fifo = mps->fifo;
spi-mpc512x-psc.c:359:	dev_dbg(&master->dev, "%s()\n", __func__);
spi-mpc512x-psc.c:363:	out_be32(&fifo->tximr, 0);
spi-mpc512x-psc.c:370:	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
spi-mpc512x-psc.c:373:	if (spi->bits_per_word % 8)
spi-mpc512x-psc.c:374:		return -EINVAL;
spi-mpc512x-psc.c:379:			return -ENOMEM;
spi-mpc512x-psc.c:381:		if (gpio_is_valid(spi->cs_gpio)) {
spi-mpc512x-psc.c:382:			ret = gpio_request(spi->cs_gpio, dev_name(&spi->dev));
spi-mpc512x-psc.c:384:				dev_err(&spi->dev, "can't get CS gpio: %d\n",
spi-mpc512x-psc.c:389:			gpio_direction_output(spi->cs_gpio,
spi-mpc512x-psc.c:390:					spi->mode & SPI_CS_HIGH ? 0 : 1);
spi-mpc512x-psc.c:393:		spi->controller_state = cs;
spi-mpc512x-psc.c:396:	cs->bits_per_word = spi->bits_per_word;
spi-mpc512x-psc.c:397:	cs->speed_hz = spi->max_speed_hz;
spi-mpc512x-psc.c:404:	if (gpio_is_valid(spi->cs_gpio))
spi-mpc512x-psc.c:405:		gpio_free(spi->cs_gpio);
spi-mpc512x-psc.c:406:	kfree(spi->controller_state);
spi-mpc512x-psc.c:412:	struct mpc512x_psc_fifo __iomem *fifo = mps->fifo;
spi-mpc512x-psc.c:427:	out_be32(&fifo->tximr, 0);
spi-mpc512x-psc.c:428:	out_be32(&fifo->rximr, 0);
spi-mpc512x-psc.c:431:	/*out_be32(&fifo->txsz, 0x0fe00004);*/
spi-mpc512x-psc.c:432:	/*out_be32(&fifo->rxsz, 0x0ff00004);*/
spi-mpc512x-psc.c:434:	sicr =	0x01000000 |	/* SIM = 0001 -- 8 bit */
spi-mpc512x-psc.c:435:		0x00800000 |	/* GenClk = 1 -- internal clk */
spi-mpc512x-psc.c:437:		0x00004000 |	/* MSTR = 1   -- SPI master */
spi-mpc512x-psc.c:438:		0x00000800;	/* UseEOF = 1 -- SS low until EOF */
spi-mpc512x-psc.c:445:	bclkdiv = (mps->mclk_rate / speed) - 1;
spi-mpc512x-psc.c:454:	out_be32(&fifo->rxalarm, 0xfff);
spi-mpc512x-psc.c:455:	out_be32(&fifo->txalarm, 0);
spi-mpc512x-psc.c:458:	out_be32(&fifo->rxcmd,
spi-mpc512x-psc.c:460:	out_be32(&fifo->txcmd,
spi-mpc512x-psc.c:463:	mps->bits_per_word = 8;
spi-mpc512x-psc.c:471:	struct mpc512x_psc_fifo __iomem *fifo = mps->fifo;
spi-mpc512x-psc.c:474:	if (in_be32(&fifo->txisr) &
spi-mpc512x-psc.c:475:	    in_be32(&fifo->tximr) & MPC512x_PSC_FIFO_EMPTY) {
spi-mpc512x-psc.c:476:		out_be32(&fifo->txisr, MPC512x_PSC_FIFO_EMPTY);
spi-mpc512x-psc.c:477:		out_be32(&fifo->tximr, 0);
spi-mpc512x-psc.c:478:		complete(&mps->txisrdone);
spi-mpc512x-psc.c:486:	gpio_set_value(spi->cs_gpio, onoff);
spi-mpc512x-psc.c:501:		return -ENOMEM;
spi-mpc512x-psc.c:505:	mps->type = (int)of_device_get_match_data(dev);
spi-mpc512x-psc.c:506:	mps->irq = irq;
spi-mpc512x-psc.c:509:		mps->cs_control = mpc512x_spi_cs_control;
spi-mpc512x-psc.c:511:		mps->cs_control = pdata->cs_control;
spi-mpc512x-psc.c:512:		master->bus_num = pdata->bus_num;
spi-mpc512x-psc.c:513:		master->num_chipselect = pdata->max_chipselect;
spi-mpc512x-psc.c:516:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;
spi-mpc512x-psc.c:517:	master->setup = mpc512x_psc_spi_setup;
spi-mpc512x-psc.c:518:	master->prepare_transfer_hardware = mpc512x_psc_spi_prep_xfer_hw;
spi-mpc512x-psc.c:519:	master->transfer_one_message = mpc512x_psc_spi_msg_xfer;
spi-mpc512x-psc.c:520:	master->unprepare_transfer_hardware = mpc512x_psc_spi_unprep_xfer_hw;
spi-mpc512x-psc.c:521:	master->cleanup = mpc512x_psc_spi_cleanup;
spi-mpc512x-psc.c:522:	master->dev.of_node = dev->of_node;
spi-mpc512x-psc.c:527:		ret = -EFAULT;
spi-mpc512x-psc.c:530:	mps->psc = tempp;
spi-mpc512x-psc.c:531:	mps->fifo =
spi-mpc512x-psc.c:533:	ret = devm_request_irq(dev, mps->irq, mpc512x_psc_spi_isr, IRQF_SHARED,
spi-mpc512x-psc.c:534:				"mpc512x-psc-spi", mps);
spi-mpc512x-psc.c:537:	init_completion(&mps->txisrdone);
spi-mpc512x-psc.c:547:	mps->clk_mclk = clk;
spi-mpc512x-psc.c:548:	mps->mclk_rate = clk_get_rate(clk);
spi-mpc512x-psc.c:558:	mps->clk_ipg = clk;
spi-mpc512x-psc.c:571:	clk_disable_unprepare(mps->clk_ipg);
spi-mpc512x-psc.c:573:	clk_disable_unprepare(mps->clk_mclk);
spi-mpc512x-psc.c:585:	clk_disable_unprepare(mps->clk_mclk);
spi-mpc512x-psc.c:586:	clk_disable_unprepare(mps->clk_ipg);
spi-mpc512x-psc.c:596:	regaddr_p = of_get_address(op->dev.of_node, 0, &size64, NULL);
spi-mpc512x-psc.c:598:		dev_err(&op->dev, "Invalid PSC address\n");
spi-mpc512x-psc.c:599:		return -EINVAL;
spi-mpc512x-psc.c:601:	regaddr64 = of_translate_address(op->dev.of_node, regaddr_p);
spi-mpc512x-psc.c:603:	return mpc512x_psc_spi_do_probe(&op->dev, (u32) regaddr64, (u32) size64,
spi-mpc512x-psc.c:604:				irq_of_parse_and_map(op->dev.of_node, 0));
spi-mpc512x-psc.c:609:	return mpc512x_psc_spi_do_remove(&op->dev);
spi-mpc512x-psc.c:613:	{ .compatible = "fsl,mpc5121-psc-spi", .data = (void *)TYPE_MPC5121 },
spi-mpc512x-psc.c:614:	{ .compatible = "fsl,mpc5125-psc-spi", .data = (void *)TYPE_MPC5125 },
spi-mpc512x-psc.c:624:		.name = "mpc512x-psc-spi",
spi-efm32.c:2: * Copyright (C) 2012-2013 Uwe Kleine-Koenig for Pengutronix
spi-efm32.c:19:#include <linux/platform_data/efm32-spi.h>
spi-efm32.c:21:#define DRIVER_NAME "efm32-spi"
spi-efm32.c:34:#define REG_FRAME_DATABITS(n)		((n) - 3)
spi-efm32.c:93:#define ddata_to_dev(ddata)	(&(ddata->bitbang.master->dev))
spi-efm32.c:100:	writel_relaxed(value, ddata->base + offset);
spi-efm32.c:105:	return readl_relaxed(ddata->base + offset);
spi-efm32.c:110:	struct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);
spi-efm32.c:111:	int value = !(spi->mode & SPI_CS_HIGH) == !(is_on == BITBANG_CS_ACTIVE);
spi-efm32.c:113:	gpio_set_value(ddata->csgpio[spi->chip_select], value);
spi-efm32.c:119:	struct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);
spi-efm32.c:121:	unsigned bpw = t->bits_per_word ?: spi->bits_per_word;
spi-efm32.c:122:	unsigned speed = t->speed_hz ?: spi->max_speed_hz;
spi-efm32.c:123:	unsigned long clkfreq = clk_get_rate(ddata->clk);
spi-efm32.c:127:			(spi->mode & SPI_CPHA ? REG_CTRL_CLKPHA : 0) |
spi-efm32.c:128:			(spi->mode & SPI_CPOL ? REG_CTRL_CLKPOL : 0), REG_CTRL);
spi-efm32.c:136:		clkdiv = 64 * (DIV_ROUND_UP(2 * clkfreq, speed) - 4);
spi-efm32.c:139:		return -EINVAL;
spi-efm32.c:152:	if (ddata->tx_buf) {
spi-efm32.c:153:		val = *ddata->tx_buf;
spi-efm32.c:154:		ddata->tx_buf++;
spi-efm32.c:157:	ddata->tx_len--;
spi-efm32.c:167:	if (ddata->rx_buf) {
spi-efm32.c:168:		*ddata->rx_buf = rxdata;
spi-efm32.c:169:		ddata->rx_buf++;
spi-efm32.c:172:	ddata->rx_len--;
spi-efm32.c:177:	while (ddata->tx_len &&
spi-efm32.c:178:			ddata->tx_len + 2 > ddata->rx_len &&
spi-efm32.c:186:	struct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);
spi-efm32.c:187:	int ret = -EBUSY;
spi-efm32.c:189:	spin_lock_irq(&ddata->lock);
spi-efm32.c:191:	if (ddata->tx_buf || ddata->rx_buf)
spi-efm32.c:194:	ddata->tx_buf = t->tx_buf;
spi-efm32.c:195:	ddata->rx_buf = t->rx_buf;
spi-efm32.c:196:	ddata->tx_len = ddata->rx_len =
spi-efm32.c:197:		t->len * DIV_ROUND_UP(t->bits_per_word, 8);
spi-efm32.c:201:	reinit_completion(&ddata->done);
spi-efm32.c:205:	spin_unlock_irq(&ddata->lock);
spi-efm32.c:207:	wait_for_completion(&ddata->done);
spi-efm32.c:209:	spin_lock_irq(&ddata->lock);
spi-efm32.c:211:	ret = t->len - max(ddata->tx_len, ddata->rx_len);
spi-efm32.c:214:	ddata->tx_buf = ddata->rx_buf = NULL;
spi-efm32.c:217:	spin_unlock_irq(&ddata->lock);
spi-efm32.c:227:	spin_lock(&ddata->lock);
spi-efm32.c:229:	while (ddata->rx_len > 0 &&
spi-efm32.c:237:	if (!ddata->rx_len) {
spi-efm32.c:244:		complete(&ddata->done);
spi-efm32.c:247:	spin_unlock(&ddata->lock);
spi-efm32.c:258:			__func__, ddata->tx_len, ddata->rx_len,
spi-efm32.c:262:	spin_lock(&ddata->lock);
spi-efm32.c:267:			__func__, ddata->tx_len, ddata->rx_len);
spi-efm32.c:269:	if (!ddata->tx_len) {
spi-efm32.c:278:	spin_unlock(&ddata->lock);
spi-efm32.c:293:	struct device_node *np = pdev->dev.of_node;
spi-efm32.c:308:		dev_dbg(&pdev->dev, "using location %u\n", location);
spi-efm32.c:313:		dev_info(&pdev->dev, "fall back to location %u\n", location);
spi-efm32.c:316:	ddata->pdata.location = location;
spi-efm32.c:325:	struct device_node *np = pdev->dev.of_node;
spi-efm32.c:329:		return -EINVAL;
spi-efm32.c:331:	num_cs = of_gpio_named_count(np, "cs-gpios");
spi-efm32.c:335:	master = spi_alloc_master(&pdev->dev,
spi-efm32.c:338:		dev_dbg(&pdev->dev,
spi-efm32.c:340:		return -ENOMEM;
spi-efm32.c:344:	master->dev.of_node = pdev->dev.of_node;
spi-efm32.c:346:	master->num_chipselect = num_cs;
spi-efm32.c:347:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-efm32.c:348:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
spi-efm32.c:352:	ddata->bitbang.master = master;
spi-efm32.c:353:	ddata->bitbang.chipselect = efm32_spi_chipselect;
spi-efm32.c:354:	ddata->bitbang.setup_transfer = efm32_spi_setup_transfer;
spi-efm32.c:355:	ddata->bitbang.txrx_bufs = efm32_spi_txrx_bufs;
spi-efm32.c:357:	spin_lock_init(&ddata->lock);
spi-efm32.c:358:	init_completion(&ddata->done);
spi-efm32.c:360:	ddata->clk = devm_clk_get(&pdev->dev, NULL);
spi-efm32.c:361:	if (IS_ERR(ddata->clk)) {
spi-efm32.c:362:		ret = PTR_ERR(ddata->clk);
spi-efm32.c:363:		dev_err(&pdev->dev, "failed to get clock: %d\n", ret);
spi-efm32.c:368:		ret = of_get_named_gpio(np, "cs-gpios", i);
spi-efm32.c:370:			dev_err(&pdev->dev, "failed to get csgpio#%u (%d)\n",
spi-efm32.c:374:		ddata->csgpio[i] = ret;
spi-efm32.c:375:		dev_dbg(&pdev->dev, "csgpio#%u = %u\n", i, ddata->csgpio[i]);
spi-efm32.c:376:		ret = devm_gpio_request_one(&pdev->dev, ddata->csgpio[i],
spi-efm32.c:379:			dev_err(&pdev->dev,
spi-efm32.c:388:		ret = -ENODEV;
spi-efm32.c:389:		dev_err(&pdev->dev, "failed to determine base address\n");
spi-efm32.c:394:		ret = -EINVAL;
spi-efm32.c:395:		dev_err(&pdev->dev, "memory resource too small\n");
spi-efm32.c:399:	ddata->base = devm_ioremap_resource(&pdev->dev, res);
spi-efm32.c:400:	if (IS_ERR(ddata->base)) {
spi-efm32.c:401:		ret = PTR_ERR(ddata->base);
spi-efm32.c:407:		dev_err(&pdev->dev, "failed to get rx irq (%d)\n", ret);
spi-efm32.c:411:	ddata->rxirq = ret;
spi-efm32.c:415:		ret = ddata->rxirq + 1;
spi-efm32.c:417:	ddata->txirq = ret;
spi-efm32.c:419:	ret = clk_prepare_enable(ddata->clk);
spi-efm32.c:421:		dev_err(&pdev->dev, "failed to enable clock (%d)\n", ret);
spi-efm32.c:430:			REG_ROUTE_LOCATION(ddata->pdata.location), REG_ROUTE);
spi-efm32.c:432:	ret = request_irq(ddata->rxirq, efm32_spi_rxirq,
spi-efm32.c:435:		dev_err(&pdev->dev, "failed to register rxirq (%d)\n", ret);
spi-efm32.c:439:	ret = request_irq(ddata->txirq, efm32_spi_txirq,
spi-efm32.c:442:		dev_err(&pdev->dev, "failed to register txirq (%d)\n", ret);
spi-efm32.c:446:	ret = spi_bitbang_start(&ddata->bitbang);
spi-efm32.c:448:		dev_err(&pdev->dev, "spi_bitbang_start failed (%d)\n", ret);
spi-efm32.c:450:		free_irq(ddata->txirq, ddata);
spi-efm32.c:452:		free_irq(ddata->rxirq, ddata);
spi-efm32.c:454:		clk_disable_unprepare(ddata->clk);
spi-efm32.c:467:	spi_bitbang_stop(&ddata->bitbang);
spi-efm32.c:471:	free_irq(ddata->txirq, ddata);
spi-efm32.c:472:	free_irq(ddata->rxirq, ddata);
spi-efm32.c:473:	clk_disable_unprepare(ddata->clk);
spi-efm32.c:481:		.compatible = "energymicro,efm32-spi",
spi-efm32.c:502:MODULE_AUTHOR("Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>");
spi-butterfly.c:2: * parport-to-butterfly adapter
spi-butterfly.c:59:	return spi->controller_data;
spi-butterfly.c:78:/*----------------------------------------------------------------------*/
spi-butterfly.c:84:	u8			bit, byte = pp->lastbyte;
spi-butterfly.c:92:	parport_write_data(pp->port, byte);
spi-butterfly.c:93:	pp->lastbyte = byte;
spi-butterfly.c:100:	u8			bit, byte = pp->lastbyte;
spi-butterfly.c:108:	parport_write_data(pp->port, byte);
spi-butterfly.c:109:	pp->lastbyte = byte;
spi-butterfly.c:121:	value = !(parport_read_status(pp->port) & bit);
spi-butterfly.c:131:		setsck(spi, spi->mode & SPI_CPOL);
spi-butterfly.c:140:	parport_frob_control(pp->port, spi_cs_bit, value ? spi_cs_bit : 0);
spi-butterfly.c:149:#include "spi-bitbang-txrx.h"
spi-butterfly.c:159:/*----------------------------------------------------------------------*/
spi-butterfly.c:176:	 * sectors 3-5 = 512 pages * 264 bytes/page
spi-butterfly.c:199:	struct device		*dev = p->physport->dev;
spi-butterfly.c:210:		status = -ENOMEM;
spi-butterfly.c:221:	master->bus_num = 42;
spi-butterfly.c:222:	master->num_chipselect = 2;
spi-butterfly.c:224:	pp->bitbang.master = master;
spi-butterfly.c:225:	pp->bitbang.chipselect = butterfly_chipselect;
spi-butterfly.c:226:	pp->bitbang.txrx_word[SPI_MODE_0] = butterfly_txrx_word_mode0;
spi-butterfly.c:231:	pp->port = p;
spi-butterfly.c:236:		status = -ENOMEM;
spi-butterfly.c:239:	pp->pd = pd;
spi-butterfly.c:248:	pr_debug("%s: powerup/reset Butterfly\n", p->name);
spi-butterfly.c:251:	parport_frob_control(pp->port, spi_cs_bit, 0);
spi-butterfly.c:256:	pp->lastbyte |= vcc_bits;
spi-butterfly.c:257:	parport_write_data(pp->port, pp->lastbyte);
spi-butterfly.c:261:	pp->lastbyte |= butterfly_nreset;
spi-butterfly.c:262:	parport_write_data(pp->port, pp->lastbyte);
spi-butterfly.c:269:	status = spi_bitbang_start(&pp->bitbang);
spi-butterfly.c:278:	pp->info[0].max_speed_hz = 15 * 1000 * 1000;
spi-butterfly.c:279:	strcpy(pp->info[0].modalias, "mtd_dataflash");
spi-butterfly.c:280:	pp->info[0].platform_data = &flash;
spi-butterfly.c:281:	pp->info[0].chip_select = 1;
spi-butterfly.c:282:	pp->info[0].controller_data = pp;
spi-butterfly.c:283:	pp->dataflash = spi_new_device(pp->bitbang.master, &pp->info[0]);
spi-butterfly.c:284:	if (pp->dataflash)
spi-butterfly.c:285:		pr_debug("%s: dataflash at %s\n", p->name,
spi-butterfly.c:286:				dev_name(&pp->dataflash->dev));
spi-butterfly.c:288:	pr_info("%s: AVR Butterfly\n", p->name);
spi-butterfly.c:294:	parport_write_data(pp->port, 0);
spi-butterfly.c:296:	parport_release(pp->pd);
spi-butterfly.c:300:	(void) spi_master_put(pp->bitbang.master);
spi-butterfly.c:302:	pr_debug("%s: butterfly probe, fail %d\n", p->name, status);
spi-butterfly.c:311:	 * "old school" driver-internal device lists?
spi-butterfly.c:313:	if (!butterfly || butterfly->port != p)
spi-butterfly.c:319:	spi_bitbang_stop(&pp->bitbang);
spi-butterfly.c:322:	parport_write_data(pp->port, 0);
spi-butterfly.c:325:	parport_release(pp->pd);
spi-butterfly.c:326:	parport_unregister_device(pp->pd);
spi-butterfly.c:328:	(void) spi_master_put(pp->bitbang.master);
spi-fsl-cpm.c:20:#include <linux/dma-mapping.h>
spi-fsl-cpm.c:29:#include "spi-fsl-cpm.h"
spi-fsl-cpm.c:30:#include "spi-fsl-lib.h"
spi-fsl-cpm.c:31:#include "spi-fsl-spi.h"
spi-fsl-cpm.c:57:	if (mspi->flags & SPI_QE) {
spi-fsl-cpm.c:58:		qe_issue_cmd(QE_INIT_TX_RX, mspi->subblock,
spi-fsl-cpm.c:61:		if (mspi->flags & SPI_CPM1) {
spi-fsl-cpm.c:62:			out_be32(&mspi->pram->rstate, 0);
spi-fsl-cpm.c:63:			out_be16(&mspi->pram->rbptr,
spi-fsl-cpm.c:64:				 in_be16(&mspi->pram->rbase));
spi-fsl-cpm.c:65:			out_be32(&mspi->pram->tstate, 0);
spi-fsl-cpm.c:66:			out_be16(&mspi->pram->tbptr,
spi-fsl-cpm.c:67:				 in_be16(&mspi->pram->tbase));
spi-fsl-cpm.c:77:	struct cpm_buf_desc __iomem *tx_bd = mspi->tx_bd;
spi-fsl-cpm.c:78:	struct cpm_buf_desc __iomem *rx_bd = mspi->rx_bd;
spi-fsl-cpm.c:79:	unsigned int xfer_len = min(mspi->count, SPI_MRBLR);
spi-fsl-cpm.c:81:	struct fsl_spi_reg *reg_base = mspi->reg_base;
spi-fsl-cpm.c:83:	xfer_ofs = mspi->xfer_in_progress->len - mspi->count;
spi-fsl-cpm.c:85:	if (mspi->rx_dma == mspi->dma_dummy_rx)
spi-fsl-cpm.c:86:		out_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma);
spi-fsl-cpm.c:88:		out_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma + xfer_ofs);
spi-fsl-cpm.c:89:	out_be16(&rx_bd->cbd_datlen, 0);
spi-fsl-cpm.c:90:	out_be16(&rx_bd->cbd_sc, BD_SC_EMPTY | BD_SC_INTRPT | BD_SC_WRAP);
spi-fsl-cpm.c:92:	if (mspi->tx_dma == mspi->dma_dummy_tx)
spi-fsl-cpm.c:93:		out_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma);
spi-fsl-cpm.c:95:		out_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma + xfer_ofs);
spi-fsl-cpm.c:96:	out_be16(&tx_bd->cbd_datlen, xfer_len);
spi-fsl-cpm.c:97:	out_be16(&tx_bd->cbd_sc, BD_SC_READY | BD_SC_INTRPT | BD_SC_WRAP |
spi-fsl-cpm.c:101:	mpc8xxx_spi_write_reg(&reg_base->command, SPCOM_STR);
spi-fsl-cpm.c:107:	struct device *dev = mspi->dev;
spi-fsl-cpm.c:108:	struct fsl_spi_reg *reg_base = mspi->reg_base;
spi-fsl-cpm.c:111:		mspi->map_tx_dma = 0;
spi-fsl-cpm.c:112:		mspi->map_rx_dma = 0;
spi-fsl-cpm.c:114:		mspi->map_tx_dma = 1;
spi-fsl-cpm.c:115:		mspi->map_rx_dma = 1;
spi-fsl-cpm.c:118:	if (!t->tx_buf) {
spi-fsl-cpm.c:119:		mspi->tx_dma = mspi->dma_dummy_tx;
spi-fsl-cpm.c:120:		mspi->map_tx_dma = 0;
spi-fsl-cpm.c:123:	if (!t->rx_buf) {
spi-fsl-cpm.c:124:		mspi->rx_dma = mspi->dma_dummy_rx;
spi-fsl-cpm.c:125:		mspi->map_rx_dma = 0;
spi-fsl-cpm.c:128:	if (mspi->map_tx_dma) {
spi-fsl-cpm.c:129:		void *nonconst_tx = (void *)mspi->tx; /* shut up gcc */
spi-fsl-cpm.c:131:		mspi->tx_dma = dma_map_single(dev, nonconst_tx, t->len,
spi-fsl-cpm.c:133:		if (dma_mapping_error(dev, mspi->tx_dma)) {
spi-fsl-cpm.c:135:			return -ENOMEM;
spi-fsl-cpm.c:137:	} else if (t->tx_buf) {
spi-fsl-cpm.c:138:		mspi->tx_dma = t->tx_dma;
spi-fsl-cpm.c:141:	if (mspi->map_rx_dma) {
spi-fsl-cpm.c:142:		mspi->rx_dma = dma_map_single(dev, mspi->rx, t->len,
spi-fsl-cpm.c:144:		if (dma_mapping_error(dev, mspi->rx_dma)) {
spi-fsl-cpm.c:148:	} else if (t->rx_buf) {
spi-fsl-cpm.c:149:		mspi->rx_dma = t->rx_dma;
spi-fsl-cpm.c:153:	mpc8xxx_spi_write_reg(&reg_base->mask, SPIE_RXB);
spi-fsl-cpm.c:155:	mspi->xfer_in_progress = t;
spi-fsl-cpm.c:156:	mspi->count = t->len;
spi-fsl-cpm.c:164:	if (mspi->map_tx_dma)
spi-fsl-cpm.c:165:		dma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);
spi-fsl-cpm.c:166:	return -ENOMEM;
spi-fsl-cpm.c:172:	struct device *dev = mspi->dev;
spi-fsl-cpm.c:173:	struct spi_transfer *t = mspi->xfer_in_progress;
spi-fsl-cpm.c:175:	if (mspi->map_tx_dma)
spi-fsl-cpm.c:176:		dma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);
spi-fsl-cpm.c:177:	if (mspi->map_rx_dma)
spi-fsl-cpm.c:178:		dma_unmap_single(dev, mspi->rx_dma, t->len, DMA_FROM_DEVICE);
spi-fsl-cpm.c:179:	mspi->xfer_in_progress = NULL;
spi-fsl-cpm.c:186:	struct fsl_spi_reg *reg_base = mspi->reg_base;
spi-fsl-cpm.c:188:	dev_dbg(mspi->dev, "%s: bd datlen %d, count %d\n", __func__,
spi-fsl-cpm.c:189:		in_be16(&mspi->rx_bd->cbd_datlen), mspi->count);
spi-fsl-cpm.c:191:	len = in_be16(&mspi->rx_bd->cbd_datlen);
spi-fsl-cpm.c:192:	if (len > mspi->count) {
spi-fsl-cpm.c:194:		len = mspi->count;
spi-fsl-cpm.c:198:	mpc8xxx_spi_write_reg(&reg_base->event, events);
spi-fsl-cpm.c:200:	mspi->count -= len;
spi-fsl-cpm.c:201:	if (mspi->count)
spi-fsl-cpm.c:204:		complete(&mspi->done);
spi-fsl-cpm.c:235:		fsl_dummy_rx_refcnt--;
spi-fsl-cpm.c:244:	struct device *dev = mspi->dev;
spi-fsl-cpm.c:245:	struct device_node *np = dev->of_node;
spi-fsl-cpm.c:249:	unsigned long pram_ofs = -ENOMEM;
spi-fsl-cpm.c:255:	if (mspi->flags & SPI_QE && iprop && size == sizeof(*iprop) * 4)
spi-fsl-cpm.c:259:	if (mspi->flags & SPI_QE) {
spi-fsl-cpm.c:261:		qe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, mspi->subblock,
spi-fsl-cpm.c:268:		return -EINVAL;
spi-fsl-cpm.c:270:	if (mspi->flags & SPI_CPM2) {
spi-fsl-cpm.c:281:	struct device *dev = mspi->dev;
spi-fsl-cpm.c:282:	struct device_node *np = dev->of_node;
spi-fsl-cpm.c:287:	if (!(mspi->flags & SPI_CPM_MODE))
spi-fsl-cpm.c:291:		return -ENOMEM;
spi-fsl-cpm.c:293:	if (mspi->flags & SPI_QE) {
spi-fsl-cpm.c:294:		iprop = of_get_property(np, "cell-index", &size);
spi-fsl-cpm.c:296:			mspi->subblock = *iprop;
spi-fsl-cpm.c:298:		switch (mspi->subblock) {
spi-fsl-cpm.c:300:			dev_warn(dev, "cell-index unspecified, assuming SPI1\n");
spi-fsl-cpm.c:303:			mspi->subblock = QE_CR_SUBBLOCK_SPI1;
spi-fsl-cpm.c:306:			mspi->subblock = QE_CR_SUBBLOCK_SPI2;
spi-fsl-cpm.c:311:	if (mspi->flags & SPI_CPM1) {
spi-fsl-cpm.c:319:			mspi->pram = NULL;
spi-fsl-cpm.c:321:			mspi->pram = pram;
spi-fsl-cpm.c:326:			mspi->pram = NULL;
spi-fsl-cpm.c:328:			mspi->pram = cpm_muram_addr(pram_ofs);
spi-fsl-cpm.c:330:	if (mspi->pram == NULL) {
spi-fsl-cpm.c:335:	bds_ofs = cpm_muram_alloc(sizeof(*mspi->tx_bd) +
spi-fsl-cpm.c:336:				  sizeof(*mspi->rx_bd), 8);
spi-fsl-cpm.c:342:	mspi->dma_dummy_tx = dma_map_single(dev, empty_zero_page, PAGE_SIZE,
spi-fsl-cpm.c:344:	if (dma_mapping_error(dev, mspi->dma_dummy_tx)) {
spi-fsl-cpm.c:349:	mspi->dma_dummy_rx = dma_map_single(dev, fsl_dummy_rx, SPI_MRBLR,
spi-fsl-cpm.c:351:	if (dma_mapping_error(dev, mspi->dma_dummy_rx)) {
spi-fsl-cpm.c:356:	mspi->tx_bd = cpm_muram_addr(bds_ofs);
spi-fsl-cpm.c:357:	mspi->rx_bd = cpm_muram_addr(bds_ofs + sizeof(*mspi->tx_bd));
spi-fsl-cpm.c:360:	out_be16(&mspi->pram->tbase, cpm_muram_offset(mspi->tx_bd));
spi-fsl-cpm.c:361:	out_be16(&mspi->pram->rbase, cpm_muram_offset(mspi->rx_bd));
spi-fsl-cpm.c:362:	out_8(&mspi->pram->tfcr, CPMFCR_EB | CPMFCR_GBL);
spi-fsl-cpm.c:363:	out_8(&mspi->pram->rfcr, CPMFCR_EB | CPMFCR_GBL);
spi-fsl-cpm.c:364:	out_be16(&mspi->pram->mrblr, SPI_MRBLR);
spi-fsl-cpm.c:365:	out_be32(&mspi->pram->rstate, 0);
spi-fsl-cpm.c:366:	out_be32(&mspi->pram->rdp, 0);
spi-fsl-cpm.c:367:	out_be16(&mspi->pram->rbptr, 0);
spi-fsl-cpm.c:368:	out_be16(&mspi->pram->rbc, 0);
spi-fsl-cpm.c:369:	out_be32(&mspi->pram->rxtmp, 0);
spi-fsl-cpm.c:370:	out_be32(&mspi->pram->tstate, 0);
spi-fsl-cpm.c:371:	out_be32(&mspi->pram->tdp, 0);
spi-fsl-cpm.c:372:	out_be16(&mspi->pram->tbptr, 0);
spi-fsl-cpm.c:373:	out_be16(&mspi->pram->tbc, 0);
spi-fsl-cpm.c:374:	out_be32(&mspi->pram->txtmp, 0);
spi-fsl-cpm.c:379:	dma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);
spi-fsl-cpm.c:383:	if (!(mspi->flags & SPI_CPM1))
spi-fsl-cpm.c:384:		cpm_muram_free(cpm_muram_offset(mspi->pram));
spi-fsl-cpm.c:387:	return -ENOMEM;
spi-fsl-cpm.c:393:	struct device *dev = mspi->dev;
spi-fsl-cpm.c:395:	if (!(mspi->flags & SPI_CPM_MODE))
spi-fsl-cpm.c:398:	dma_unmap_single(dev, mspi->dma_dummy_rx, SPI_MRBLR, DMA_FROM_DEVICE);
spi-fsl-cpm.c:399:	dma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);
spi-fsl-cpm.c:400:	cpm_muram_free(cpm_muram_offset(mspi->tx_bd));
spi-fsl-cpm.c:401:	cpm_muram_free(cpm_muram_offset(mspi->pram));
spi-gpio.c:35: * platform_device->driver_data ... points to spi_gpio
spi-gpio.c:37: * spi->controller_state ... reserved for bitbang framework code
spi-gpio.c:38: * spi->controller_data ... holds chipselect GPIO
spi-gpio.c:40: * spi->master->dev.driver_data ... points to spi_gpio->bitbang
spi-gpio.c:50:/*----------------------------------------------------------------------*/
spi-gpio.c:57: *   - The slow generic way:  set up platform_data to hold the GPIO
spi-gpio.c:61: *   - The quicker inlined way:  only helps with platform GPIO code
spi-gpio.c:72: *		#include "spi-gpio.c"
spi-gpio.c:81:#define SPI_MISO_GPIO	((pdata)->miso)
spi-gpio.c:82:#define SPI_MOSI_GPIO	((pdata)->mosi)
spi-gpio.c:83:#define SPI_SCK_GPIO	((pdata)->sck)
spi-gpio.c:85:#define SPI_N_CHIPSEL	((pdata)->num_chipselect)
spi-gpio.c:89:/*----------------------------------------------------------------------*/
spi-gpio.c:97:	bang = spi_master_get_devdata(spi->master);
spi-gpio.c:105:	return &spi_to_spi_gpio(spi)->pdata;
spi-gpio.c:108:/* this is #defined to avoid unused-variable warnings when inlining */
spi-gpio.c:132: * we'll just assume we never need additional per-bit slowdowns.
spi-gpio.c:136:#include "spi-bitbang-txrx.h"
spi-gpio.c:142: * even with default 8-bit words.
spi-gpio.c:189:	unsigned flags = spi->master->flags;
spi-gpio.c:196:	unsigned flags = spi->master->flags;
spi-gpio.c:203:	unsigned flags = spi->master->flags;
spi-gpio.c:210:	unsigned flags = spi->master->flags;
spi-gpio.c:214:/*----------------------------------------------------------------------*/
spi-gpio.c:219:	unsigned long cs = spi_gpio->cs_gpios[spi->chip_select];
spi-gpio.c:223:		setsck(spi, spi->mode & SPI_CPOL);
spi-gpio.c:226:		/* SPI is normally active-low */
spi-gpio.c:227:		gpio_set_value_cansleep(cs, (spi->mode & SPI_CS_HIGH) ? is_active : !is_active);
spi-gpio.c:236:	struct device_node	*np = spi->master->dev.of_node;
spi-gpio.c:241:		 * initialized from the "cs-gpios" property of the node.
spi-gpio.c:243:		cs = spi_gpio->cs_gpios[spi->chip_select];
spi-gpio.c:246:		 * ... otherwise, take it from spi->controller_data
spi-gpio.c:248:		cs = (uintptr_t) spi->controller_data;
spi-gpio.c:251:	if (!spi->controller_state) {
spi-gpio.c:253:			status = gpio_request(cs, dev_name(&spi->dev));
spi-gpio.c:257:					!(spi->mode & SPI_CS_HIGH));
spi-gpio.c:262:		spi_gpio->cs_gpios[spi->chip_select] = cs;
spi-gpio.c:267:		if (!spi->controller_state && cs != SPI_GPIO_NO_CHIPSELECT)
spi-gpio.c:276:	unsigned long cs = spi_gpio->cs_gpios[spi->chip_select];
spi-gpio.c:340:	{ .compatible = "spi-gpio" },
spi-gpio.c:350:	struct device_node *np = pdev->dev.of_node;
spi-gpio.c:352:			of_match_device(spi_gpio_dt_ids, &pdev->dev);
spi-gpio.c:357:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
spi-gpio.c:359:		return -ENOMEM;
spi-gpio.c:361:	ret = of_get_named_gpio(np, "gpio-sck", 0);
spi-gpio.c:363:		dev_err(&pdev->dev, "gpio-sck property not found\n");
spi-gpio.c:366:	pdata->sck = ret;
spi-gpio.c:368:	ret = of_get_named_gpio(np, "gpio-miso", 0);
spi-gpio.c:370:		dev_info(&pdev->dev, "gpio-miso property not found, switching to no-rx mode\n");
spi-gpio.c:371:		pdata->miso = SPI_GPIO_NO_MISO;
spi-gpio.c:373:		pdata->miso = ret;
spi-gpio.c:375:	ret = of_get_named_gpio(np, "gpio-mosi", 0);
spi-gpio.c:377:		dev_info(&pdev->dev, "gpio-mosi property not found, switching to no-tx mode\n");
spi-gpio.c:378:		pdata->mosi = SPI_GPIO_NO_MOSI;
spi-gpio.c:380:		pdata->mosi = ret;
spi-gpio.c:382:	ret = of_property_read_u32(np, "num-chipselects", &tmp);
spi-gpio.c:384:		dev_err(&pdev->dev, "num-chipselects property not found\n");
spi-gpio.c:388:	pdata->num_chipselect = tmp;
spi-gpio.c:389:	pdev->dev.platform_data = pdata;
spi-gpio.c:394:	devm_kfree(&pdev->dev, pdata);
spi-gpio.c:420:	pdata = dev_get_platdata(&pdev->dev);
spi-gpio.c:422:	if (!pdata || (!use_of && !pdata->num_chipselect))
spi-gpio.c:423:		return -ENODEV;
spi-gpio.c:431:	status = spi_gpio_request(pdata, dev_name(&pdev->dev), &master_flags);
spi-gpio.c:435:	master = spi_alloc_master(&pdev->dev, sizeof(*spi_gpio) +
spi-gpio.c:438:		status = -ENOMEM;
spi-gpio.c:444:	spi_gpio->pdev = pdev;
spi-gpio.c:446:		spi_gpio->pdata = *pdata;
spi-gpio.c:448:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);
spi-gpio.c:449:	master->flags = master_flags;
spi-gpio.c:450:	master->bus_num = pdev->id;
spi-gpio.c:451:	master->num_chipselect = num_devices;
spi-gpio.c:452:	master->setup = spi_gpio_setup;
spi-gpio.c:453:	master->cleanup = spi_gpio_cleanup;
spi-gpio.c:455:	master->dev.of_node = pdev->dev.of_node;
spi-gpio.c:459:		struct device_node *np = pdev->dev.of_node;
spi-gpio.c:462:		 * In DT environments, take the CS GPIO from the "cs-gpios"
spi-gpio.c:467:			spi_gpio->cs_gpios[0] = SPI_GPIO_NO_CHIPSELECT;
spi-gpio.c:470:				status = of_get_named_gpio(np, "cs-gpios", i);
spi-gpio.c:472:					dev_err(&pdev->dev,
spi-gpio.c:473:						"invalid cs-gpios property\n");
spi-gpio.c:476:				spi_gpio->cs_gpios[i] = status;
spi-gpio.c:481:	spi_gpio->bitbang.master = master;
spi-gpio.c:482:	spi_gpio->bitbang.chipselect = spi_gpio_chipselect;
spi-gpio.c:485:		spi_gpio->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_word_mode0;
spi-gpio.c:486:		spi_gpio->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_word_mode1;
spi-gpio.c:487:		spi_gpio->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_word_mode2;
spi-gpio.c:488:		spi_gpio->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_txrx_word_mode3;
spi-gpio.c:490:		spi_gpio->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_spec_txrx_word_mode0;
spi-gpio.c:491:		spi_gpio->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_spec_txrx_word_mode1;
spi-gpio.c:492:		spi_gpio->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_spec_txrx_word_mode2;
spi-gpio.c:493:		spi_gpio->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_spec_txrx_word_mode3;
spi-gpio.c:495:	spi_gpio->bitbang.setup_transfer = spi_bitbang_setup_transfer;
spi-gpio.c:496:	spi_gpio->bitbang.flags = SPI_CS_HIGH;
spi-gpio.c:498:	status = spi_bitbang_start(&spi_gpio->bitbang);
spi-gpio.c:518:	pdata = dev_get_platdata(&pdev->dev);
spi-gpio.c:521:	spi_bitbang_stop(&spi_gpio->bitbang);
spi-gpio.c:528:	spi_master_put(spi_gpio->bitbang.master);
spi-sun4i.c:2: * Copyright (C) 2012 - 2014 Allwinner Tech
spi-sun4i.c:6: * Maxime Ripard <maxime.ripard@free-electrons.com>
spi-sun4i.c:91:	return readl(sspi->base_addr + reg);
spi-sun4i.c:96:	writel(value, sspi->base_addr + reg);
spi-sun4i.c:112:	while (len--) {
spi-sun4i.c:113:		byte = readb(sspi->base_addr + SUN4I_RXDATA_REG);
spi-sun4i.c:114:		if (sspi->rx_buf)
spi-sun4i.c:115:			*sspi->rx_buf++ = byte;
spi-sun4i.c:123:	if (len > sspi->len)
spi-sun4i.c:124:		len = sspi->len;
spi-sun4i.c:126:	while (len--) {
spi-sun4i.c:127:		byte = sspi->tx_buf ? *sspi->tx_buf++ : 0;
spi-sun4i.c:128:		writeb(byte, sspi->base_addr + SUN4I_TXDATA_REG);
spi-sun4i.c:129:		sspi->len--;
spi-sun4i.c:135:	struct sun4i_spi *sspi = spi_master_get_devdata(spi->master);
spi-sun4i.c:141:	reg |= SUN4I_CTL_CS(spi->chip_select);
spi-sun4i.c:159:	if (spi->mode & SPI_CS_HIGH)
spi-sun4i.c:179:	if (tfr->len > SUN4I_FIFO_DEPTH)
spi-sun4i.c:180:		return -EMSGSIZE;
spi-sun4i.c:182:	if (tfr->tx_buf && tfr->len >= SUN4I_FIFO_DEPTH)
spi-sun4i.c:183:		return -EMSGSIZE;
spi-sun4i.c:185:	reinit_completion(&sspi->done);
spi-sun4i.c:186:	sspi->tx_buf = tfr->tx_buf;
spi-sun4i.c:187:	sspi->rx_buf = tfr->rx_buf;
spi-sun4i.c:188:	sspi->len = tfr->len;
spi-sun4i.c:204:	if (spi->mode & SPI_CPOL)
spi-sun4i.c:209:	if (spi->mode & SPI_CPHA)
spi-sun4i.c:214:	if (spi->mode & SPI_LSB_FIRST)
spi-sun4i.c:224:	if (sspi->rx_buf)
spi-sun4i.c:235:	mclk_rate = clk_get_rate(sspi->mclk);
spi-sun4i.c:236:	if (mclk_rate < (2 * spi->max_speed_hz)) {
spi-sun4i.c:237:		clk_set_rate(sspi->mclk, 2 * spi->max_speed_hz);
spi-sun4i.c:238:		mclk_rate = clk_get_rate(sspi->mclk);
spi-sun4i.c:255:	div = mclk_rate / (2 * spi->max_speed_hz);
spi-sun4i.c:258:			div--;
spi-sun4i.c:262:		div = ilog2(mclk_rate) - ilog2(spi->max_speed_hz);
spi-sun4i.c:269:	if (sspi->tx_buf)
spi-sun4i.c:270:		tx_len = tfr->len;
spi-sun4i.c:273:	sun4i_spi_write(sspi, SUN4I_BURST_CNT_REG, SUN4I_BURST_CNT(tfr->len));
spi-sun4i.c:281:	sun4i_spi_fill_fifo(sspi, SUN4I_FIFO_DEPTH - 1);
spi-sun4i.c:290:	tx_time = max(tfr->len * 8 * 2 / (tfr->speed_hz / 1000), 100U);
spi-sun4i.c:292:	timeout = wait_for_completion_timeout(&sspi->done,
spi-sun4i.c:296:		dev_warn(&master->dev,
spi-sun4i.c:298:			 dev_name(&spi->dev), tfr->len, tfr->speed_hz,
spi-sun4i.c:299:			 jiffies_to_msecs(end - start), tx_time);
spi-sun4i.c:300:		ret = -ETIMEDOUT;
spi-sun4i.c:320:		complete(&sspi->done);
spi-sun4i.c:333:	ret = clk_prepare_enable(sspi->hclk);
spi-sun4i.c:339:	ret = clk_prepare_enable(sspi->mclk);
spi-sun4i.c:351:	clk_disable_unprepare(sspi->hclk);
spi-sun4i.c:361:	clk_disable_unprepare(sspi->mclk);
spi-sun4i.c:362:	clk_disable_unprepare(sspi->hclk);
spi-sun4i.c:374:	master = spi_alloc_master(&pdev->dev, sizeof(struct sun4i_spi));
spi-sun4i.c:376:		dev_err(&pdev->dev, "Unable to allocate SPI Master\n");
spi-sun4i.c:377:		return -ENOMEM;
spi-sun4i.c:384:	sspi->base_addr = devm_ioremap_resource(&pdev->dev, res);
spi-sun4i.c:385:	if (IS_ERR(sspi->base_addr)) {
spi-sun4i.c:386:		ret = PTR_ERR(sspi->base_addr);
spi-sun4i.c:392:		dev_err(&pdev->dev, "No spi IRQ specified\n");
spi-sun4i.c:393:		ret = -ENXIO;
spi-sun4i.c:397:	ret = devm_request_irq(&pdev->dev, irq, sun4i_spi_handler,
spi-sun4i.c:398:			       0, "sun4i-spi", sspi);
spi-sun4i.c:400:		dev_err(&pdev->dev, "Cannot request IRQ\n");
spi-sun4i.c:404:	sspi->master = master;
spi-sun4i.c:405:	master->set_cs = sun4i_spi_set_cs;
spi-sun4i.c:406:	master->transfer_one = sun4i_spi_transfer_one;
spi-sun4i.c:407:	master->num_chipselect = 4;
spi-sun4i.c:408:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;
spi-sun4i.c:409:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-sun4i.c:410:	master->dev.of_node = pdev->dev.of_node;
spi-sun4i.c:411:	master->auto_runtime_pm = true;
spi-sun4i.c:413:	sspi->hclk = devm_clk_get(&pdev->dev, "ahb");
spi-sun4i.c:414:	if (IS_ERR(sspi->hclk)) {
spi-sun4i.c:415:		dev_err(&pdev->dev, "Unable to acquire AHB clock\n");
spi-sun4i.c:416:		ret = PTR_ERR(sspi->hclk);
spi-sun4i.c:420:	sspi->mclk = devm_clk_get(&pdev->dev, "mod");
spi-sun4i.c:421:	if (IS_ERR(sspi->mclk)) {
spi-sun4i.c:422:		dev_err(&pdev->dev, "Unable to acquire module clock\n");
spi-sun4i.c:423:		ret = PTR_ERR(sspi->mclk);
spi-sun4i.c:427:	init_completion(&sspi->done);
spi-sun4i.c:430:	 * This wake-up/shutdown pattern is to be able to have the
spi-sun4i.c:433:	ret = sun4i_spi_runtime_resume(&pdev->dev);
spi-sun4i.c:435:		dev_err(&pdev->dev, "Couldn't resume the device\n");
spi-sun4i.c:439:	pm_runtime_set_active(&pdev->dev);
spi-sun4i.c:440:	pm_runtime_enable(&pdev->dev);
spi-sun4i.c:441:	pm_runtime_idle(&pdev->dev);
spi-sun4i.c:443:	ret = devm_spi_register_master(&pdev->dev, master);
spi-sun4i.c:445:		dev_err(&pdev->dev, "cannot register SPI master\n");
spi-sun4i.c:452:	pm_runtime_disable(&pdev->dev);
spi-sun4i.c:453:	sun4i_spi_runtime_suspend(&pdev->dev);
spi-sun4i.c:461:	pm_runtime_force_suspend(&pdev->dev);
spi-sun4i.c:467:	{ .compatible = "allwinner,sun4i-a10-spi", },
spi-sun4i.c:481:		.name		= "sun4i-spi",
spi-sun4i.c:489:MODULE_AUTHOR("Maxime Ripard <maxime.ripard@free-electrons.com>");
 built-in.o
spi-rockchip.c:3: * Author: Addy Ke <addy.ke@rock-chips.com>
spi-rockchip.c:31:#define DRIVER_NAME "rockchip-spi"
spi-rockchip.c:206:	writel_relaxed((enable ? 1 : 0), rs->regs + ROCKCHIP_SPI_SSIENR);
spi-rockchip.c:211:	writel_relaxed(div, rs->regs + ROCKCHIP_SPI_BAUDR);
spi-rockchip.c:216:	while (readl_relaxed(rs->regs + ROCKCHIP_SPI_RXFLR))
spi-rockchip.c:217:		readl_relaxed(rs->regs + ROCKCHIP_SPI_RXDR);
spi-rockchip.c:225:		if (!(readl_relaxed(rs->regs + ROCKCHIP_SPI_SR) & SR_BUSY))
spi-rockchip.c:229:	dev_warn(rs->dev, "spi controller is in busy state!\n");
spi-rockchip.c:237:		writel_relaxed(fifo, rs->regs + ROCKCHIP_SPI_TXFTLR);
spi-rockchip.c:238:		if (fifo != readl_relaxed(rs->regs + ROCKCHIP_SPI_TXFTLR))
spi-rockchip.c:242:	writel_relaxed(0, rs->regs + ROCKCHIP_SPI_TXFTLR);
spi-rockchip.c:251:	tx_left = (rs->tx_end - rs->tx) / rs->n_bytes;
spi-rockchip.c:252:	tx_room = rs->fifo_len - readl_relaxed(rs->regs + ROCKCHIP_SPI_TXFLR);
spi-rockchip.c:259:	u32 rx_left = (rs->rx_end - rs->rx) / rs->n_bytes;
spi-rockchip.c:260:	u32 rx_room = (u32)readl_relaxed(rs->regs + ROCKCHIP_SPI_RXFLR);
spi-rockchip.c:268:	struct spi_master *master = spi->master;
spi-rockchip.c:271:	pm_runtime_get_sync(rs->dev);
spi-rockchip.c:273:	ser = readl_relaxed(rs->regs + ROCKCHIP_SPI_SER) & SER_MASK;
spi-rockchip.c:279:	 *		if (spi->mode & SPI_CS_HIGH)
spi-rockchip.c:282:	 *		if (spi->cs_gpio >= 0)
spi-rockchip.c:283:	 *			gpio_set_value(spi->cs_gpio, !enable);
spi-rockchip.c:284:	 *		else if (spi->master->set_cs)
spi-rockchip.c:285:	 *		spi->master->set_cs(spi, !enable);
spi-rockchip.c:291:		ser |= 1 << spi->chip_select;
spi-rockchip.c:293:		ser &= ~(1 << spi->chip_select);
spi-rockchip.c:295:	writel_relaxed(ser, rs->regs + ROCKCHIP_SPI_SER);
spi-rockchip.c:297:	pm_runtime_put_sync(rs->dev);
spi-rockchip.c:304:	struct spi_device *spi = msg->spi;
spi-rockchip.c:306:	rs->mode = spi->mode;
spi-rockchip.c:317:	spin_lock_irqsave(&rs->lock, flags);
spi-rockchip.c:325:	if (rs->use_dma) {
spi-rockchip.c:326:		if (rs->state & RXBUSY) {
spi-rockchip.c:327:			dmaengine_terminate_all(rs->dma_rx.ch);
spi-rockchip.c:331:		if (rs->state & TXBUSY)
spi-rockchip.c:332:			dmaengine_terminate_all(rs->dma_tx.ch);
spi-rockchip.c:335:	spin_unlock_irqrestore(&rs->lock, flags);
spi-rockchip.c:353:	while (max--) {
spi-rockchip.c:354:		if (rs->n_bytes == 1)
spi-rockchip.c:355:			txw = *(u8 *)(rs->tx);
spi-rockchip.c:357:			txw = *(u16 *)(rs->tx);
spi-rockchip.c:359:		writel_relaxed(txw, rs->regs + ROCKCHIP_SPI_TXDR);
spi-rockchip.c:360:		rs->tx += rs->n_bytes;
spi-rockchip.c:369:	while (max--) {
spi-rockchip.c:370:		rxw = readl_relaxed(rs->regs + ROCKCHIP_SPI_RXDR);
spi-rockchip.c:371:		if (rs->n_bytes == 1)
spi-rockchip.c:372:			*(u8 *)(rs->rx) = (u8)rxw;
spi-rockchip.c:374:			*(u16 *)(rs->rx) = (u16)rxw;
spi-rockchip.c:375:		rs->rx += rs->n_bytes;
spi-rockchip.c:384:		if (rs->tx) {
spi-rockchip.c:385:			remain = rs->tx_end - rs->tx;
spi-rockchip.c:389:		if (rs->rx) {
spi-rockchip.c:390:			remain = rs->rx_end - rs->rx;
spi-rockchip.c:398:	if (rs->tx)
spi-rockchip.c:411:	spin_lock_irqsave(&rs->lock, flags);
spi-rockchip.c:413:	rs->state &= ~RXBUSY;
spi-rockchip.c:414:	if (!(rs->state & TXBUSY)) {
spi-rockchip.c:416:		spi_finalize_current_transfer(rs->master);
spi-rockchip.c:419:	spin_unlock_irqrestore(&rs->lock, flags);
spi-rockchip.c:430:	spin_lock_irqsave(&rs->lock, flags);
spi-rockchip.c:432:	rs->state &= ~TXBUSY;
spi-rockchip.c:433:	if (!(rs->state & RXBUSY)) {
spi-rockchip.c:435:		spi_finalize_current_transfer(rs->master);
spi-rockchip.c:438:	spin_unlock_irqrestore(&rs->lock, flags);
spi-rockchip.c:447:	spin_lock_irqsave(&rs->lock, flags);
spi-rockchip.c:448:	rs->state &= ~RXBUSY;
spi-rockchip.c:449:	rs->state &= ~TXBUSY;
spi-rockchip.c:450:	spin_unlock_irqrestore(&rs->lock, flags);
spi-rockchip.c:453:	if (rs->rx) {
spi-rockchip.c:454:		rxconf.direction = rs->dma_rx.direction;
spi-rockchip.c:455:		rxconf.src_addr = rs->dma_rx.addr;
spi-rockchip.c:456:		rxconf.src_addr_width = rs->n_bytes;
spi-rockchip.c:457:		rxconf.src_maxburst = rs->n_bytes;
spi-rockchip.c:458:		dmaengine_slave_config(rs->dma_rx.ch, &rxconf);
spi-rockchip.c:461:				rs->dma_rx.ch,
spi-rockchip.c:462:				rs->rx_sg.sgl, rs->rx_sg.nents,
spi-rockchip.c:463:				rs->dma_rx.direction, DMA_PREP_INTERRUPT);
spi-rockchip.c:465:		rxdesc->callback = rockchip_spi_dma_rxcb;
spi-rockchip.c:466:		rxdesc->callback_param = rs;
spi-rockchip.c:470:	if (rs->tx) {
spi-rockchip.c:471:		txconf.direction = rs->dma_tx.direction;
spi-rockchip.c:472:		txconf.dst_addr = rs->dma_tx.addr;
spi-rockchip.c:473:		txconf.dst_addr_width = rs->n_bytes;
spi-rockchip.c:474:		txconf.dst_maxburst = rs->n_bytes;
spi-rockchip.c:475:		dmaengine_slave_config(rs->dma_tx.ch, &txconf);
spi-rockchip.c:478:				rs->dma_tx.ch,
spi-rockchip.c:479:				rs->tx_sg.sgl, rs->tx_sg.nents,
spi-rockchip.c:480:				rs->dma_tx.direction, DMA_PREP_INTERRUPT);
spi-rockchip.c:482:		txdesc->callback = rockchip_spi_dma_txcb;
spi-rockchip.c:483:		txdesc->callback_param = rs;
spi-rockchip.c:488:		spin_lock_irqsave(&rs->lock, flags);
spi-rockchip.c:489:		rs->state |= RXBUSY;
spi-rockchip.c:490:		spin_unlock_irqrestore(&rs->lock, flags);
spi-rockchip.c:492:		dma_async_issue_pending(rs->dma_rx.ch);
spi-rockchip.c:496:		spin_lock_irqsave(&rs->lock, flags);
spi-rockchip.c:497:		rs->state |= TXBUSY;
spi-rockchip.c:498:		spin_unlock_irqrestore(&rs->lock, flags);
spi-rockchip.c:500:		dma_async_issue_pending(rs->dma_tx.ch);
spi-rockchip.c:513:	cr0 |= (rs->n_bytes << CR0_DFS_OFFSET);
spi-rockchip.c:514:	cr0 |= ((rs->mode & 0x3) << CR0_SCPH_OFFSET);
spi-rockchip.c:515:	cr0 |= (rs->tmode << CR0_XFM_OFFSET);
spi-rockchip.c:516:	cr0 |= (rs->type << CR0_FRF_OFFSET);
spi-rockchip.c:518:	if (rs->use_dma) {
spi-rockchip.c:519:		if (rs->tx)
spi-rockchip.c:521:		if (rs->rx)
spi-rockchip.c:525:	if (WARN_ON(rs->speed > MAX_SCLK_OUT))
spi-rockchip.c:526:		rs->speed = MAX_SCLK_OUT;
spi-rockchip.c:529:	if (rs->max_freq < 2 * rs->speed) {
spi-rockchip.c:530:		clk_set_rate(rs->spiclk, 2 * rs->speed);
spi-rockchip.c:531:		rs->max_freq = clk_get_rate(rs->spiclk);
spi-rockchip.c:535:	div = DIV_ROUND_UP(rs->max_freq, rs->speed);
spi-rockchip.c:539:	rsd = DIV_ROUND_CLOSEST(rs->rsd_nsecs * (rs->max_freq >> 8),
spi-rockchip.c:541:	if (!rsd && rs->rsd_nsecs) {
spi-rockchip.c:542:		pr_warn_once("rockchip-spi: %u Hz are too slow to express %u ns delay\n",
spi-rockchip.c:543:			     rs->max_freq, rs->rsd_nsecs);
spi-rockchip.c:546:		pr_warn_once("rockchip-spi: %u Hz are too fast to express %u ns delay, clamping at %u ns\n",
spi-rockchip.c:547:			     rs->max_freq, rs->rsd_nsecs,
spi-rockchip.c:548:			     rsd * 1000000000U / rs->max_freq);
spi-rockchip.c:552:	writel_relaxed(cr0, rs->regs + ROCKCHIP_SPI_CTRLR0);
spi-rockchip.c:554:	writel_relaxed(rs->len - 1, rs->regs + ROCKCHIP_SPI_CTRLR1);
spi-rockchip.c:555:	writel_relaxed(rs->fifo_len / 2 - 1, rs->regs + ROCKCHIP_SPI_TXFTLR);
spi-rockchip.c:556:	writel_relaxed(rs->fifo_len / 2 - 1, rs->regs + ROCKCHIP_SPI_RXFTLR);
spi-rockchip.c:558:	writel_relaxed(0, rs->regs + ROCKCHIP_SPI_DMATDLR);
spi-rockchip.c:559:	writel_relaxed(0, rs->regs + ROCKCHIP_SPI_DMARDLR);
spi-rockchip.c:560:	writel_relaxed(dmacr, rs->regs + ROCKCHIP_SPI_DMACR);
spi-rockchip.c:564:	dev_dbg(rs->dev, "cr0 0x%x, div %d\n", cr0, div);
spi-rockchip.c:575:	WARN_ON(readl_relaxed(rs->regs + ROCKCHIP_SPI_SSIENR) &&
spi-rockchip.c:576:		(readl_relaxed(rs->regs + ROCKCHIP_SPI_SR) & SR_BUSY));
spi-rockchip.c:578:	if (!xfer->tx_buf && !xfer->rx_buf) {
spi-rockchip.c:579:		dev_err(rs->dev, "No buffer for transfer\n");
spi-rockchip.c:580:		return -EINVAL;
spi-rockchip.c:583:	rs->speed = xfer->speed_hz;
spi-rockchip.c:584:	rs->bpw = xfer->bits_per_word;
spi-rockchip.c:585:	rs->n_bytes = rs->bpw >> 3;
spi-rockchip.c:587:	rs->tx = xfer->tx_buf;
spi-rockchip.c:588:	rs->tx_end = rs->tx + xfer->len;
spi-rockchip.c:589:	rs->rx = xfer->rx_buf;
spi-rockchip.c:590:	rs->rx_end = rs->rx + xfer->len;
spi-rockchip.c:591:	rs->len = xfer->len;
spi-rockchip.c:593:	rs->tx_sg = xfer->tx_sg;
spi-rockchip.c:594:	rs->rx_sg = xfer->rx_sg;
spi-rockchip.c:596:	if (rs->tx && rs->rx)
spi-rockchip.c:597:		rs->tmode = CR0_XFM_TR;
spi-rockchip.c:598:	else if (rs->tx)
spi-rockchip.c:599:		rs->tmode = CR0_XFM_TO;
spi-rockchip.c:600:	else if (rs->rx)
spi-rockchip.c:601:		rs->tmode = CR0_XFM_RO;
spi-rockchip.c:604:	if (master->can_dma && master->can_dma(master, spi, xfer))
spi-rockchip.c:605:		rs->use_dma = 1;
spi-rockchip.c:607:		rs->use_dma = 0;
spi-rockchip.c:611:	if (rs->use_dma) {
spi-rockchip.c:612:		if (rs->tmode == CR0_XFM_RO) {
spi-rockchip.c:635:	return (xfer->len > rs->fifo_len);
spi-rockchip.c:646:	master = spi_alloc_master(&pdev->dev, sizeof(struct rockchip_spi));
spi-rockchip.c:648:		return -ENOMEM;
spi-rockchip.c:656:	rs->regs = devm_ioremap_resource(&pdev->dev, mem);
spi-rockchip.c:657:	if (IS_ERR(rs->regs)) {
spi-rockchip.c:658:		ret =  PTR_ERR(rs->regs);
spi-rockchip.c:662:	rs->apb_pclk = devm_clk_get(&pdev->dev, "apb_pclk");
spi-rockchip.c:663:	if (IS_ERR(rs->apb_pclk)) {
spi-rockchip.c:664:		dev_err(&pdev->dev, "Failed to get apb_pclk\n");
spi-rockchip.c:665:		ret = PTR_ERR(rs->apb_pclk);
spi-rockchip.c:669:	rs->spiclk = devm_clk_get(&pdev->dev, "spiclk");
spi-rockchip.c:670:	if (IS_ERR(rs->spiclk)) {
spi-rockchip.c:671:		dev_err(&pdev->dev, "Failed to get spi_pclk\n");
spi-rockchip.c:672:		ret = PTR_ERR(rs->spiclk);
spi-rockchip.c:676:	ret = clk_prepare_enable(rs->apb_pclk);
spi-rockchip.c:678:		dev_err(&pdev->dev, "Failed to enable apb_pclk\n");
spi-rockchip.c:682:	ret = clk_prepare_enable(rs->spiclk);
spi-rockchip.c:684:		dev_err(&pdev->dev, "Failed to enable spi_clk\n");
spi-rockchip.c:690:	rs->type = SSI_MOTO_SPI;
spi-rockchip.c:691:	rs->master = master;
spi-rockchip.c:692:	rs->dev = &pdev->dev;
spi-rockchip.c:693:	rs->max_freq = clk_get_rate(rs->spiclk);
spi-rockchip.c:695:	if (!of_property_read_u32(pdev->dev.of_node, "rx-sample-delay-ns",
spi-rockchip.c:697:		rs->rsd_nsecs = rsd_nsecs;
spi-rockchip.c:699:	rs->fifo_len = get_fifo_len(rs);
spi-rockchip.c:700:	if (!rs->fifo_len) {
spi-rockchip.c:701:		dev_err(&pdev->dev, "Failed to get fifo length\n");
spi-rockchip.c:702:		ret = -EINVAL;
spi-rockchip.c:706:	spin_lock_init(&rs->lock);
spi-rockchip.c:708:	pm_runtime_set_active(&pdev->dev);
spi-rockchip.c:709:	pm_runtime_enable(&pdev->dev);
spi-rockchip.c:711:	master->auto_runtime_pm = true;
spi-rockchip.c:712:	master->bus_num = pdev->id;
spi-rockchip.c:713:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP;
spi-rockchip.c:714:	master->num_chipselect = 2;
spi-rockchip.c:715:	master->dev.of_node = pdev->dev.of_node;
spi-rockchip.c:716:	master->bits_per_word_mask = SPI_BPW_MASK(16) | SPI_BPW_MASK(8);
spi-rockchip.c:718:	master->set_cs = rockchip_spi_set_cs;
spi-rockchip.c:719:	master->prepare_message = rockchip_spi_prepare_message;
spi-rockchip.c:720:	master->unprepare_message = rockchip_spi_unprepare_message;
spi-rockchip.c:721:	master->transfer_one = rockchip_spi_transfer_one;
spi-rockchip.c:722:	master->handle_err = rockchip_spi_handle_err;
spi-rockchip.c:724:	rs->dma_tx.ch = dma_request_slave_channel(rs->dev, "tx");
spi-rockchip.c:725:	if (!rs->dma_tx.ch)
spi-rockchip.c:726:		dev_warn(rs->dev, "Failed to request TX DMA channel\n");
spi-rockchip.c:728:	rs->dma_rx.ch = dma_request_slave_channel(rs->dev, "rx");
spi-rockchip.c:729:	if (!rs->dma_rx.ch) {
spi-rockchip.c:730:		if (rs->dma_tx.ch) {
spi-rockchip.c:731:			dma_release_channel(rs->dma_tx.ch);
spi-rockchip.c:732:			rs->dma_tx.ch = NULL;
spi-rockchip.c:734:		dev_warn(rs->dev, "Failed to request RX DMA channel\n");
spi-rockchip.c:737:	if (rs->dma_tx.ch && rs->dma_rx.ch) {
spi-rockchip.c:738:		rs->dma_tx.addr = (dma_addr_t)(mem->start + ROCKCHIP_SPI_TXDR);
spi-rockchip.c:739:		rs->dma_rx.addr = (dma_addr_t)(mem->start + ROCKCHIP_SPI_RXDR);
spi-rockchip.c:740:		rs->dma_tx.direction = DMA_MEM_TO_DEV;
spi-rockchip.c:741:		rs->dma_rx.direction = DMA_DEV_TO_MEM;
spi-rockchip.c:743:		master->can_dma = rockchip_spi_can_dma;
spi-rockchip.c:744:		master->dma_tx = rs->dma_tx.ch;
spi-rockchip.c:745:		master->dma_rx = rs->dma_rx.ch;
spi-rockchip.c:748:	ret = devm_spi_register_master(&pdev->dev, master);
spi-rockchip.c:750:		dev_err(&pdev->dev, "Failed to register master\n");
spi-rockchip.c:757:	if (rs->dma_tx.ch)
spi-rockchip.c:758:		dma_release_channel(rs->dma_tx.ch);
spi-rockchip.c:759:	if (rs->dma_rx.ch)
spi-rockchip.c:760:		dma_release_channel(rs->dma_rx.ch);
spi-rockchip.c:762:	clk_disable_unprepare(rs->spiclk);
spi-rockchip.c:764:	clk_disable_unprepare(rs->apb_pclk);
spi-rockchip.c:776:	pm_runtime_disable(&pdev->dev);
spi-rockchip.c:778:	clk_disable_unprepare(rs->spiclk);
spi-rockchip.c:779:	clk_disable_unprepare(rs->apb_pclk);
spi-rockchip.c:781:	if (rs->dma_tx.ch)
spi-rockchip.c:782:		dma_release_channel(rs->dma_tx.ch);
spi-rockchip.c:783:	if (rs->dma_rx.ch)
spi-rockchip.c:784:		dma_release_channel(rs->dma_rx.ch);
spi-rockchip.c:796:	ret = spi_master_suspend(rs->master);
spi-rockchip.c:801:		clk_disable_unprepare(rs->spiclk);
spi-rockchip.c:802:		clk_disable_unprepare(rs->apb_pclk);
spi-rockchip.c:815:		ret = clk_prepare_enable(rs->apb_pclk);
spi-rockchip.c:819:		ret = clk_prepare_enable(rs->spiclk);
spi-rockchip.c:821:			clk_disable_unprepare(rs->apb_pclk);
spi-rockchip.c:826:	ret = spi_master_resume(rs->master);
spi-rockchip.c:828:		clk_disable_unprepare(rs->spiclk);
spi-rockchip.c:829:		clk_disable_unprepare(rs->apb_pclk);
spi-rockchip.c:842:	clk_disable_unprepare(rs->spiclk);
spi-rockchip.c:843:	clk_disable_unprepare(rs->apb_pclk);
spi-rockchip.c:854:	ret = clk_prepare_enable(rs->apb_pclk);
spi-rockchip.c:858:	ret = clk_prepare_enable(rs->spiclk);
spi-rockchip.c:860:		clk_disable_unprepare(rs->apb_pclk);
spi-rockchip.c:873:	{ .compatible = "rockchip,rk3066-spi", },
spi-rockchip.c:874:	{ .compatible = "rockchip,rk3188-spi", },
spi-rockchip.c:875:	{ .compatible = "rockchip,rk3288-spi", },
spi-rockchip.c:892:MODULE_AUTHOR("Addy Ke <addy.ke@rock-chips.com>");
spi-bcm53xx.c:10:#include "spi-bcm53xx.h"
spi-bcm53xx.c:26:	return bcma_read32(b53spi->core, offset);
spi-bcm53xx.c:32:	bcma_write32(b53spi->core, offset, value);
spi-bcm53xx.c:76:	return -EBUSY;
spi-bcm53xx.c:94:		if (!cont && i == len - 1)
spi-bcm53xx.c:103:	bcm53xxspi_write(b53spi, B53SPI_MSPI_ENDQP, len - 1);
spi-bcm53xx.c:121:	b53spi->read_offset = len;
spi-bcm53xx.c:130:	for (i = 0; i < b53spi->read_offset + len; i++) {
spi-bcm53xx.c:133:		if (!cont && i == b53spi->read_offset + len - 1)
spi-bcm53xx.c:143:			 b53spi->read_offset + len - 1);
spi-bcm53xx.c:162:		int offset = b53spi->read_offset + i;
spi-bcm53xx.c:168:	b53spi->read_offset = 0;
spi-bcm53xx.c:179:	if (t->tx_buf) {
spi-bcm53xx.c:180:		buf = (u8 *)t->tx_buf;
spi-bcm53xx.c:181:		left = t->len;
spi-bcm53xx.c:184:			bool cont = left - to_write > 0;
spi-bcm53xx.c:187:			left -= to_write;
spi-bcm53xx.c:192:	if (t->rx_buf) {
spi-bcm53xx.c:193:		buf = (u8 *)t->rx_buf;
spi-bcm53xx.c:194:		left = t->len;
spi-bcm53xx.c:196:			size_t to_read = min_t(size_t, 16 - b53spi->read_offset,
spi-bcm53xx.c:198:			bool cont = left - to_read > 0;
spi-bcm53xx.c:201:			left -= to_read;
spi-bcm53xx.c:229:	if (core->bus->drv_cc.core->id.rev != 42) {
spi-bcm53xx.c:231:		return -ENOTSUPP;
spi-bcm53xx.c:234:	master = spi_alloc_master(&core->dev, sizeof(*b53spi));
spi-bcm53xx.c:236:		return -ENOMEM;
spi-bcm53xx.c:239:	b53spi->master = master;
spi-bcm53xx.c:240:	b53spi->core = core;
spi-bcm53xx.c:242:	master->transfer_one = bcm53xxspi_transfer_one;
spi-bcm53xx.c:246:	err = devm_spi_register_master(&core->dev, master);
spi-zynqmp-gqspi.c:2: * Xilinx Zynq UltraScale+ MPSoC Quad-SPI (QSPI) controller driver
spi-zynqmp-gqspi.c:5: * Copyright (C) 2009 - 2015 Xilinx, Inc.
spi-zynqmp-gqspi.c:15:#include <linux/dma-mapping.h>
spi-zynqmp-gqspi.c:120:#define GQSPI_TX_FIFO_FILL	(GQSPI_TXD_DEPTH -\
spi-zynqmp-gqspi.c:141: * struct zynqmp_qspi - Defines qspi driver instance
spi-zynqmp-gqspi.c:183:	return readl_relaxed(xqspi->regs + offset);
spi-zynqmp-gqspi.c:195:	writel_relaxed(val, (xqspi->regs + offset));
spi-zynqmp-gqspi.c:202: * @flashbus:	To check which bus is selected- upper or lower
spi-zynqmp-gqspi.c:215:		instanceptr->genfifocs = GQSPI_GENFIFO_CS_LOWER |
spi-zynqmp-gqspi.c:219:		instanceptr->genfifocs = GQSPI_GENFIFO_CS_UPPER;
spi-zynqmp-gqspi.c:222:		instanceptr->genfifocs = GQSPI_GENFIFO_CS_LOWER;
spi-zynqmp-gqspi.c:225:		dev_warn(instanceptr->dev, "Invalid slave select\n");
spi-zynqmp-gqspi.c:231:		instanceptr->genfifobus = GQSPI_GENFIFO_BUS_LOWER |
spi-zynqmp-gqspi.c:235:		instanceptr->genfifobus = GQSPI_GENFIFO_BUS_UPPER;
spi-zynqmp-gqspi.c:238:		instanceptr->genfifobus = GQSPI_GENFIFO_BUS_LOWER;
spi-zynqmp-gqspi.c:241:		dev_warn(instanceptr->dev, "Invalid slave bus\n");
spi-zynqmp-gqspi.c:251: *	- Master mode
spi-zynqmp-gqspi.c:252: *	- TX threshold set to 1
spi-zynqmp-gqspi.c:253: *	- RX threshold set to 1
spi-zynqmp-gqspi.c:254: *	- Flash memory interface mode enabled
spi-zynqmp-gqspi.c:256: *	- Disable and clear all the interrupts
spi-zynqmp-gqspi.c:257: *	- Enable manual slave select
spi-zynqmp-gqspi.c:258: *	- Enable manual start
spi-zynqmp-gqspi.c:259: *	- Deselect all the chip select lines
spi-zynqmp-gqspi.c:260: *	- Set the little endian mode of TX FIFO and
spi-zynqmp-gqspi.c:261: *	- Enable the QSPI controller
spi-zynqmp-gqspi.c:297:	/* Clear pre-scalar by default */
spi-zynqmp-gqspi.c:342:	memcpy(xqspi->rxbuf, &data, size);
spi-zynqmp-gqspi.c:343:	xqspi->rxbuf += size;
spi-zynqmp-gqspi.c:344:	xqspi->bytes_to_receive -= size;
spi-zynqmp-gqspi.c:361:	ret = clk_enable(xqspi->refclk);
spi-zynqmp-gqspi.c:365:	ret = clk_enable(xqspi->pclk);
spi-zynqmp-gqspi.c:389:	clk_disable(xqspi->refclk);
spi-zynqmp-gqspi.c:390:	clk_disable(xqspi->pclk);
spi-zynqmp-gqspi.c:401:	struct zynqmp_qspi *xqspi = spi_master_get_devdata(qspi->master);
spi-zynqmp-gqspi.c:406:	genfifoentry |= xqspi->genfifobus;
spi-zynqmp-gqspi.c:409:		genfifoentry |= xqspi->genfifocs;
spi-zynqmp-gqspi.c:439:		dev_err(xqspi->dev, "Chip select timed out\n");
spi-zynqmp-gqspi.c:456: *	obtained using the pre-scalar value, the driver sets the clock
spi-zynqmp-gqspi.c:467:	struct zynqmp_qspi *xqspi = spi_master_get_devdata(qspi->master);
spi-zynqmp-gqspi.c:472:		req_hz = transfer->speed_hz;
spi-zynqmp-gqspi.c:474:		req_hz = qspi->max_speed_hz;
spi-zynqmp-gqspi.c:478:	clk_rate = clk_get_rate(xqspi->refclk);
spi-zynqmp-gqspi.c:490:	if (qspi->mode & SPI_CPHA)
spi-zynqmp-gqspi.c:492:	if (qspi->mode & SPI_CPOL)
spi-zynqmp-gqspi.c:512:	if (qspi->master->busy)
spi-zynqmp-gqspi.c:513:		return -EBUSY;
spi-zynqmp-gqspi.c:528:	while ((xqspi->bytes_to_transfer > 0) && (count < size)) {
spi-zynqmp-gqspi.c:529:		memcpy(&intermediate, xqspi->txbuf, 4);
spi-zynqmp-gqspi.c:532:		if (xqspi->bytes_to_transfer >= 4) {
spi-zynqmp-gqspi.c:533:			xqspi->txbuf += 4;
spi-zynqmp-gqspi.c:534:			xqspi->bytes_to_transfer -= 4;
spi-zynqmp-gqspi.c:536:			xqspi->txbuf += xqspi->bytes_to_transfer;
spi-zynqmp-gqspi.c:537:			xqspi->bytes_to_transfer = 0;
spi-zynqmp-gqspi.c:554:	while ((count < size) && (xqspi->bytes_to_receive > 0)) {
spi-zynqmp-gqspi.c:555:		if (xqspi->bytes_to_receive >= 4) {
spi-zynqmp-gqspi.c:556:			(*(u32 *) xqspi->rxbuf) =
spi-zynqmp-gqspi.c:558:			xqspi->rxbuf += 4;
spi-zynqmp-gqspi.c:559:			xqspi->bytes_to_receive -= 4;
spi-zynqmp-gqspi.c:563:			count += xqspi->bytes_to_receive;
spi-zynqmp-gqspi.c:565:						   xqspi->bytes_to_receive);
spi-zynqmp-gqspi.c:566:			xqspi->bytes_to_receive = 0;
spi-zynqmp-gqspi.c:582:	dma_unmap_single(xqspi->dev, xqspi->dma_addr,
spi-zynqmp-gqspi.c:583:				xqspi->dma_rx_bytes, DMA_FROM_DEVICE);
spi-zynqmp-gqspi.c:584:	xqspi->rxbuf += xqspi->dma_rx_bytes;
spi-zynqmp-gqspi.c:585:	xqspi->bytes_to_receive -= xqspi->dma_rx_bytes;
spi-zynqmp-gqspi.c:586:	xqspi->dma_rx_bytes = 0;
spi-zynqmp-gqspi.c:592:	if (xqspi->bytes_to_receive > 0) {
spi-zynqmp-gqspi.c:599:		genfifoentry = xqspi->genfifoentry;
spi-zynqmp-gqspi.c:600:		genfifoentry |= xqspi->bytes_to_receive;
spi-zynqmp-gqspi.c:643:	if (xqspi->mode == GQSPI_MODE_DMA) {
spi-zynqmp-gqspi.c:664:	if ((xqspi->bytes_to_receive == 0) && (xqspi->bytes_to_transfer == 0)
spi-zynqmp-gqspi.c:674: * zynqmp_qspi_selectspimode:	Selects SPI mode - x1 or x2 or x4.
spi-zynqmp-gqspi.c:676: * @spimode:	spimode - SPI or DUAL or QUAD.
spi-zynqmp-gqspi.c:695:		dev_warn(xqspi->dev, "Invalid SPI mode\n");
spi-zynqmp-gqspi.c:709:	u64 dma_align =  (u64)(uintptr_t)xqspi->rxbuf;
spi-zynqmp-gqspi.c:711:	if ((xqspi->bytes_to_receive < 8) ||
spi-zynqmp-gqspi.c:717:		xqspi->mode = GQSPI_MODE_IO;
spi-zynqmp-gqspi.c:718:		xqspi->dma_rx_bytes = 0;
spi-zynqmp-gqspi.c:722:	rx_rem = xqspi->bytes_to_receive % 4;
spi-zynqmp-gqspi.c:723:	rx_bytes = (xqspi->bytes_to_receive - rx_rem);
spi-zynqmp-gqspi.c:725:	addr = dma_map_single(xqspi->dev, (void *)xqspi->rxbuf,
spi-zynqmp-gqspi.c:727:	if (dma_mapping_error(xqspi->dev, addr))
spi-zynqmp-gqspi.c:728:		dev_err(xqspi->dev, "ERR:rxdma:memory not mapped\n");
spi-zynqmp-gqspi.c:730:	xqspi->dma_rx_bytes = rx_bytes;
spi-zynqmp-gqspi.c:731:	xqspi->dma_addr = addr;
spi-zynqmp-gqspi.c:745:	xqspi->mode = GQSPI_MODE_DMA;
spi-zynqmp-gqspi.c:767:	if ((xqspi->txbuf != NULL) && (xqspi->rxbuf == NULL)) {
spi-zynqmp-gqspi.c:773:			zynqmp_qspi_selectspimode(xqspi, transfer->tx_nbits);
spi-zynqmp-gqspi.c:774:		xqspi->bytes_to_transfer = transfer->len;
spi-zynqmp-gqspi.c:775:		if (xqspi->mode == GQSPI_MODE_DMA) {
spi-zynqmp-gqspi.c:781:			xqspi->mode = GQSPI_MODE_IO;
spi-zynqmp-gqspi.c:785:		xqspi->bytes_to_receive = 0;
spi-zynqmp-gqspi.c:786:	} else if ((xqspi->txbuf == NULL) && (xqspi->rxbuf != NULL)) {
spi-zynqmp-gqspi.c:795:			zynqmp_qspi_selectspimode(xqspi, transfer->rx_nbits);
spi-zynqmp-gqspi.c:796:		xqspi->bytes_to_transfer = 0;
spi-zynqmp-gqspi.c:797:		xqspi->bytes_to_receive = transfer->len;
spi-zynqmp-gqspi.c:822:	xqspi->txbuf = transfer->tx_buf;
spi-zynqmp-gqspi.c:823:	xqspi->rxbuf = transfer->rx_buf;
spi-zynqmp-gqspi.c:827:	genfifoentry |= xqspi->genfifocs;
spi-zynqmp-gqspi.c:828:	genfifoentry |= xqspi->genfifobus;
spi-zynqmp-gqspi.c:832:	if (xqspi->mode == GQSPI_MODE_DMA)
spi-zynqmp-gqspi.c:833:		transfer_len = xqspi->dma_rx_bytes;
spi-zynqmp-gqspi.c:835:		transfer_len = transfer->len;
spi-zynqmp-gqspi.c:837:	xqspi->genfifoentry = genfifoentry;
spi-zynqmp-gqspi.c:874:	if ((xqspi->mode == GQSPI_MODE_IO) &&
spi-zynqmp-gqspi.c:875:			(xqspi->rxbuf != NULL)) {
spi-zynqmp-gqspi.c:885:	if (xqspi->txbuf != NULL)
spi-zynqmp-gqspi.c:892:	if (xqspi->rxbuf != NULL) {
spi-zynqmp-gqspi.c:894:		if (xqspi->mode == GQSPI_MODE_DMA) {
spi-zynqmp-gqspi.c:907:	return transfer->len;
spi-zynqmp-gqspi.c:950:	ret = clk_enable(xqspi->pclk);
spi-zynqmp-gqspi.c:956:	ret = clk_enable(xqspi->refclk);
spi-zynqmp-gqspi.c:959:		clk_disable(xqspi->pclk);
spi-zynqmp-gqspi.c:985:	struct device *dev = &pdev->dev;
spi-zynqmp-gqspi.c:987:	master = spi_alloc_master(&pdev->dev, sizeof(*xqspi));
spi-zynqmp-gqspi.c:989:		return -ENOMEM;
spi-zynqmp-gqspi.c:992:	master->dev.of_node = pdev->dev.of_node;
spi-zynqmp-gqspi.c:996:	xqspi->regs = devm_ioremap_resource(&pdev->dev, res);
spi-zynqmp-gqspi.c:997:	if (IS_ERR(xqspi->regs)) {
spi-zynqmp-gqspi.c:998:		ret = PTR_ERR(xqspi->regs);
spi-zynqmp-gqspi.c:1002:	xqspi->dev = dev;
spi-zynqmp-gqspi.c:1003:	xqspi->pclk = devm_clk_get(&pdev->dev, "pclk");
spi-zynqmp-gqspi.c:1004:	if (IS_ERR(xqspi->pclk)) {
spi-zynqmp-gqspi.c:1006:		ret = PTR_ERR(xqspi->pclk);
spi-zynqmp-gqspi.c:1010:	ret = clk_prepare_enable(xqspi->pclk);
spi-zynqmp-gqspi.c:1016:	xqspi->refclk = devm_clk_get(&pdev->dev, "ref_clk");
spi-zynqmp-gqspi.c:1017:	if (IS_ERR(xqspi->refclk)) {
spi-zynqmp-gqspi.c:1019:		ret = PTR_ERR(xqspi->refclk);
spi-zynqmp-gqspi.c:1023:	ret = clk_prepare_enable(xqspi->refclk);
spi-zynqmp-gqspi.c:1032:	xqspi->irq = platform_get_irq(pdev, 0);
spi-zynqmp-gqspi.c:1033:	if (xqspi->irq <= 0) {
spi-zynqmp-gqspi.c:1034:		ret = -ENXIO;
spi-zynqmp-gqspi.c:1038:	ret = devm_request_irq(&pdev->dev, xqspi->irq, zynqmp_qspi_irq,
spi-zynqmp-gqspi.c:1039:			       0, pdev->name, master);
spi-zynqmp-gqspi.c:1041:		ret = -ENXIO;
spi-zynqmp-gqspi.c:1046:	master->num_chipselect = GQSPI_DEFAULT_NUM_CS;
spi-zynqmp-gqspi.c:1048:	master->setup = zynqmp_qspi_setup;
spi-zynqmp-gqspi.c:1049:	master->set_cs = zynqmp_qspi_chipselect;
spi-zynqmp-gqspi.c:1050:	master->transfer_one = zynqmp_qspi_start_transfer;
spi-zynqmp-gqspi.c:1051:	master->prepare_transfer_hardware = zynqmp_prepare_transfer_hardware;
spi-zynqmp-gqspi.c:1052:	master->unprepare_transfer_hardware =
spi-zynqmp-gqspi.c:1054:	master->max_speed_hz = clk_get_rate(xqspi->refclk) / 2;
spi-zynqmp-gqspi.c:1055:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-zynqmp-gqspi.c:1056:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_RX_DUAL | SPI_RX_QUAD |
spi-zynqmp-gqspi.c:1059:	if (master->dev.parent == NULL)
spi-zynqmp-gqspi.c:1060:		master->dev.parent = &master->dev;
spi-zynqmp-gqspi.c:1069:	clk_disable_unprepare(xqspi->refclk);
spi-zynqmp-gqspi.c:1071:	clk_disable_unprepare(xqspi->pclk);
spi-zynqmp-gqspi.c:1094:	clk_disable_unprepare(xqspi->refclk);
spi-zynqmp-gqspi.c:1095:	clk_disable_unprepare(xqspi->pclk);
spi-zynqmp-gqspi.c:1103:	{ .compatible = "xlnx,zynqmp-qspi-1.0", },
spi-zynqmp-gqspi.c:1113:		.name = "zynqmp-qspi",
spi-octeon.c:18:#include <asm/octeon/cvmx-mpi-defs.h>
spi-octeon.c:43:		mpi_sts.u64 = cvmx_read_csr(p->register_base + OCTEON_SPI_STS);
spi-octeon.c:52:	struct spi_device *spi = msg->spi;
spi-octeon.c:64:	mode = spi->mode;
spi-octeon.c:68:	speed_hz = xfer->speed_hz;
spi-octeon.c:82:	if (spi->chip_select < 4)
spi-octeon.c:83:		p->cs_enax |= 1ull << (12 + spi->chip_select);
spi-octeon.c:84:	mpi_cfg.u64 |= p->cs_enax;
spi-octeon.c:86:	if (mpi_cfg.u64 != p->last_cfg) {
spi-octeon.c:87:		p->last_cfg = mpi_cfg.u64;
spi-octeon.c:88:		cvmx_write_csr(p->register_base + OCTEON_SPI_CFG, mpi_cfg.u64);
spi-octeon.c:90:	tx_buf = xfer->tx_buf;
spi-octeon.c:91:	rx_buf = xfer->rx_buf;
spi-octeon.c:92:	len = xfer->len;
spi-octeon.c:100:			cvmx_write_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i), d);
spi-octeon.c:103:		mpi_tx.s.csid = spi->chip_select;
spi-octeon.c:107:		cvmx_write_csr(p->register_base + OCTEON_SPI_TX, mpi_tx.u64);
spi-octeon.c:112:				u64 v = cvmx_read_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i));
spi-octeon.c:115:		len -= OCTEON_SPI_MAX_BYTES;
spi-octeon.c:124:		cvmx_write_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i), d);
spi-octeon.c:128:	mpi_tx.s.csid = spi->chip_select;
spi-octeon.c:130:		mpi_tx.s.leavecs = xfer->cs_change;
spi-octeon.c:132:		mpi_tx.s.leavecs = !xfer->cs_change;
spi-octeon.c:135:	cvmx_write_csr(p->register_base + OCTEON_SPI_TX, mpi_tx.u64);
spi-octeon.c:140:			u64 v = cvmx_read_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i));
spi-octeon.c:144:	if (xfer->delay_usecs)
spi-octeon.c:145:		udelay(xfer->delay_usecs);
spi-octeon.c:147:	return xfer->len;
spi-octeon.c:158:	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
spi-octeon.c:159:		bool last_xfer = list_is_last(&xfer->transfer_list,
spi-octeon.c:160:					      &msg->transfers);
spi-octeon.c:169:	msg->status = status;
spi-octeon.c:170:	msg->actual_length = total_len;
spi-octeon.c:180:	int err = -ENOENT;
spi-octeon.c:182:	master = spi_alloc_master(&pdev->dev, sizeof(struct octeon_spi));
spi-octeon.c:184:		return -ENOMEM;
spi-octeon.c:191:		dev_err(&pdev->dev, "found no memory resource\n");
spi-octeon.c:192:		err = -ENXIO;
spi-octeon.c:195:	if (!devm_request_mem_region(&pdev->dev, res_mem->start,
spi-octeon.c:196:				     resource_size(res_mem), res_mem->name)) {
spi-octeon.c:197:		dev_err(&pdev->dev, "request_mem_region failed\n");
spi-octeon.c:200:	p->register_base = (u64)devm_ioremap(&pdev->dev, res_mem->start,
spi-octeon.c:203:	master->num_chipselect = 4;
spi-octeon.c:204:	master->mode_bits = SPI_CPHA |
spi-octeon.c:210:	master->transfer_one_message = octeon_spi_transfer_one_message;
spi-octeon.c:211:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-octeon.c:212:	master->max_speed_hz = OCTEON_SPI_MAX_CLOCK_HZ;
spi-octeon.c:214:	master->dev.of_node = pdev->dev.of_node;
spi-octeon.c:215:	err = devm_spi_register_master(&pdev->dev, master);
spi-octeon.c:217:		dev_err(&pdev->dev, "register master failed: %d\n", err);
spi-octeon.c:221:	dev_info(&pdev->dev, "OCTEON SPI bus driver\n");
spi-octeon.c:233:	u64 register_base = p->register_base;
spi-octeon.c:242:	{ .compatible = "cavium,octeon-3010-spi", },
spi-octeon.c:249:		.name		= "spi-octeon",
spi-tegra20-slink.c:23:#include <linux/dma-mapping.h>
spi-tegra20-slink.c:224:	return readl(tspi->base + reg);
spi-tegra20-slink.c:230:	writel(val, tspi->base + reg);
spi-tegra20-slink.c:234:		readl(tspi->base + SLINK_MAS_DATA);
spi-tegra20-slink.c:251:	switch (tspi->bytes_per_word) {
spi-tegra20-slink.c:269:	unsigned remain_len = t->len - tspi->cur_pos;
spi-tegra20-slink.c:275:	bits_per_word = t->bits_per_word;
spi-tegra20-slink.c:276:	tspi->bytes_per_word = DIV_ROUND_UP(bits_per_word, 8);
spi-tegra20-slink.c:279:		tspi->is_packed = 1;
spi-tegra20-slink.c:280:		tspi->words_per_32bit = 32/bits_per_word;
spi-tegra20-slink.c:282:		tspi->is_packed = 0;
spi-tegra20-slink.c:283:		tspi->words_per_32bit = 1;
spi-tegra20-slink.c:285:	tspi->packed_size = tegra_slink_get_packed_size(tspi, t);
spi-tegra20-slink.c:287:	if (tspi->is_packed) {
spi-tegra20-slink.c:288:		max_len = min(remain_len, tspi->max_buf_size);
spi-tegra20-slink.c:289:		tspi->curr_dma_words = max_len/tspi->bytes_per_word;
spi-tegra20-slink.c:292:		max_word = (remain_len - 1) / tspi->bytes_per_word + 1;
spi-tegra20-slink.c:293:		max_word = min(max_word, tspi->max_buf_size/4);
spi-tegra20-slink.c:294:		tspi->curr_dma_words = max_word;
spi-tegra20-slink.c:310:	u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
spi-tegra20-slink.c:315:	if (tspi->is_packed) {
spi-tegra20-slink.c:316:		fifo_words_left = tx_empty_count * tspi->words_per_32bit;
spi-tegra20-slink.c:317:		written_words = min(fifo_words_left, tspi->curr_dma_words);
spi-tegra20-slink.c:318:		nbytes = written_words * tspi->bytes_per_word;
spi-tegra20-slink.c:322:			for (i = 0; (i < 4) && nbytes; i++, nbytes--)
spi-tegra20-slink.c:327:		max_n_32bit = min(tspi->curr_dma_words,  tx_empty_count);
spi-tegra20-slink.c:329:		nbytes = written_words * tspi->bytes_per_word;
spi-tegra20-slink.c:332:			for (i = 0; nbytes && (i < tspi->bytes_per_word);
spi-tegra20-slink.c:333:							i++, nbytes--)
spi-tegra20-slink.c:338:	tspi->cur_tx_pos += written_words * tspi->bytes_per_word;
spi-tegra20-slink.c:350:	u8 *rx_buf = (u8 *)t->rx_buf + tspi->cur_rx_pos;
spi-tegra20-slink.c:354:	if (tspi->is_packed) {
spi-tegra20-slink.c:355:		len = tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra20-slink.c:358:			for (i = 0; len && (i < 4); i++, len--)
spi-tegra20-slink.c:361:		tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra20-slink.c:362:		read_words += tspi->curr_dma_words;
spi-tegra20-slink.c:366:			for (i = 0; (i < tspi->bytes_per_word); i++)
spi-tegra20-slink.c:369:		tspi->cur_rx_pos += rx_full_count * tspi->bytes_per_word;
spi-tegra20-slink.c:379:	dma_sync_single_for_cpu(tspi->dev, tspi->tx_dma_phys,
spi-tegra20-slink.c:380:				tspi->dma_buf_size, DMA_TO_DEVICE);
spi-tegra20-slink.c:382:	if (tspi->is_packed) {
spi-tegra20-slink.c:383:		unsigned len = tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra20-slink.c:384:		memcpy(tspi->tx_dma_buf, t->tx_buf + tspi->cur_pos, len);
spi-tegra20-slink.c:388:		u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
spi-tegra20-slink.c:389:		unsigned consume = tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra20-slink.c:391:		for (count = 0; count < tspi->curr_dma_words; count++) {
spi-tegra20-slink.c:393:			for (i = 0; consume && (i < tspi->bytes_per_word);
spi-tegra20-slink.c:394:							i++, consume--)
spi-tegra20-slink.c:396:			tspi->tx_dma_buf[count] = x;
spi-tegra20-slink.c:399:	tspi->cur_tx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra20-slink.c:402:	dma_sync_single_for_device(tspi->dev, tspi->tx_dma_phys,
spi-tegra20-slink.c:403:				tspi->dma_buf_size, DMA_TO_DEVICE);
spi-tegra20-slink.c:412:	dma_sync_single_for_cpu(tspi->dev, tspi->rx_dma_phys,
spi-tegra20-slink.c:413:		tspi->dma_buf_size, DMA_FROM_DEVICE);
spi-tegra20-slink.c:415:	if (tspi->is_packed) {
spi-tegra20-slink.c:416:		len = tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra20-slink.c:417:		memcpy(t->rx_buf + tspi->cur_rx_pos, tspi->rx_dma_buf, len);
spi-tegra20-slink.c:421:		unsigned char *rx_buf = t->rx_buf + tspi->cur_rx_pos;
spi-tegra20-slink.c:422:		u32 rx_mask = ((u32)1 << t->bits_per_word) - 1;
spi-tegra20-slink.c:424:		for (count = 0; count < tspi->curr_dma_words; count++) {
spi-tegra20-slink.c:425:			u32 x = tspi->rx_dma_buf[count] & rx_mask;
spi-tegra20-slink.c:426:			for (i = 0; (i < tspi->bytes_per_word); i++)
spi-tegra20-slink.c:430:	tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra20-slink.c:433:	dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
spi-tegra20-slink.c:434:		tspi->dma_buf_size, DMA_FROM_DEVICE);
spi-tegra20-slink.c:446:	reinit_completion(&tspi->tx_dma_complete);
spi-tegra20-slink.c:447:	tspi->tx_dma_desc = dmaengine_prep_slave_single(tspi->tx_dma_chan,
spi-tegra20-slink.c:448:				tspi->tx_dma_phys, len, DMA_MEM_TO_DEV,
spi-tegra20-slink.c:450:	if (!tspi->tx_dma_desc) {
spi-tegra20-slink.c:451:		dev_err(tspi->dev, "Not able to get desc for Tx\n");
spi-tegra20-slink.c:452:		return -EIO;
spi-tegra20-slink.c:455:	tspi->tx_dma_desc->callback = tegra_slink_dma_complete;
spi-tegra20-slink.c:456:	tspi->tx_dma_desc->callback_param = &tspi->tx_dma_complete;
spi-tegra20-slink.c:458:	dmaengine_submit(tspi->tx_dma_desc);
spi-tegra20-slink.c:459:	dma_async_issue_pending(tspi->tx_dma_chan);
spi-tegra20-slink.c:465:	reinit_completion(&tspi->rx_dma_complete);
spi-tegra20-slink.c:466:	tspi->rx_dma_desc = dmaengine_prep_slave_single(tspi->rx_dma_chan,
spi-tegra20-slink.c:467:				tspi->rx_dma_phys, len, DMA_DEV_TO_MEM,
spi-tegra20-slink.c:469:	if (!tspi->rx_dma_desc) {
spi-tegra20-slink.c:470:		dev_err(tspi->dev, "Not able to get desc for Rx\n");
spi-tegra20-slink.c:471:		return -EIO;
spi-tegra20-slink.c:474:	tspi->rx_dma_desc->callback = tegra_slink_dma_complete;
spi-tegra20-slink.c:475:	tspi->rx_dma_desc->callback_param = &tspi->rx_dma_complete;
spi-tegra20-slink.c:477:	dmaengine_submit(tspi->rx_dma_desc);
spi-tegra20-slink.c:478:	dma_async_issue_pending(tspi->rx_dma_chan);
spi-tegra20-slink.c:493:		dev_err(tspi->dev, "Rx/Tx fifo are not empty status 0x%08x\n",
spi-tegra20-slink.c:495:		return -EIO;
spi-tegra20-slink.c:498:	val = SLINK_DMA_BLOCK_SIZE(tspi->curr_dma_words - 1);
spi-tegra20-slink.c:499:	val |= tspi->packed_size;
spi-tegra20-slink.c:500:	if (tspi->is_packed)
spi-tegra20-slink.c:501:		len = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,
spi-tegra20-slink.c:504:		len = tspi->curr_dma_words * 4;
spi-tegra20-slink.c:514:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra20-slink.c:517:	if (tspi->cur_direction & DATA_DIR_RX)
spi-tegra20-slink.c:521:	tspi->dma_control_reg = val;
spi-tegra20-slink.c:523:	if (tspi->cur_direction & DATA_DIR_TX) {
spi-tegra20-slink.c:528:			dev_err(tspi->dev,
spi-tegra20-slink.c:539:	if (tspi->cur_direction & DATA_DIR_RX) {
spi-tegra20-slink.c:541:		dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
spi-tegra20-slink.c:542:				tspi->dma_buf_size, DMA_FROM_DEVICE);
spi-tegra20-slink.c:546:			dev_err(tspi->dev,
spi-tegra20-slink.c:548:			if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra20-slink.c:549:				dmaengine_terminate_all(tspi->tx_dma_chan);
spi-tegra20-slink.c:553:	tspi->is_curr_dma_xfer = true;
spi-tegra20-slink.c:554:	if (tspi->is_packed) {
spi-tegra20-slink.c:560:	tspi->dma_control_reg = val;
spi-tegra20-slink.c:573:	val = tspi->packed_size;
spi-tegra20-slink.c:574:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra20-slink.c:577:	if (tspi->cur_direction & DATA_DIR_RX)
spi-tegra20-slink.c:581:	tspi->dma_control_reg = val;
spi-tegra20-slink.c:583:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra20-slink.c:586:		cur_words = tspi->curr_dma_words;
spi-tegra20-slink.c:587:	val |= SLINK_DMA_BLOCK_SIZE(cur_words - 1);
spi-tegra20-slink.c:589:	tspi->dma_control_reg = val;
spi-tegra20-slink.c:591:	tspi->is_curr_dma_xfer = false;
spi-tegra20-slink.c:592:	if (tspi->is_packed) {
spi-tegra20-slink.c:598:	tspi->dma_control_reg = val;
spi-tegra20-slink.c:613:	dma_chan = dma_request_slave_channel_reason(tspi->dev,
spi-tegra20-slink.c:617:		if (ret != -EPROBE_DEFER)
spi-tegra20-slink.c:618:			dev_err(tspi->dev,
spi-tegra20-slink.c:623:	dma_buf = dma_alloc_coherent(tspi->dev, tspi->dma_buf_size,
spi-tegra20-slink.c:626:		dev_err(tspi->dev, " Not able to allocate the dma buffer\n");
spi-tegra20-slink.c:628:		return -ENOMEM;
spi-tegra20-slink.c:632:		dma_sconfig.src_addr = tspi->phys + SLINK_RX_FIFO;
spi-tegra20-slink.c:636:		dma_sconfig.dst_addr = tspi->phys + SLINK_TX_FIFO;
spi-tegra20-slink.c:645:		tspi->rx_dma_chan = dma_chan;
spi-tegra20-slink.c:646:		tspi->rx_dma_buf = dma_buf;
spi-tegra20-slink.c:647:		tspi->rx_dma_phys = dma_phys;
spi-tegra20-slink.c:649:		tspi->tx_dma_chan = dma_chan;
spi-tegra20-slink.c:650:		tspi->tx_dma_buf = dma_buf;
spi-tegra20-slink.c:651:		tspi->tx_dma_phys = dma_phys;
spi-tegra20-slink.c:656:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
spi-tegra20-slink.c:669:		dma_buf = tspi->rx_dma_buf;
spi-tegra20-slink.c:670:		dma_chan = tspi->rx_dma_chan;
spi-tegra20-slink.c:671:		dma_phys = tspi->rx_dma_phys;
spi-tegra20-slink.c:672:		tspi->rx_dma_chan = NULL;
spi-tegra20-slink.c:673:		tspi->rx_dma_buf = NULL;
spi-tegra20-slink.c:675:		dma_buf = tspi->tx_dma_buf;
spi-tegra20-slink.c:676:		dma_chan = tspi->tx_dma_chan;
spi-tegra20-slink.c:677:		dma_phys = tspi->tx_dma_phys;
spi-tegra20-slink.c:678:		tspi->tx_dma_buf = NULL;
spi-tegra20-slink.c:679:		tspi->tx_dma_chan = NULL;
spi-tegra20-slink.c:684:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
spi-tegra20-slink.c:691:	struct tegra_slink_data *tspi = spi_master_get_devdata(spi->master);
spi-tegra20-slink.c:699:	bits_per_word = t->bits_per_word;
spi-tegra20-slink.c:700:	speed = t->speed_hz;
spi-tegra20-slink.c:701:	if (speed != tspi->cur_speed) {
spi-tegra20-slink.c:702:		clk_set_rate(tspi->clk, speed * 4);
spi-tegra20-slink.c:703:		tspi->cur_speed = speed;
spi-tegra20-slink.c:706:	tspi->cur_spi = spi;
spi-tegra20-slink.c:707:	tspi->cur_pos = 0;
spi-tegra20-slink.c:708:	tspi->cur_rx_pos = 0;
spi-tegra20-slink.c:709:	tspi->cur_tx_pos = 0;
spi-tegra20-slink.c:710:	tspi->curr_xfer = t;
spi-tegra20-slink.c:713:	command = tspi->command_reg;
spi-tegra20-slink.c:715:	command |= SLINK_BIT_LENGTH(bits_per_word - 1);
spi-tegra20-slink.c:717:	command2 = tspi->command2_reg;
spi-tegra20-slink.c:721:	tspi->command_reg = command;
spi-tegra20-slink.c:723:	tspi->cur_direction = 0;
spi-tegra20-slink.c:724:	if (t->rx_buf) {
spi-tegra20-slink.c:726:		tspi->cur_direction |= DATA_DIR_RX;
spi-tegra20-slink.c:728:	if (t->tx_buf) {
spi-tegra20-slink.c:730:		tspi->cur_direction |= DATA_DIR_TX;
spi-tegra20-slink.c:733:	tspi->command2_reg = command2;
spi-tegra20-slink.c:751:	struct tegra_slink_data *tspi = spi_master_get_devdata(spi->master);
spi-tegra20-slink.c:756:	dev_dbg(&spi->dev, "setup %d bpw, %scpol, %scpha, %dHz\n",
spi-tegra20-slink.c:757:		spi->bits_per_word,
spi-tegra20-slink.c:758:		spi->mode & SPI_CPOL ? "" : "~",
spi-tegra20-slink.c:759:		spi->mode & SPI_CPHA ? "" : "~",
spi-tegra20-slink.c:760:		spi->max_speed_hz);
spi-tegra20-slink.c:762:	ret = pm_runtime_get_sync(tspi->dev);
spi-tegra20-slink.c:764:		dev_err(tspi->dev, "pm runtime failed, e = %d\n", ret);
spi-tegra20-slink.c:768:	spin_lock_irqsave(&tspi->lock, flags);
spi-tegra20-slink.c:769:	val = tspi->def_command_reg;
spi-tegra20-slink.c:770:	if (spi->mode & SPI_CS_HIGH)
spi-tegra20-slink.c:771:		val |= cs_pol_bit[spi->chip_select];
spi-tegra20-slink.c:773:		val &= ~cs_pol_bit[spi->chip_select];
spi-tegra20-slink.c:774:	tspi->def_command_reg = val;
spi-tegra20-slink.c:775:	tegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);
spi-tegra20-slink.c:776:	spin_unlock_irqrestore(&tspi->lock, flags);
spi-tegra20-slink.c:778:	pm_runtime_put(tspi->dev);
spi-tegra20-slink.c:786:	struct spi_device *spi = msg->spi;
spi-tegra20-slink.c:790:	tspi->command_reg = tspi->def_command_reg;
spi-tegra20-slink.c:791:	tspi->command_reg |= SLINK_CS_SW | SLINK_CS_VALUE;
spi-tegra20-slink.c:793:	tspi->command2_reg = tspi->def_command2_reg;
spi-tegra20-slink.c:794:	tspi->command2_reg |= SLINK_SS_EN_CS(spi->chip_select);
spi-tegra20-slink.c:796:	tspi->command_reg &= ~SLINK_MODES;
spi-tegra20-slink.c:797:	if (spi->mode & SPI_CPHA)
spi-tegra20-slink.c:798:		tspi->command_reg |= SLINK_CK_SDA;
spi-tegra20-slink.c:800:	if (spi->mode & SPI_CPOL)
spi-tegra20-slink.c:801:		tspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_HIGH;
spi-tegra20-slink.c:803:		tspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_LOW;
spi-tegra20-slink.c:815:	reinit_completion(&tspi->xfer_completion);
spi-tegra20-slink.c:818:		dev_err(tspi->dev,
spi-tegra20-slink.c:823:	ret = wait_for_completion_timeout(&tspi->xfer_completion,
spi-tegra20-slink.c:826:		dev_err(tspi->dev,
spi-tegra20-slink.c:828:		return -EIO;
spi-tegra20-slink.c:831:	if (tspi->tx_status)
spi-tegra20-slink.c:832:		return tspi->tx_status;
spi-tegra20-slink.c:833:	if (tspi->rx_status)
spi-tegra20-slink.c:834:		return tspi->rx_status;
spi-tegra20-slink.c:844:	tegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);
spi-tegra20-slink.c:845:	tegra_slink_writel(tspi, tspi->def_command2_reg, SLINK_COMMAND2);
spi-tegra20-slink.c:852:	struct spi_transfer *t = tspi->curr_xfer;
spi-tegra20-slink.c:855:	spin_lock_irqsave(&tspi->lock, flags);
spi-tegra20-slink.c:856:	if (tspi->tx_status ||  tspi->rx_status ||
spi-tegra20-slink.c:857:				(tspi->status_reg & SLINK_BSY)) {
spi-tegra20-slink.c:858:		dev_err(tspi->dev,
spi-tegra20-slink.c:859:			"CpuXfer ERROR bit set 0x%x\n", tspi->status_reg);
spi-tegra20-slink.c:860:		dev_err(tspi->dev,
spi-tegra20-slink.c:861:			"CpuXfer 0x%08x:0x%08x:0x%08x\n", tspi->command_reg,
spi-tegra20-slink.c:862:				tspi->command2_reg, tspi->dma_control_reg);
spi-tegra20-slink.c:863:		reset_control_assert(tspi->rst);
spi-tegra20-slink.c:865:		reset_control_deassert(tspi->rst);
spi-tegra20-slink.c:866:		complete(&tspi->xfer_completion);
spi-tegra20-slink.c:870:	if (tspi->cur_direction & DATA_DIR_RX)
spi-tegra20-slink.c:873:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra20-slink.c:874:		tspi->cur_pos = tspi->cur_tx_pos;
spi-tegra20-slink.c:876:		tspi->cur_pos = tspi->cur_rx_pos;
spi-tegra20-slink.c:878:	if (tspi->cur_pos == t->len) {
spi-tegra20-slink.c:879:		complete(&tspi->xfer_completion);
spi-tegra20-slink.c:883:	tegra_slink_calculate_curr_xfer_param(tspi->cur_spi, tspi, t);
spi-tegra20-slink.c:886:	spin_unlock_irqrestore(&tspi->lock, flags);
spi-tegra20-slink.c:892:	struct spi_transfer *t = tspi->curr_xfer;
spi-tegra20-slink.c:899:	if (tspi->cur_direction & DATA_DIR_TX) {
spi-tegra20-slink.c:900:		if (tspi->tx_status) {
spi-tegra20-slink.c:901:			dmaengine_terminate_all(tspi->tx_dma_chan);
spi-tegra20-slink.c:905:				&tspi->tx_dma_complete, SLINK_DMA_TIMEOUT);
spi-tegra20-slink.c:907:				dmaengine_terminate_all(tspi->tx_dma_chan);
spi-tegra20-slink.c:908:				dev_err(tspi->dev, "TxDma Xfer failed\n");
spi-tegra20-slink.c:914:	if (tspi->cur_direction & DATA_DIR_RX) {
spi-tegra20-slink.c:915:		if (tspi->rx_status) {
spi-tegra20-slink.c:916:			dmaengine_terminate_all(tspi->rx_dma_chan);
spi-tegra20-slink.c:920:				&tspi->rx_dma_complete, SLINK_DMA_TIMEOUT);
spi-tegra20-slink.c:922:				dmaengine_terminate_all(tspi->rx_dma_chan);
spi-tegra20-slink.c:923:				dev_err(tspi->dev, "RxDma Xfer failed\n");
spi-tegra20-slink.c:929:	spin_lock_irqsave(&tspi->lock, flags);
spi-tegra20-slink.c:931:		dev_err(tspi->dev,
spi-tegra20-slink.c:932:			"DmaXfer: ERROR bit set 0x%x\n", tspi->status_reg);
spi-tegra20-slink.c:933:		dev_err(tspi->dev,
spi-tegra20-slink.c:934:			"DmaXfer 0x%08x:0x%08x:0x%08x\n", tspi->command_reg,
spi-tegra20-slink.c:935:				tspi->command2_reg, tspi->dma_control_reg);
spi-tegra20-slink.c:936:		reset_control_assert(tspi->rst);
spi-tegra20-slink.c:938:		reset_control_assert(tspi->rst);
spi-tegra20-slink.c:939:		complete(&tspi->xfer_completion);
spi-tegra20-slink.c:940:		spin_unlock_irqrestore(&tspi->lock, flags);
spi-tegra20-slink.c:944:	if (tspi->cur_direction & DATA_DIR_RX)
spi-tegra20-slink.c:947:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra20-slink.c:948:		tspi->cur_pos = tspi->cur_tx_pos;
spi-tegra20-slink.c:950:		tspi->cur_pos = tspi->cur_rx_pos;
spi-tegra20-slink.c:952:	if (tspi->cur_pos == t->len) {
spi-tegra20-slink.c:953:		complete(&tspi->xfer_completion);
spi-tegra20-slink.c:958:	total_fifo_words = tegra_slink_calculate_curr_xfer_param(tspi->cur_spi,
spi-tegra20-slink.c:966:	spin_unlock_irqrestore(&tspi->lock, flags);
spi-tegra20-slink.c:974:	if (!tspi->is_curr_dma_xfer)
spi-tegra20-slink.c:983:	tspi->status_reg = tegra_slink_readl(tspi, SLINK_STATUS);
spi-tegra20-slink.c:984:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra20-slink.c:985:		tspi->tx_status = tspi->status_reg &
spi-tegra20-slink.c:988:	if (tspi->cur_direction & DATA_DIR_RX)
spi-tegra20-slink.c:989:		tspi->rx_status = tspi->status_reg &
spi-tegra20-slink.c:1005:	{ .compatible = "nvidia,tegra30-slink", .data = &tegra30_spi_cdata, },
spi-tegra20-slink.c:1006:	{ .compatible = "nvidia,tegra20-slink", .data = &tegra20_spi_cdata, },
spi-tegra20-slink.c:1020:	match = of_match_device(tegra_slink_of_match, &pdev->dev);
spi-tegra20-slink.c:1022:		dev_err(&pdev->dev, "Error: No device match found\n");
spi-tegra20-slink.c:1023:		return -ENODEV;
spi-tegra20-slink.c:1025:	cdata = match->data;
spi-tegra20-slink.c:1027:	master = spi_alloc_master(&pdev->dev, sizeof(*tspi));
spi-tegra20-slink.c:1029:		dev_err(&pdev->dev, "master allocation failed\n");
spi-tegra20-slink.c:1030:		return -ENOMEM;
spi-tegra20-slink.c:1033:	/* the spi->mode bits understood by this driver: */
spi-tegra20-slink.c:1034:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-tegra20-slink.c:1035:	master->setup = tegra_slink_setup;
spi-tegra20-slink.c:1036:	master->prepare_message = tegra_slink_prepare_message;
spi-tegra20-slink.c:1037:	master->transfer_one = tegra_slink_transfer_one;
spi-tegra20-slink.c:1038:	master->unprepare_message = tegra_slink_unprepare_message;
spi-tegra20-slink.c:1039:	master->auto_runtime_pm = true;
spi-tegra20-slink.c:1040:	master->num_chipselect = MAX_CHIP_SELECT;
spi-tegra20-slink.c:1044:	tspi->master = master;
spi-tegra20-slink.c:1045:	tspi->dev = &pdev->dev;
spi-tegra20-slink.c:1046:	tspi->chip_data = cdata;
spi-tegra20-slink.c:1047:	spin_lock_init(&tspi->lock);
spi-tegra20-slink.c:1049:	if (of_property_read_u32(tspi->dev->of_node, "spi-max-frequency",
spi-tegra20-slink.c:1050:				 &master->max_speed_hz))
spi-tegra20-slink.c:1051:		master->max_speed_hz = 25000000; /* 25MHz */
spi-tegra20-slink.c:1055:		dev_err(&pdev->dev, "No IO memory resource\n");
spi-tegra20-slink.c:1056:		ret = -ENODEV;
spi-tegra20-slink.c:1059:	tspi->phys = r->start;
spi-tegra20-slink.c:1060:	tspi->base = devm_ioremap_resource(&pdev->dev, r);
spi-tegra20-slink.c:1061:	if (IS_ERR(tspi->base)) {
spi-tegra20-slink.c:1062:		ret = PTR_ERR(tspi->base);
spi-tegra20-slink.c:1067:	tspi->clk = devm_clk_get(&pdev->dev, NULL);
spi-tegra20-slink.c:1068:	if (IS_ERR(tspi->clk)) {
spi-tegra20-slink.c:1069:		ret = PTR_ERR(tspi->clk);
spi-tegra20-slink.c:1070:		dev_err(&pdev->dev, "Can not get clock %d\n", ret);
spi-tegra20-slink.c:1073:	ret = clk_prepare(tspi->clk);
spi-tegra20-slink.c:1075:		dev_err(&pdev->dev, "Clock prepare failed %d\n", ret);
spi-tegra20-slink.c:1078:	ret = clk_enable(tspi->clk);
spi-tegra20-slink.c:1080:		dev_err(&pdev->dev, "Clock enable failed %d\n", ret);
spi-tegra20-slink.c:1085:	tspi->irq = spi_irq;
spi-tegra20-slink.c:1086:	ret = request_threaded_irq(tspi->irq, tegra_slink_isr,
spi-tegra20-slink.c:1088:			dev_name(&pdev->dev), tspi);
spi-tegra20-slink.c:1090:		dev_err(&pdev->dev, "Failed to register ISR for IRQ %d\n",
spi-tegra20-slink.c:1091:					tspi->irq);
spi-tegra20-slink.c:1095:	tspi->rst = devm_reset_control_get(&pdev->dev, "spi");
spi-tegra20-slink.c:1096:	if (IS_ERR(tspi->rst)) {
spi-tegra20-slink.c:1097:		dev_err(&pdev->dev, "can not get reset\n");
spi-tegra20-slink.c:1098:		ret = PTR_ERR(tspi->rst);
spi-tegra20-slink.c:1102:	tspi->max_buf_size = SLINK_FIFO_DEPTH << 2;
spi-tegra20-slink.c:1103:	tspi->dma_buf_size = DEFAULT_SPI_DMA_BUF_LEN;
spi-tegra20-slink.c:1111:	tspi->max_buf_size = tspi->dma_buf_size;
spi-tegra20-slink.c:1112:	init_completion(&tspi->tx_dma_complete);
spi-tegra20-slink.c:1113:	init_completion(&tspi->rx_dma_complete);
spi-tegra20-slink.c:1115:	init_completion(&tspi->xfer_completion);
spi-tegra20-slink.c:1117:	pm_runtime_enable(&pdev->dev);
spi-tegra20-slink.c:1118:	if (!pm_runtime_enabled(&pdev->dev)) {
spi-tegra20-slink.c:1119:		ret = tegra_slink_runtime_resume(&pdev->dev);
spi-tegra20-slink.c:1124:	ret = pm_runtime_get_sync(&pdev->dev);
spi-tegra20-slink.c:1126:		dev_err(&pdev->dev, "pm runtime get failed, e = %d\n", ret);
spi-tegra20-slink.c:1129:	tspi->def_command_reg  = SLINK_M_S;
spi-tegra20-slink.c:1130:	tspi->def_command2_reg = SLINK_CS_ACTIVE_BETWEEN;
spi-tegra20-slink.c:1131:	tegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);
spi-tegra20-slink.c:1132:	tegra_slink_writel(tspi, tspi->def_command2_reg, SLINK_COMMAND2);
spi-tegra20-slink.c:1133:	pm_runtime_put(&pdev->dev);
spi-tegra20-slink.c:1135:	master->dev.of_node = pdev->dev.of_node;
spi-tegra20-slink.c:1136:	ret = devm_spi_register_master(&pdev->dev, master);
spi-tegra20-slink.c:1138:		dev_err(&pdev->dev, "can not register to master err %d\n", ret);
spi-tegra20-slink.c:1144:	pm_runtime_disable(&pdev->dev);
spi-tegra20-slink.c:1145:	if (!pm_runtime_status_suspended(&pdev->dev))
spi-tegra20-slink.c:1146:		tegra_slink_runtime_suspend(&pdev->dev);
spi-tegra20-slink.c:1153:	clk_disable(tspi->clk);
spi-tegra20-slink.c:1164:	free_irq(tspi->irq, tspi);
spi-tegra20-slink.c:1166:	clk_disable(tspi->clk);
spi-tegra20-slink.c:1168:	if (tspi->tx_dma_chan)
spi-tegra20-slink.c:1171:	if (tspi->rx_dma_chan)
spi-tegra20-slink.c:1174:	pm_runtime_disable(&pdev->dev);
spi-tegra20-slink.c:1175:	if (!pm_runtime_status_suspended(&pdev->dev))
spi-tegra20-slink.c:1176:		tegra_slink_runtime_suspend(&pdev->dev);
spi-tegra20-slink.c:1200:	tegra_slink_writel(tspi, tspi->command_reg, SLINK_COMMAND);
spi-tegra20-slink.c:1201:	tegra_slink_writel(tspi, tspi->command2_reg, SLINK_COMMAND2);
spi-tegra20-slink.c:1216:	clk_disable_unprepare(tspi->clk);
spi-tegra20-slink.c:1226:	ret = clk_prepare_enable(tspi->clk);
spi-tegra20-slink.c:1228:		dev_err(tspi->dev, "clk_prepare failed: %d\n", ret);
spi-tegra20-slink.c:1241:		.name		= "spi-tegra-slink",
spi-tegra20-slink.c:1250:MODULE_ALIAS("platform:spi-tegra-slink");
spi-dw-mid.c:16:#include <linux/dma-mapping.h>
spi-dw-mid.c:23:#include "spi-dw.h"
spi-dw-mid.c:27:#include <linux/platform_data/dma-dw.h>
spi-dw-mid.c:39:	if (s->dma_dev != chan->device->dev)
spi-dw-mid.c:42:	chan->private = s;
spi-dw-mid.c:49:	struct dw_dma_slave *tx = dws->dma_tx;
spi-dw-mid.c:50:	struct dw_dma_slave *rx = dws->dma_rx;
spi-dw-mid.c:59:		return -ENODEV;
spi-dw-mid.c:65:	rx->dma_dev = &dma_dev->dev;
spi-dw-mid.c:66:	dws->rxchan = dma_request_channel(mask, mid_spi_dma_chan_filter, rx);
spi-dw-mid.c:67:	if (!dws->rxchan)
spi-dw-mid.c:69:	dws->master->dma_rx = dws->rxchan;
spi-dw-mid.c:72:	tx->dma_dev = &dma_dev->dev;
spi-dw-mid.c:73:	dws->txchan = dma_request_channel(mask, mid_spi_dma_chan_filter, tx);
spi-dw-mid.c:74:	if (!dws->txchan)
spi-dw-mid.c:76:	dws->master->dma_tx = dws->txchan;
spi-dw-mid.c:78:	dws->dma_inited = 1;
spi-dw-mid.c:82:	dma_release_channel(dws->rxchan);
spi-dw-mid.c:84:	return -EBUSY;
spi-dw-mid.c:89:	if (!dws->dma_inited)
spi-dw-mid.c:92:	dmaengine_terminate_all(dws->txchan);
spi-dw-mid.c:93:	dma_release_channel(dws->txchan);
spi-dw-mid.c:95:	dmaengine_terminate_all(dws->rxchan);
spi-dw-mid.c:96:	dma_release_channel(dws->rxchan);
spi-dw-mid.c:109:	dev_err(&dws->master->dev, "%s: FIFO overrun/underrun\n", __func__);
spi-dw-mid.c:110:	dws->master->cur_msg->status = -EIO;
spi-dw-mid.c:111:	spi_finalize_current_transfer(dws->master);
spi-dw-mid.c:120:	if (!dws->dma_inited)
spi-dw-mid.c:123:	return xfer->len > dws->fifo_len;
spi-dw-mid.c:136: * dws->dma_chan_busy is set before the dma transfer starts, callback for tx
spi-dw-mid.c:143:	clear_bit(TX_BUSY, &dws->dma_chan_busy);
spi-dw-mid.c:144:	if (test_bit(RX_BUSY, &dws->dma_chan_busy))
spi-dw-mid.c:146:	spi_finalize_current_transfer(dws->master);
spi-dw-mid.c:155:	if (!xfer->tx_buf)
spi-dw-mid.c:159:	txconf.dst_addr = dws->dma_addr;
spi-dw-mid.c:162:	txconf.dst_addr_width = convert_dma_width(dws->dma_width);
spi-dw-mid.c:165:	dmaengine_slave_config(dws->txchan, &txconf);
spi-dw-mid.c:167:	txdesc = dmaengine_prep_slave_sg(dws->txchan,
spi-dw-mid.c:168:				xfer->tx_sg.sgl,
spi-dw-mid.c:169:				xfer->tx_sg.nents,
spi-dw-mid.c:175:	txdesc->callback = dw_spi_dma_tx_done;
spi-dw-mid.c:176:	txdesc->callback_param = dws;
spi-dw-mid.c:182: * dws->dma_chan_busy is set before the dma transfer starts, callback for rx
spi-dw-mid.c:189:	clear_bit(RX_BUSY, &dws->dma_chan_busy);
spi-dw-mid.c:190:	if (test_bit(TX_BUSY, &dws->dma_chan_busy))
spi-dw-mid.c:192:	spi_finalize_current_transfer(dws->master);
spi-dw-mid.c:201:	if (!xfer->rx_buf)
spi-dw-mid.c:205:	rxconf.src_addr = dws->dma_addr;
spi-dw-mid.c:208:	rxconf.src_addr_width = convert_dma_width(dws->dma_width);
spi-dw-mid.c:211:	dmaengine_slave_config(dws->rxchan, &rxconf);
spi-dw-mid.c:213:	rxdesc = dmaengine_prep_slave_sg(dws->rxchan,
spi-dw-mid.c:214:				xfer->rx_sg.sgl,
spi-dw-mid.c:215:				xfer->rx_sg.nents,
spi-dw-mid.c:221:	rxdesc->callback = dw_spi_dma_rx_done;
spi-dw-mid.c:222:	rxdesc->callback_param = dws;
spi-dw-mid.c:234:	if (xfer->tx_buf)
spi-dw-mid.c:236:	if (xfer->rx_buf)
spi-dw-mid.c:243:	dws->transfer_handler = dma_transfer;
spi-dw-mid.c:260:		set_bit(RX_BUSY, &dws->dma_chan_busy);
spi-dw-mid.c:262:		dma_async_issue_pending(dws->rxchan);
spi-dw-mid.c:266:		set_bit(TX_BUSY, &dws->dma_chan_busy);
spi-dw-mid.c:268:		dma_async_issue_pending(dws->txchan);
spi-dw-mid.c:276:	if (test_bit(TX_BUSY, &dws->dma_chan_busy)) {
spi-dw-mid.c:277:		dmaengine_terminate_all(dws->txchan);
spi-dw-mid.c:278:		clear_bit(TX_BUSY, &dws->dma_chan_busy);
spi-dw-mid.c:280:	if (test_bit(RX_BUSY, &dws->dma_chan_busy)) {
spi-dw-mid.c:281:		dmaengine_terminate_all(dws->rxchan);
spi-dw-mid.c:282:		clear_bit(RX_BUSY, &dws->dma_chan_busy);
spi-dw-mid.c:314:		return -ENOMEM;
spi-dw-mid.c:317:	clk_cdiv = readl(clk_reg + dws->bus_num * sizeof(u32));
spi-dw-mid.c:320:	dws->max_freq = MRST_SPI_CLK_BASE / (clk_cdiv + 1);
spi-dw-mid.c:325:	dws->dma_tx = &mid_dma_tx;
spi-dw-mid.c:326:	dws->dma_rx = &mid_dma_rx;
spi-dw-mid.c:327:	dws->dma_ops = &mid_dma_ops;
spi-xcomm.c:2: * Analog Devices AD-FMCOMMS1-EBZ board I2C-SPI bridge driver
spi-xcomm.c:5: * Author: Lars-Peter Clausen <lars@metafoo.de>
spi-xcomm.c:7: * Licensed under the GPL-2 or later.
spi-xcomm.c:47:	uint8_t *buf = spi_xcomm->buf;
spi-xcomm.c:49:	settings = spi_xcomm->settings;
spi-xcomm.c:54:	put_unaligned_be16(spi_xcomm->chipselect, &buf[3]);
spi-xcomm.c:56:	return i2c_master_send(spi_xcomm->i2c, buf, 5);
spi-xcomm.c:62:	unsigned long cs = spi->chip_select;
spi-xcomm.c:63:	uint16_t chipselect = spi_xcomm->chipselect;
spi-xcomm.c:70:	spi_xcomm->chipselect = chipselect;
spi-xcomm.c:76:	if (t->len > 62)
spi-xcomm.c:77:		return -EINVAL;
spi-xcomm.c:79:	if (t->speed_hz != spi_xcomm->current_speed) {
spi-xcomm.c:82:		divider = DIV_ROUND_UP(SPI_XCOMM_CLOCK, t->speed_hz);
spi-xcomm.c:90:		spi_xcomm->current_speed = t->speed_hz;
spi-xcomm.c:93:	if (spi->mode & SPI_CPOL)
spi-xcomm.c:98:	if (spi->mode & SPI_CPHA)
spi-xcomm.c:103:	if (spi->mode & SPI_3WIRE)
spi-xcomm.c:116:	if (t->tx_buf) {
spi-xcomm.c:117:		spi_xcomm->buf[0] = SPI_XCOMM_CMD_WRITE;
spi-xcomm.c:118:		memcpy(spi_xcomm->buf + 1, t->tx_buf, t->len);
spi-xcomm.c:120:		ret = i2c_master_send(spi_xcomm->i2c, spi_xcomm->buf, t->len + 1);
spi-xcomm.c:123:		else if (ret != t->len + 1)
spi-xcomm.c:124:			return -EIO;
spi-xcomm.c:125:	} else if (t->rx_buf) {
spi-xcomm.c:126:		ret = i2c_master_recv(spi_xcomm->i2c, t->rx_buf, t->len);
spi-xcomm.c:129:		else if (ret != t->len)
spi-xcomm.c:130:			return -EIO;
spi-xcomm.c:133:	return t->len;
spi-xcomm.c:140:	unsigned int settings = spi_xcomm->settings;
spi-xcomm.c:141:	struct spi_device *spi = msg->spi;
spi-xcomm.c:150:	list_for_each_entry(t, &msg->transfers, transfer_list) {
spi-xcomm.c:152:		if (!t->tx_buf && !t->rx_buf && t->len) {
spi-xcomm.c:153:			status = -EINVAL;
spi-xcomm.c:161:		is_last = list_is_last(&t->transfer_list, &msg->transfers);
spi-xcomm.c:162:		cs_change = t->cs_change;
spi-xcomm.c:169:		if (t->rx_buf) {
spi-xcomm.c:170:			spi_xcomm->settings = settings;
spi-xcomm.c:171:			status = spi_xcomm_sync_config(spi_xcomm, t->len);
spi-xcomm.c:174:		} else if (settings != spi_xcomm->settings || is_first) {
spi-xcomm.c:175:			spi_xcomm->settings = settings;
spi-xcomm.c:181:		if (t->len) {
spi-xcomm.c:188:				msg->actual_length += status;
spi-xcomm.c:192:		if (t->delay_usecs)
spi-xcomm.c:193:			udelay(t->delay_usecs);
spi-xcomm.c:201:	msg->status = status;
spi-xcomm.c:214:	master = spi_alloc_master(&i2c->dev, sizeof(*spi_xcomm));
spi-xcomm.c:216:		return -ENOMEM;
spi-xcomm.c:219:	spi_xcomm->i2c = i2c;
spi-xcomm.c:221:	master->num_chipselect = 16;
spi-xcomm.c:222:	master->mode_bits = SPI_CPHA | SPI_CPOL | SPI_3WIRE;
spi-xcomm.c:223:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-xcomm.c:224:	master->flags = SPI_MASTER_HALF_DUPLEX;
spi-xcomm.c:225:	master->transfer_one_message = spi_xcomm_transfer_one;
spi-xcomm.c:226:	master->dev.of_node = i2c->dev.of_node;
spi-xcomm.c:229:	ret = devm_spi_register_master(&i2c->dev, master);
spi-xcomm.c:237:	{ "spi-xcomm" },
spi-xcomm.c:244:		.name	= "spi-xcomm",
spi-xcomm.c:252:MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
spi-xcomm.c:253:MODULE_DESCRIPTION("Analog Devices AD-FMCOMMS1-EBZ board I2C-SPI bridge driver");
spi-pxa2xx-dma.c:13:#include <linux/dma-mapping.h>
spi-pxa2xx-dma.c:21:#include "spi-pxa2xx.h"
spi-pxa2xx-dma.c:26:	int i, nents, len = drv_data->len;
spi-pxa2xx-dma.c:33:		dmadev = drv_data->tx_chan->device->dev;
spi-pxa2xx-dma.c:34:		sgt = &drv_data->tx_sgt;
spi-pxa2xx-dma.c:35:		buf = drv_data->tx;
spi-pxa2xx-dma.c:36:		drv_data->tx_map_len = len;
spi-pxa2xx-dma.c:38:		dmadev = drv_data->rx_chan->device->dev;
spi-pxa2xx-dma.c:39:		sgt = &drv_data->rx_sgt;
spi-pxa2xx-dma.c:40:		buf = drv_data->rx;
spi-pxa2xx-dma.c:41:		drv_data->rx_map_len = len;
spi-pxa2xx-dma.c:45:	if (nents != sgt->nents) {
spi-pxa2xx-dma.c:55:	for_each_sg(sgt->sgl, sg, sgt->nents, i) {
spi-pxa2xx-dma.c:61:			sg_set_buf(sg, drv_data->dummy, bytes);
spi-pxa2xx-dma.c:64:		len -= bytes;
spi-pxa2xx-dma.c:67:	nents = dma_map_sg(dmadev, sgt->sgl, sgt->nents, dir);
spi-pxa2xx-dma.c:69:		return -ENOMEM;
spi-pxa2xx-dma.c:81:		dmadev = drv_data->tx_chan->device->dev;
spi-pxa2xx-dma.c:82:		sgt = &drv_data->tx_sgt;
spi-pxa2xx-dma.c:84:		dmadev = drv_data->rx_chan->device->dev;
spi-pxa2xx-dma.c:85:		sgt = &drv_data->rx_sgt;
spi-pxa2xx-dma.c:88:	dma_unmap_sg(dmadev, sgt->sgl, sgt->nents, dir);
spi-pxa2xx-dma.c:93:	if (!drv_data->dma_mapped)
spi-pxa2xx-dma.c:99:	drv_data->dma_mapped = 0;
spi-pxa2xx-dma.c:105:	struct spi_message *msg = drv_data->cur_msg;
spi-pxa2xx-dma.c:111:	 * by using ->dma_running.
spi-pxa2xx-dma.c:113:	if (atomic_dec_and_test(&drv_data->dma_running)) {
spi-pxa2xx-dma.c:116:		 * might not know about the error yet. So we re-check the
spi-pxa2xx-dma.c:121:				     & drv_data->mask_sr;
spi-pxa2xx-dma.c:128:				 & ~drv_data->dma_cr1);
spi-pxa2xx-dma.c:129:		write_SSSR_CS(drv_data, drv_data->clear_sr);
spi-pxa2xx-dma.c:136:			drv_data->tx += drv_data->tx_map_len;
spi-pxa2xx-dma.c:137:			drv_data->rx += drv_data->rx_map_len;
spi-pxa2xx-dma.c:139:			msg->actual_length += drv_data->len;
spi-pxa2xx-dma.c:140:			msg->state = pxa2xx_spi_next_transfer(drv_data);
spi-pxa2xx-dma.c:147:			msg->state = ERROR_STATE;
spi-pxa2xx-dma.c:150:		tasklet_schedule(&drv_data->pump_transfers);
spi-pxa2xx-dma.c:163:	struct chip_data *chip = drv_data->cur_chip;
spi-pxa2xx-dma.c:170:	switch (drv_data->n_bytes) {
spi-pxa2xx-dma.c:186:		cfg.dst_addr = drv_data->ssdr_physical;
spi-pxa2xx-dma.c:188:		cfg.dst_maxburst = chip->dma_burst_size;
spi-pxa2xx-dma.c:190:		sgt = &drv_data->tx_sgt;
spi-pxa2xx-dma.c:191:		nents = drv_data->tx_nents;
spi-pxa2xx-dma.c:192:		chan = drv_data->tx_chan;
spi-pxa2xx-dma.c:194:		cfg.src_addr = drv_data->ssdr_physical;
spi-pxa2xx-dma.c:196:		cfg.src_maxburst = chip->dma_burst_size;
spi-pxa2xx-dma.c:198:		sgt = &drv_data->rx_sgt;
spi-pxa2xx-dma.c:199:		nents = drv_data->rx_nents;
spi-pxa2xx-dma.c:200:		chan = drv_data->rx_chan;
spi-pxa2xx-dma.c:205:		dev_warn(&drv_data->pdev->dev, "DMA slave config failed\n");
spi-pxa2xx-dma.c:209:	return dmaengine_prep_slave_sg(chan, sgt->sgl, nents, dir,
spi-pxa2xx-dma.c:220:	const struct chip_data *chip = drv_data->cur_chip;
spi-pxa2xx-dma.c:223:	if (!chip->enable_dma)
spi-pxa2xx-dma.c:227:	if (drv_data->len < chip->dma_burst_size)
spi-pxa2xx-dma.c:232:		dev_warn(&drv_data->pdev->dev, "failed to DMA map TX\n");
spi-pxa2xx-dma.c:236:	drv_data->tx_nents = ret;
spi-pxa2xx-dma.c:241:		dev_warn(&drv_data->pdev->dev, "failed to DMA map RX\n");
spi-pxa2xx-dma.c:245:	drv_data->rx_nents = ret;
spi-pxa2xx-dma.c:253:	status = pxa2xx_spi_read(drv_data, SSSR) & drv_data->mask_sr;
spi-pxa2xx-dma.c:255:		dev_err(&drv_data->pdev->dev, "FIFO overrun\n");
spi-pxa2xx-dma.c:257:		dmaengine_terminate_all(drv_data->rx_chan);
spi-pxa2xx-dma.c:258:		dmaengine_terminate_all(drv_data->tx_chan);
spi-pxa2xx-dma.c:273:		dev_err(&drv_data->pdev->dev,
spi-pxa2xx-dma.c:275:		return -EBUSY;
spi-pxa2xx-dma.c:280:		dev_err(&drv_data->pdev->dev,
spi-pxa2xx-dma.c:282:		return -EBUSY;
spi-pxa2xx-dma.c:286:	rx_desc->callback = pxa2xx_spi_dma_callback;
spi-pxa2xx-dma.c:287:	rx_desc->callback_param = drv_data;
spi-pxa2xx-dma.c:296:	dma_async_issue_pending(drv_data->rx_chan);
spi-pxa2xx-dma.c:297:	dma_async_issue_pending(drv_data->tx_chan);
spi-pxa2xx-dma.c:299:	atomic_set(&drv_data->dma_running, 1);
spi-pxa2xx-dma.c:304:	struct pxa2xx_spi_master *pdata = drv_data->master_info;
spi-pxa2xx-dma.c:305:	struct device *dev = &drv_data->pdev->dev;
spi-pxa2xx-dma.c:311:	drv_data->dummy = devm_kzalloc(dev, SZ_2K, GFP_KERNEL);
spi-pxa2xx-dma.c:312:	if (!drv_data->dummy)
spi-pxa2xx-dma.c:313:		return -ENOMEM;
spi-pxa2xx-dma.c:315:	drv_data->tx_chan = dma_request_slave_channel_compat(mask,
spi-pxa2xx-dma.c:316:				pdata->dma_filter, pdata->tx_param, dev, "tx");
spi-pxa2xx-dma.c:317:	if (!drv_data->tx_chan)
spi-pxa2xx-dma.c:318:		return -ENODEV;
spi-pxa2xx-dma.c:320:	drv_data->rx_chan = dma_request_slave_channel_compat(mask,
spi-pxa2xx-dma.c:321:				pdata->dma_filter, pdata->rx_param, dev, "rx");
spi-pxa2xx-dma.c:322:	if (!drv_data->rx_chan) {
spi-pxa2xx-dma.c:323:		dma_release_channel(drv_data->tx_chan);
spi-pxa2xx-dma.c:324:		drv_data->tx_chan = NULL;
spi-pxa2xx-dma.c:325:		return -ENODEV;
spi-pxa2xx-dma.c:333:	if (drv_data->rx_chan) {
spi-pxa2xx-dma.c:334:		dmaengine_terminate_all(drv_data->rx_chan);
spi-pxa2xx-dma.c:335:		dma_release_channel(drv_data->rx_chan);
spi-pxa2xx-dma.c:336:		sg_free_table(&drv_data->rx_sgt);
spi-pxa2xx-dma.c:337:		drv_data->rx_chan = NULL;
spi-pxa2xx-dma.c:339:	if (drv_data->tx_chan) {
spi-pxa2xx-dma.c:340:		dmaengine_terminate_all(drv_data->tx_chan);
spi-pxa2xx-dma.c:341:		dma_release_channel(drv_data->tx_chan);
spi-pxa2xx-dma.c:342:		sg_free_table(&drv_data->tx_sgt);
spi-pxa2xx-dma.c:343:		drv_data->tx_chan = NULL;
spi-pxa2xx-dma.c:352:	struct pxa2xx_spi_chip *chip_info = spi->controller_data;
spi-pxa2xx-dma.c:359:	*burst_code = chip_info ? chip_info->dma_burst_size : 1;
spi-rspi.c:7: * Based on spi-sh.c:
spi-rspi.c:29:#include <linux/dma-mapping.h>
spi-rspi.c:47:#define RSPI_SPND		0x0e	/* Next-Access Delay Register */
spi-rspi.c:75:/* SPCR - Control Register */
spi-rspi.c:84:#define SPCR_SPMS		0x01	/* 3-wire Mode (vs. 4-wire) */
spi-rspi.c:85:/* QSPI on R-Car Gen2 only */
spi-rspi.c:86:#define SPCR_WSWAP		0x02	/* Word Swap of read-data for DMAC */
spi-rspi.c:87:#define SPCR_BSWAP		0x01	/* Byte Swap of read-data for DMAC */
spi-rspi.c:89:/* SSLP - Slave Select Polarity Register */
spi-rspi.c:93:/* SPPCR - Pin Control Register */
spi-rspi.c:97:#define SPPCR_SPLP2		0x02	/* Loopback Mode 2 (non-inverting) */
spi-rspi.c:100:#define SPPCR_IO3FV		0x04	/* Single-/Dual-SPI Mode IO3 Output Fixed Value */
spi-rspi.c:101:#define SPPCR_IO2FV		0x04	/* Single-/Dual-SPI Mode IO2 Output Fixed Value */
spi-rspi.c:103:/* SPSR - Status Register */
spi-rspi.c:112:/* SPSCR - Sequence Control Register */
spi-rspi.c:115:/* SPSSR - Sequence Status Register */
spi-rspi.c:119:/* SPDCR - Data Control Register */
spi-rspi.c:133:#define SPDCR_SPFC_MASK		0x03	/* Frame Count Setting (1-4) (SH) */
spi-rspi.c:135:/* SPCKD - Clock Delay Register */
spi-rspi.c:136:#define SPCKD_SCKDL_MASK	0x07	/* Clock Delay Setting (1-8) */
spi-rspi.c:138:/* SSLND - Slave Select Negation Delay Register */
spi-rspi.c:139:#define SSLND_SLNDL_MASK	0x07	/* SSL Negation Delay Setting (1-8) */
spi-rspi.c:141:/* SPND - Next-Access Delay Register */
spi-rspi.c:142:#define SPND_SPNDL_MASK		0x07	/* Next-Access Delay Setting (1-8) */
spi-rspi.c:144:/* SPCR2 - Control Register 2 */
spi-rspi.c:145:#define SPCR2_PTE		0x08	/* Parity Self-Test Enable */
spi-rspi.c:150:/* SPCMDn - Command Registers */
spi-rspi.c:153:#define SPCMD_SPNDEN		0x2000	/* Next-Access Delay Enable */
spi-rspi.c:156:#define SPCMD_SPB_8_TO_16(bit)	(((bit - 1) << 8) & SPCMD_SPB_MASK)
spi-rspi.c:175:/* SPBFCR - Buffer Control Register */
spi-rspi.c:180:/* QSPI on R-Car Gen2 */
spi-rspi.c:206:	iowrite8(data, rspi->addr + offset);
spi-rspi.c:211:	iowrite16(data, rspi->addr + offset);
spi-rspi.c:216:	iowrite32(data, rspi->addr + offset);
spi-rspi.c:221:	return ioread8(rspi->addr + offset);
spi-rspi.c:226:	return ioread16(rspi->addr + offset);
spi-rspi.c:231:	if (rspi->byte_access)
spi-rspi.c:239:	if (rspi->byte_access)
spi-rspi.c:263:	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
spi-rspi.c:266:	spbr = DIV_ROUND_UP(clk_get_rate(rspi->clk),
spi-rspi.c:267:			    2 * rspi->max_speed_hz) - 1;
spi-rspi.c:270:	/* Disable dummy transmission, set 16-bit word access, 1 frame */
spi-rspi.c:272:	rspi->byte_access = 0;
spi-rspi.c:274:	/* Sets RSPCK, SSL, next-access delay value */
spi-rspi.c:284:	rspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);
spi-rspi.c:285:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
spi-rspi.c:301:	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
spi-rspi.c:304:	spbr = DIV_ROUND_UP(clk_get_rate(rspi->clk),
spi-rspi.c:305:			    2 * rspi->max_speed_hz) - 1;
spi-rspi.c:310:	rspi->byte_access = 1;
spi-rspi.c:312:	/* Sets RSPCK, SSL, next-access delay value */
spi-rspi.c:319:	rspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);
spi-rspi.c:320:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
spi-rspi.c:336:	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
spi-rspi.c:339:	spbr = DIV_ROUND_UP(clk_get_rate(rspi->clk), 2 * rspi->max_speed_hz);
spi-rspi.c:344:	rspi->byte_access = 1;
spi-rspi.c:346:	/* Sets RSPCK, SSL, next-access delay value */
spi-rspi.c:353:		rspi->spcmd |= SPCMD_SPB_8BIT;
spi-rspi.c:355:		rspi->spcmd |= SPCMD_SPB_16BIT;
spi-rspi.c:357:		rspi->spcmd |= SPCMD_SPB_32BIT;
spi-rspi.c:359:	rspi->spcmd |= SPCMD_SCKDEN | SPCMD_SLNDEN | SPCMD_SPNDEN;
spi-rspi.c:371:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
spi-rspi.c:426:#define set_config_register(spi, n) spi->ops->set_config_register(spi, n)
spi-rspi.c:443:	rspi->spsr = rspi_read8(rspi, RSPI_SPSR);
spi-rspi.c:444:	if (rspi->spsr & wait_mask)
spi-rspi.c:448:	ret = wait_event_timeout(rspi->wait, rspi->spsr & wait_mask, HZ);
spi-rspi.c:449:	if (ret == 0 && !(rspi->spsr & wait_mask))
spi-rspi.c:450:		return -ETIMEDOUT;
spi-rspi.c:469:		dev_err(&rspi->master->dev, "transmit timeout\n");
spi-rspi.c:483:		dev_err(&rspi->master->dev, "receive timeout\n");
spi-rspi.c:493:	while (n-- > 0) {
spi-rspi.c:514:	rspi->dma_callbacked = 1;
spi-rspi.c:515:	wake_up_interruptible(&rspi->wait);
spi-rspi.c:529:		desc_rx = dmaengine_prep_slave_sg(rspi->master->dma_rx,
spi-rspi.c:530:					rx->sgl, rx->nents, DMA_FROM_DEVICE,
spi-rspi.c:533:			ret = -EAGAIN;
spi-rspi.c:537:		desc_rx->callback = rspi_dma_complete;
spi-rspi.c:538:		desc_rx->callback_param = rspi;
spi-rspi.c:549:		desc_tx = dmaengine_prep_slave_sg(rspi->master->dma_tx,
spi-rspi.c:550:					tx->sgl, tx->nents, DMA_TO_DEVICE,
spi-rspi.c:553:			ret = -EAGAIN;
spi-rspi.c:559:			desc_tx->callback = NULL;
spi-rspi.c:561:			desc_tx->callback = rspi_dma_complete;
spi-rspi.c:562:			desc_tx->callback_param = rspi;
spi-rspi.c:578:		disable_irq(other_irq = rspi->tx_irq);
spi-rspi.c:579:	if (rx && rspi->rx_irq != other_irq)
spi-rspi.c:580:		disable_irq(rspi->rx_irq);
spi-rspi.c:583:	rspi->dma_callbacked = 0;
spi-rspi.c:587:		dma_async_issue_pending(rspi->master->dma_rx);
spi-rspi.c:589:		dma_async_issue_pending(rspi->master->dma_tx);
spi-rspi.c:591:	ret = wait_event_interruptible_timeout(rspi->wait,
spi-rspi.c:592:					       rspi->dma_callbacked, HZ);
spi-rspi.c:593:	if (ret > 0 && rspi->dma_callbacked) {
spi-rspi.c:597:			dev_err(&rspi->master->dev, "DMA timeout\n");
spi-rspi.c:598:			ret = -ETIMEDOUT;
spi-rspi.c:601:			dmaengine_terminate_all(rspi->master->dma_tx);
spi-rspi.c:603:			dmaengine_terminate_all(rspi->master->dma_rx);
spi-rspi.c:609:		enable_irq(rspi->tx_irq);
spi-rspi.c:610:	if (rx && rspi->rx_irq != other_irq)
spi-rspi.c:611:		enable_irq(rspi->rx_irq);
spi-rspi.c:617:		dmaengine_terminate_all(rspi->master->dma_rx);
spi-rspi.c:619:	if (ret == -EAGAIN) {
spi-rspi.c:621:			     dev_driver_string(&rspi->master->dev),
spi-rspi.c:622:			     dev_name(&rspi->master->dev));
spi-rspi.c:660:	return xfer->len > rspi->ops->fifo_size;
spi-rspi.c:674:	if (!rspi->master->can_dma || !__rspi_can_dma(rspi, xfer))
spi-rspi.c:675:		return -EAGAIN;
spi-rspi.c:677:	/* rx_buf can be NULL on RSPI on SH in TX-only Mode */
spi-rspi.c:678:	return rspi_dma_transfer(rspi, &xfer->tx_sg,
spi-rspi.c:679:				xfer->rx_buf ? &xfer->rx_sg : NULL);
spi-rspi.c:688:	if (ret != -EAGAIN)
spi-rspi.c:691:	ret = rspi_pio_transfer(rspi, xfer->tx_buf, xfer->rx_buf, xfer->len);
spi-rspi.c:708:	if (xfer->rx_buf) {
spi-rspi.c:742:				dev_err(&rspi->master->dev, "transmit timeout\n");
spi-rspi.c:750:				dev_err(&rspi->master->dev, "receive timeout\n");
spi-rspi.c:760:		len -= n;
spi-rspi.c:774:	if (ret != -EAGAIN)
spi-rspi.c:777:	return qspi_trigger_transfer_out_in(rspi, xfer->tx_buf,
spi-rspi.c:778:					    xfer->rx_buf, xfer->len);
spi-rspi.c:785:	if (rspi->master->can_dma && __rspi_can_dma(rspi, xfer)) {
spi-rspi.c:786:		ret = rspi_dma_transfer(rspi, &xfer->tx_sg, NULL);
spi-rspi.c:787:		if (ret != -EAGAIN)
spi-rspi.c:791:	ret = rspi_pio_transfer(rspi, xfer->tx_buf, NULL, xfer->len);
spi-rspi.c:803:	if (rspi->master->can_dma && __rspi_can_dma(rspi, xfer)) {
spi-rspi.c:804:		int ret = rspi_dma_transfer(rspi, NULL, &xfer->rx_sg);
spi-rspi.c:805:		if (ret != -EAGAIN)
spi-rspi.c:809:	return rspi_pio_transfer(rspi, NULL, xfer->rx_buf, xfer->len);
spi-rspi.c:817:	if (spi->mode & SPI_LOOP) {
spi-rspi.c:819:	} else if (xfer->tx_nbits > SPI_NBITS_SINGLE) {
spi-rspi.c:822:	} else if (xfer->rx_nbits > SPI_NBITS_SINGLE) {
spi-rspi.c:833:	struct rspi_data *rspi = spi_master_get_devdata(spi->master);
spi-rspi.c:835:	rspi->max_speed_hz = spi->max_speed_hz;
spi-rspi.c:837:	rspi->spcmd = SPCMD_SSLKP;
spi-rspi.c:838:	if (spi->mode & SPI_CPOL)
spi-rspi.c:839:		rspi->spcmd |= SPCMD_CPOL;
spi-rspi.c:840:	if (spi->mode & SPI_CPHA)
spi-rspi.c:841:		rspi->spcmd |= SPCMD_CPHA;
spi-rspi.c:844:	rspi->sppcr = 0;
spi-rspi.c:845:	if (spi->mode & SPI_LOOP)
spi-rspi.c:846:		rspi->sppcr |= SPPCR_SPLP;
spi-rspi.c:855:	if (xfer->tx_buf)
spi-rspi.c:856:		switch (xfer->tx_nbits) {
spi-rspi.c:864:	if (xfer->rx_buf)
spi-rspi.c:865:		switch (xfer->rx_nbits) {
spi-rspi.c:884:	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
spi-rspi.c:887:			len += xfer->len;
spi-rspi.c:894:			rspi_write32(rspi, len, QSPI_SPBMUL(i - 1));
spi-rspi.c:898:			dev_err(&msg->spi->dev,
spi-rspi.c:900:			return -EINVAL;
spi-rspi.c:904:		rspi_write16(rspi, rspi->spcmd | mode, RSPI_SPCMD(i));
spi-rspi.c:906:		len = xfer->len;
spi-rspi.c:911:		rspi_write32(rspi, len, QSPI_SPBMUL(i - 1));
spi-rspi.c:912:		rspi_write8(rspi, i - 1, RSPI_SPSCR);
spi-rspi.c:924:	if (msg->spi->mode &
spi-rspi.c:946:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
spi-rspi.c:958:	rspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);
spi-rspi.c:967:		wake_up(&rspi->wait);
spi-rspi.c:978:	rspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);
spi-rspi.c:981:		wake_up(&rspi->wait);
spi-rspi.c:993:	rspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);
spi-rspi.c:996:		wake_up(&rspi->wait);
spi-rspi.c:1050:	if (dev->of_node) {
spi-rspi.c:1054:	} else if (rspi_pd && rspi_pd->dma_tx_id && rspi_pd->dma_rx_id) {
spi-rspi.c:1055:		dma_tx_id = rspi_pd->dma_tx_id;
spi-rspi.c:1056:		dma_rx_id = rspi_pd->dma_rx_id;
spi-rspi.c:1062:	master->dma_tx = rspi_request_dma_chan(dev, DMA_MEM_TO_DEV, dma_tx_id,
spi-rspi.c:1063:					       res->start + RSPI_SPDR);
spi-rspi.c:1064:	if (!master->dma_tx)
spi-rspi.c:1065:		return -ENODEV;
spi-rspi.c:1067:	master->dma_rx = rspi_request_dma_chan(dev, DMA_DEV_TO_MEM, dma_rx_id,
spi-rspi.c:1068:					       res->start + RSPI_SPDR);
spi-rspi.c:1069:	if (!master->dma_rx) {
spi-rspi.c:1070:		dma_release_channel(master->dma_tx);
spi-rspi.c:1071:		master->dma_tx = NULL;
spi-rspi.c:1072:		return -ENODEV;
spi-rspi.c:1075:	master->can_dma = rspi_can_dma;
spi-rspi.c:1082:	if (master->dma_tx)
spi-rspi.c:1083:		dma_release_channel(master->dma_tx);
spi-rspi.c:1084:	if (master->dma_rx)
spi-rspi.c:1085:		dma_release_channel(master->dma_rx);
spi-rspi.c:1092:	rspi_release_dma(rspi->master);
spi-rspi.c:1093:	pm_runtime_disable(&pdev->dev);
spi-rspi.c:1129:	{ .compatible = "renesas,rspi-rz", .data = &rspi_rz_ops },
spi-rspi.c:1130:	/* QSPI on R-Car Gen2 */
spi-rspi.c:1143:	error = of_property_read_u32(dev->of_node, "num-cs", &num_cs);
spi-rspi.c:1145:		dev_err(dev, "of_property_read_u32 num-cs failed %d\n", error);
spi-rspi.c:1149:	master->num_chipselect = num_cs;
spi-rspi.c:1156:	return -EINVAL;
spi-rspi.c:1167:		return -ENOMEM;
spi-rspi.c:1182:	master = spi_alloc_master(&pdev->dev, sizeof(struct rspi_data));
spi-rspi.c:1184:		dev_err(&pdev->dev, "spi_alloc_master error.\n");
spi-rspi.c:1185:		return -ENOMEM;
spi-rspi.c:1188:	of_id = of_match_device(rspi_of_match, &pdev->dev);
spi-rspi.c:1190:		ops = of_id->data;
spi-rspi.c:1191:		ret = rspi_parse_dt(&pdev->dev, master);
spi-rspi.c:1195:		ops = (struct spi_ops *)pdev->id_entry->driver_data;
spi-rspi.c:1196:		rspi_pd = dev_get_platdata(&pdev->dev);
spi-rspi.c:1197:		if (rspi_pd && rspi_pd->num_chipselect)
spi-rspi.c:1198:			master->num_chipselect = rspi_pd->num_chipselect;
spi-rspi.c:1200:			master->num_chipselect = 2; /* default */
spi-rspi.c:1204:	if (!ops->set_config_register) {
spi-rspi.c:1205:		dev_err(&pdev->dev, "there is no set_config_register\n");
spi-rspi.c:1206:		ret = -ENODEV;
spi-rspi.c:1212:	rspi->ops = ops;
spi-rspi.c:1213:	rspi->master = master;
spi-rspi.c:1216:	rspi->addr = devm_ioremap_resource(&pdev->dev, res);
spi-rspi.c:1217:	if (IS_ERR(rspi->addr)) {
spi-rspi.c:1218:		ret = PTR_ERR(rspi->addr);
spi-rspi.c:1222:	rspi->clk = devm_clk_get(&pdev->dev, NULL);
spi-rspi.c:1223:	if (IS_ERR(rspi->clk)) {
spi-rspi.c:1224:		dev_err(&pdev->dev, "cannot get clock\n");
spi-rspi.c:1225:		ret = PTR_ERR(rspi->clk);
spi-rspi.c:1229:	pm_runtime_enable(&pdev->dev);
spi-rspi.c:1231:	init_waitqueue_head(&rspi->wait);
spi-rspi.c:1233:	master->bus_num = pdev->id;
spi-rspi.c:1234:	master->setup = rspi_setup;
spi-rspi.c:1235:	master->auto_runtime_pm = true;
spi-rspi.c:1236:	master->transfer_one = ops->transfer_one;
spi-rspi.c:1237:	master->prepare_message = rspi_prepare_message;
spi-rspi.c:1238:	master->unprepare_message = rspi_unprepare_message;
spi-rspi.c:1239:	master->mode_bits = ops->mode_bits;
spi-rspi.c:1240:	master->flags = ops->flags;
spi-rspi.c:1241:	master->dev.of_node = pdev->dev.of_node;
spi-rspi.c:1249:			rspi->rx_irq = rspi->tx_irq = ret;
spi-rspi.c:1251:		rspi->rx_irq = ret;
spi-rspi.c:1254:			rspi->tx_irq = ret;
spi-rspi.c:1257:		dev_err(&pdev->dev, "platform_get_irq error\n");
spi-rspi.c:1261:	if (rspi->rx_irq == rspi->tx_irq) {
spi-rspi.c:1263:		ret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_mux,
spi-rspi.c:1266:		/* Multi-interrupt mode, only SPRI and SPTI are used */
spi-rspi.c:1267:		ret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_rx,
spi-rspi.c:1270:			ret = rspi_request_irq(&pdev->dev, rspi->tx_irq,
spi-rspi.c:1274:		dev_err(&pdev->dev, "request_irq error\n");
spi-rspi.c:1278:	ret = rspi_request_dma(&pdev->dev, master, res);
spi-rspi.c:1280:		dev_warn(&pdev->dev, "DMA not available, using PIO\n");
spi-rspi.c:1282:	ret = devm_spi_register_master(&pdev->dev, master);
spi-rspi.c:1284:		dev_err(&pdev->dev, "spi_register_master error.\n");
spi-rspi.c:1288:	dev_info(&pdev->dev, "probed\n");
spi-rspi.c:1295:	pm_runtime_disable(&pdev->dev);
spi-rspi.c:1304:	{ "rspi-rz",	(kernel_ulong_t)&rspi_rz_ops },
spi-rspi.c:1317:	return spi_master_suspend(rspi->master);
spi-rspi.c:1325:	return spi_master_resume(rspi->master);
spi-omap-uwire.c:48:#include <asm/mach-types.h>
spi-omap-uwire.c:155:			return -1;
spi-omap-uwire.c:176:	struct	uwire_state *ust = spi->controller_state;
spi-omap-uwire.c:185:	if (value == BITBANG_CS_INACTIVE || old_cs != spi->chip_select) {
spi-omap-uwire.c:192:		uwire_set_clk1_div(ust->div1_idx);
spi-omap-uwire.c:194:		if (spi->mode & SPI_CPOL)
spi-omap-uwire.c:199:		w = spi->chip_select << 10;
spi-omap-uwire.c:207:	unsigned	len = t->len;
spi-omap-uwire.c:208:	unsigned	bits = t->bits_per_word;
spi-omap-uwire.c:213:	if (!t->tx_buf && !t->rx_buf)
spi-omap-uwire.c:216:	w = spi->chip_select << 10;
spi-omap-uwire.c:219:	if (t->tx_buf) {
spi-omap-uwire.c:220:		const u8	*buf = t->tx_buf;
spi-omap-uwire.c:227:			 * (msb-first) on the way out from memory.
spi-omap-uwire.c:235:			val <<= 16 - bits;
spi-omap-uwire.c:238:			pr_debug("%s: write-%d =%04x\n",
spi-omap-uwire.c:239:					dev_name(&spi->dev), bits, val);
spi-omap-uwire.c:250:			len -= bytes;
spi-omap-uwire.c:266:	} else if (t->rx_buf) {
spi-omap-uwire.c:267:		u8		*buf = t->rx_buf;
spi-omap-uwire.c:279:			len -= bytes;
spi-omap-uwire.c:292:			val &= (1 << bits) - 1;
spi-omap-uwire.c:298:			pr_debug("%s: read-%d =%04x\n",
spi-omap-uwire.c:299:					dev_name(&spi->dev), bits, val);
spi-omap-uwire.c:306:	return -EIO;
spi-omap-uwire.c:311:	struct uwire_state	*ust = spi->controller_state;
spi-omap-uwire.c:321:	uwire = spi_master_get_devdata(spi->master);
spi-omap-uwire.c:327:	if (spi->mode & SPI_CS_HIGH)
spi-omap-uwire.c:330:	if (spi->mode & SPI_CPOL)
spi-omap-uwire.c:333:	switch (spi->mode & (SPI_CPOL | SPI_CPHA)) {
spi-omap-uwire.c:345:	rate = clk_get_rate(uwire->ck);
spi-omap-uwire.c:348:		hz = t->speed_hz;
spi-omap-uwire.c:350:		hz = spi->max_speed_hz;
spi-omap-uwire.c:353:		pr_debug("%s: zero speed?\n", dev_name(&spi->dev));
spi-omap-uwire.c:354:		status = -EINVAL;
spi-omap-uwire.c:375:		div2 = (rate / div1 + hz - 1) / hz;
spi-omap-uwire.c:381:			dev_name(&spi->dev), rate / 10 / 8, hz);
spi-omap-uwire.c:382:		status = -EDOM;
spi-omap-uwire.c:389:	ust->div1_idx = div1_idx;
spi-omap-uwire.c:414:	omap_uwire_configure_mode(spi->chip_select, flags);
spi-omap-uwire.c:417:			clk_get_rate(uwire->ck) / 1000,
spi-omap-uwire.c:426:	struct uwire_state *ust = spi->controller_state;
spi-omap-uwire.c:431:			return -ENOMEM;
spi-omap-uwire.c:432:		spi->controller_state = ust;
spi-omap-uwire.c:440:	kfree(spi->controller_state);
spi-omap-uwire.c:446:	clk_disable(uwire->ck);
spi-omap-uwire.c:447:	spi_master_put(uwire->bitbang.master);
spi-omap-uwire.c:456:	master = spi_alloc_master(&pdev->dev, sizeof *uwire);
spi-omap-uwire.c:458:		return -ENODEV;
spi-omap-uwire.c:462:	uwire_base = devm_ioremap(&pdev->dev, UWIRE_BASE_PHYS, UWIRE_IO_SIZE);
spi-omap-uwire.c:464:		dev_dbg(&pdev->dev, "can't ioremap UWIRE\n");
spi-omap-uwire.c:466:		return -ENOMEM;
spi-omap-uwire.c:471:	uwire->ck = devm_clk_get(&pdev->dev, "fck");
spi-omap-uwire.c:472:	if (IS_ERR(uwire->ck)) {
spi-omap-uwire.c:473:		status = PTR_ERR(uwire->ck);
spi-omap-uwire.c:474:		dev_dbg(&pdev->dev, "no functional clock?\n");
spi-omap-uwire.c:478:	clk_enable(uwire->ck);
spi-omap-uwire.c:487:	/* the spi->mode bits understood by this driver: */
spi-omap-uwire.c:488:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-omap-uwire.c:489:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 16);
spi-omap-uwire.c:490:	master->flags = SPI_MASTER_HALF_DUPLEX;
spi-omap-uwire.c:492:	master->bus_num = 2;	/* "official" */
spi-omap-uwire.c:493:	master->num_chipselect = 4;
spi-omap-uwire.c:494:	master->setup = uwire_setup;
spi-omap-uwire.c:495:	master->cleanup = uwire_cleanup;
spi-omap-uwire.c:497:	uwire->bitbang.master = master;
spi-omap-uwire.c:498:	uwire->bitbang.chipselect = uwire_chipselect;
spi-omap-uwire.c:499:	uwire->bitbang.setup_transfer = uwire_setup_transfer;
spi-omap-uwire.c:500:	uwire->bitbang.txrx_bufs = uwire_txrx;
spi-omap-uwire.c:502:	status = spi_bitbang_start(&uwire->bitbang);
spi-omap-uwire.c:515:	spi_bitbang_stop(&uwire->bitbang);
spi-sirf.c:24:#include <linux/dma-direction.h>
spi-sirf.c:25:#include <linux/dma-mapping.h>
spi-sirf.c:137:#define SIRFSOC_SPI_FIFO_FULL_MASK(s)	(1 << ((s)->fifo_full_offset))
spi-sirf.c:138:#define SIRFSOC_SPI_FIFO_EMPTY_MASK(s)	(1 << ((s)->fifo_full_offset + 1))
spi-sirf.c:139:#define SIRFSOC_SPI_FIFO_THD_MASK(s)	((s)->fifo_size - 1)
spi-sirf.c:142:	((val) & (s)->fifo_level_chk_mask)
spi-sirf.c:151: * only if the rx/tx buffer and transfer size are 4-bytes aligned, we use dma
spi-sirf.c:156:#define IS_DMA_VALID(x) (x && ALIGNED(x->tx_buf) && ALIGNED(x->rx_buf) && \
spi-sirf.c:157:	ALIGNED(x->len) && (x->len < 2 * PAGE_SIZE))
spi-sirf.c:163:	/*SPI and USP-SPI common*/
spi-sirf.c:185:	/*USP-SPI self*/
spi-sirf.c:291:	/* fifo_level_chk_mask is (fifo_size/4 - 1) */
spi-sirf.c:307:	writel(readl(sspi->base + sspi->regs->usp_mode1) &
spi-sirf.c:308:		~SIRFSOC_USP_EN, sspi->base + sspi->regs->usp_mode1);
spi-sirf.c:309:	writel(readl(sspi->base + sspi->regs->usp_mode1) |
spi-sirf.c:310:		SIRFSOC_USP_EN, sspi->base + sspi->regs->usp_mode1);
spi-sirf.c:316:	u8 *rx = sspi->rx;
spi-sirf.c:318:	data = readl(sspi->base + sspi->regs->rxfifo_data);
spi-sirf.c:322:		sspi->rx = rx;
spi-sirf.c:325:	sspi->left_rx_word--;
spi-sirf.c:331:	const u8 *tx = sspi->tx;
spi-sirf.c:335:		sspi->tx = tx;
spi-sirf.c:337:	writel(data, sspi->base + sspi->regs->txfifo_data);
spi-sirf.c:338:	sspi->left_tx_word--;
spi-sirf.c:344:	u16 *rx = sspi->rx;
spi-sirf.c:346:	data = readl(sspi->base + sspi->regs->rxfifo_data);
spi-sirf.c:350:		sspi->rx = rx;
spi-sirf.c:353:	sspi->left_rx_word--;
spi-sirf.c:359:	const u16 *tx = sspi->tx;
spi-sirf.c:363:		sspi->tx = tx;
spi-sirf.c:366:	writel(data, sspi->base + sspi->regs->txfifo_data);
spi-sirf.c:367:	sspi->left_tx_word--;
spi-sirf.c:373:	u32 *rx = sspi->rx;
spi-sirf.c:375:	data = readl(sspi->base + sspi->regs->rxfifo_data);
spi-sirf.c:379:		sspi->rx = rx;
spi-sirf.c:382:	sspi->left_rx_word--;
spi-sirf.c:389:	const u32 *tx = sspi->tx;
spi-sirf.c:393:		sspi->tx = tx;
spi-sirf.c:396:	writel(data, sspi->base + sspi->regs->txfifo_data);
spi-sirf.c:397:	sspi->left_tx_word--;
spi-sirf.c:405:	spi_stat = readl(sspi->base + sspi->regs->int_st);
spi-sirf.c:406:	if (sspi->tx_by_cmd && sspi->type == SIRF_REAL_SPI
spi-sirf.c:408:		complete(&sspi->tx_done);
spi-sirf.c:409:		writel(0x0, sspi->base + sspi->regs->int_en);
spi-sirf.c:410:		writel(readl(sspi->base + sspi->regs->int_st),
spi-sirf.c:411:				sspi->base + sspi->regs->int_st);
spi-sirf.c:417:		complete(&sspi->tx_done);
spi-sirf.c:418:		complete(&sspi->rx_done);
spi-sirf.c:419:		switch (sspi->type) {
spi-sirf.c:422:			writel(0x0, sspi->base + sspi->regs->int_en);
spi-sirf.c:425:			writel(~0UL, sspi->base + sspi->regs->usp_int_en_clr);
spi-sirf.c:428:		writel(readl(sspi->base + sspi->regs->int_st),
spi-sirf.c:429:				sspi->base + sspi->regs->int_st);
spi-sirf.c:433:		complete(&sspi->tx_done);
spi-sirf.c:434:	while (!(readl(sspi->base + sspi->regs->int_st) &
spi-sirf.c:437:	complete(&sspi->rx_done);
spi-sirf.c:438:	switch (sspi->type) {
spi-sirf.c:441:		writel(0x0, sspi->base + sspi->regs->int_en);
spi-sirf.c:444:		writel(~0UL, sspi->base + sspi->regs->usp_int_en_clr);
spi-sirf.c:447:	writel(readl(sspi->base + sspi->regs->int_st),
spi-sirf.c:448:			sspi->base + sspi->regs->int_st);
spi-sirf.c:464:	int timeout = t->len * 10;
spi-sirf.c:467:	sspi = spi_master_get_devdata(spi->master);
spi-sirf.c:468:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:469:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:470:	memcpy(&cmd, sspi->tx, t->len);
spi-sirf.c:471:	if (sspi->word_width == 1 && !(spi->mode & SPI_LSB_FIRST))
spi-sirf.c:473:			((SIRFSOC_MAX_CMD_BYTES - t->len) * 8);
spi-sirf.c:474:	if (sspi->word_width == 2 && t->len == 4 &&
spi-sirf.c:475:			(!(spi->mode & SPI_LSB_FIRST)))
spi-sirf.c:477:	writel(cmd, sspi->base + sspi->regs->spi_cmd);
spi-sirf.c:479:		sspi->base + sspi->regs->int_en);
spi-sirf.c:481:		sspi->base + sspi->regs->tx_rx_en);
spi-sirf.c:482:	if (wait_for_completion_timeout(&sspi->tx_done, timeout) == 0) {
spi-sirf.c:483:		dev_err(&spi->dev, "cmd transfer timeout\n");
spi-sirf.c:486:	sspi->left_rx_word -= t->len;
spi-sirf.c:494:	int timeout = t->len * 10;
spi-sirf.c:496:	sspi = spi_master_get_devdata(spi->master);
spi-sirf.c:497:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:498:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:499:	switch (sspi->type) {
spi-sirf.c:502:			sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:504:			sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:505:		writel(0, sspi->base + sspi->regs->int_en);
spi-sirf.c:508:		writel(0x0, sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:509:		writel(0x0, sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:510:		writel(0, sspi->base + sspi->regs->int_en);
spi-sirf.c:513:		writel(0x0, sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:514:		writel(0x0, sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:515:		writel(~0UL, sspi->base + sspi->regs->usp_int_en_clr);
spi-sirf.c:518:	writel(readl(sspi->base + sspi->regs->int_st),
spi-sirf.c:519:		sspi->base + sspi->regs->int_st);
spi-sirf.c:520:	if (sspi->left_tx_word < sspi->dat_max_frm_len) {
spi-sirf.c:521:		switch (sspi->type) {
spi-sirf.c:523:			writel(readl(sspi->base + sspi->regs->spi_ctrl) |
spi-sirf.c:526:				sspi->base + sspi->regs->spi_ctrl);
spi-sirf.c:527:			writel(sspi->left_tx_word - 1,
spi-sirf.c:528:				sspi->base + sspi->regs->tx_dma_io_len);
spi-sirf.c:529:			writel(sspi->left_tx_word - 1,
spi-sirf.c:530:				sspi->base + sspi->regs->rx_dma_io_len);
spi-sirf.c:535:			writel(sspi->left_tx_word * sspi->word_width,
spi-sirf.c:536:				sspi->base + sspi->regs->tx_dma_io_len);
spi-sirf.c:537:			writel(sspi->left_tx_word * sspi->word_width,
spi-sirf.c:538:				sspi->base + sspi->regs->rx_dma_io_len);
spi-sirf.c:542:		if (sspi->type == SIRF_REAL_SPI)
spi-sirf.c:543:			writel(readl(sspi->base + sspi->regs->spi_ctrl),
spi-sirf.c:544:				sspi->base + sspi->regs->spi_ctrl);
spi-sirf.c:545:		writel(0, sspi->base + sspi->regs->tx_dma_io_len);
spi-sirf.c:546:		writel(0, sspi->base + sspi->regs->rx_dma_io_len);
spi-sirf.c:548:	sspi->dst_start = dma_map_single(&spi->dev, sspi->rx, t->len,
spi-sirf.c:549:					(t->tx_buf != t->rx_buf) ?
spi-sirf.c:551:	rx_desc = dmaengine_prep_slave_single(sspi->rx_chan,
spi-sirf.c:552:		sspi->dst_start, t->len, DMA_DEV_TO_MEM,
spi-sirf.c:554:	rx_desc->callback = spi_sirfsoc_dma_fini_callback;
spi-sirf.c:555:	rx_desc->callback_param = &sspi->rx_done;
spi-sirf.c:557:	sspi->src_start = dma_map_single(&spi->dev, (void *)sspi->tx, t->len,
spi-sirf.c:558:					(t->tx_buf != t->rx_buf) ?
spi-sirf.c:560:	tx_desc = dmaengine_prep_slave_single(sspi->tx_chan,
spi-sirf.c:561:		sspi->src_start, t->len, DMA_MEM_TO_DEV,
spi-sirf.c:563:	tx_desc->callback = spi_sirfsoc_dma_fini_callback;
spi-sirf.c:564:	tx_desc->callback_param = &sspi->tx_done;
spi-sirf.c:568:	dma_async_issue_pending(sspi->tx_chan);
spi-sirf.c:569:	dma_async_issue_pending(sspi->rx_chan);
spi-sirf.c:571:			sspi->base + sspi->regs->tx_rx_en);
spi-sirf.c:572:	if (sspi->type == SIRF_USP_SPI_P2 ||
spi-sirf.c:573:		sspi->type == SIRF_USP_SPI_A7) {
spi-sirf.c:575:			sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:577:			sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:579:	if (wait_for_completion_timeout(&sspi->rx_done, timeout) == 0) {
spi-sirf.c:580:		dev_err(&spi->dev, "transfer timeout\n");
spi-sirf.c:581:		dmaengine_terminate_all(sspi->rx_chan);
spi-sirf.c:583:		sspi->left_rx_word = 0;
spi-sirf.c:585:	 * we only wait tx-done event if transferring by DMA. for PIO,
spi-sirf.c:589:	if (wait_for_completion_timeout(&sspi->tx_done, timeout) == 0) {
spi-sirf.c:590:		dev_err(&spi->dev, "transfer timeout\n");
spi-sirf.c:591:		if (sspi->type == SIRF_USP_SPI_P2 ||
spi-sirf.c:592:			sspi->type == SIRF_USP_SPI_A7)
spi-sirf.c:593:			writel(0, sspi->base + sspi->regs->tx_rx_en);
spi-sirf.c:594:		dmaengine_terminate_all(sspi->tx_chan);
spi-sirf.c:596:	dma_unmap_single(&spi->dev, sspi->src_start, t->len, DMA_TO_DEVICE);
spi-sirf.c:597:	dma_unmap_single(&spi->dev, sspi->dst_start, t->len, DMA_FROM_DEVICE);
spi-sirf.c:599:	writel(0, sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:600:	writel(0, sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:601:	if (sspi->left_tx_word >= sspi->dat_max_frm_len)
spi-sirf.c:602:		writel(0, sspi->base + sspi->regs->tx_rx_en);
spi-sirf.c:603:	if (sspi->type == SIRF_USP_SPI_P2 ||
spi-sirf.c:604:		sspi->type == SIRF_USP_SPI_A7)
spi-sirf.c:605:		writel(0, sspi->base + sspi->regs->tx_rx_en);
spi-sirf.c:612:	int timeout = t->len * 10;
spi-sirf.c:615:	sspi = spi_master_get_devdata(spi->master);
spi-sirf.c:618:			sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:620:			sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:621:		switch (sspi->type) {
spi-sirf.c:623:			writel(0x0, sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:624:			writel(0x0, sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:625:			writel(0, sspi->base + sspi->regs->int_en);
spi-sirf.c:626:			writel(readl(sspi->base + sspi->regs->int_st),
spi-sirf.c:627:				sspi->base + sspi->regs->int_st);
spi-sirf.c:628:			writel(min((sspi->left_tx_word * sspi->word_width),
spi-sirf.c:629:				sspi->fifo_size),
spi-sirf.c:630:				sspi->base + sspi->regs->tx_dma_io_len);
spi-sirf.c:631:			writel(min((sspi->left_rx_word * sspi->word_width),
spi-sirf.c:632:				sspi->fifo_size),
spi-sirf.c:633:				sspi->base + sspi->regs->rx_dma_io_len);
spi-sirf.c:636:			writel(0x0, sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:637:			writel(0x0, sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:638:			writel(~0UL, sspi->base + sspi->regs->usp_int_en_clr);
spi-sirf.c:639:			writel(readl(sspi->base + sspi->regs->int_st),
spi-sirf.c:640:				sspi->base + sspi->regs->int_st);
spi-sirf.c:641:			writel(min((sspi->left_tx_word * sspi->word_width),
spi-sirf.c:642:				sspi->fifo_size),
spi-sirf.c:643:				sspi->base + sspi->regs->tx_dma_io_len);
spi-sirf.c:644:			writel(min((sspi->left_rx_word * sspi->word_width),
spi-sirf.c:645:				sspi->fifo_size),
spi-sirf.c:646:				sspi->base + sspi->regs->rx_dma_io_len);
spi-sirf.c:650:				sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:652:				sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:653:			writel(0, sspi->base + sspi->regs->int_en);
spi-sirf.c:654:			writel(readl(sspi->base + sspi->regs->int_st),
spi-sirf.c:655:				sspi->base + sspi->regs->int_st);
spi-sirf.c:656:			writel(readl(sspi->base + sspi->regs->spi_ctrl) |
spi-sirf.c:659:				sspi->base + sspi->regs->spi_ctrl);
spi-sirf.c:660:			data_units = sspi->fifo_size / sspi->word_width;
spi-sirf.c:661:			writel(min(sspi->left_tx_word, data_units) - 1,
spi-sirf.c:662:				sspi->base + sspi->regs->tx_dma_io_len);
spi-sirf.c:663:			writel(min(sspi->left_rx_word, data_units) - 1,
spi-sirf.c:664:				sspi->base + sspi->regs->rx_dma_io_len);
spi-sirf.c:667:		while (!((readl(sspi->base + sspi->regs->txfifo_st)
spi-sirf.c:669:			sspi->left_tx_word)
spi-sirf.c:670:			sspi->tx_word(sspi);
spi-sirf.c:675:			sspi->base + sspi->regs->int_en);
spi-sirf.c:677:			sspi->base + sspi->regs->tx_rx_en);
spi-sirf.c:678:		if (sspi->type == SIRF_USP_SPI_P2 ||
spi-sirf.c:679:			sspi->type == SIRF_USP_SPI_A7) {
spi-sirf.c:681:				sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:683:				sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:685:		if (!wait_for_completion_timeout(&sspi->tx_done, timeout) ||
spi-sirf.c:686:			!wait_for_completion_timeout(&sspi->rx_done, timeout)) {
spi-sirf.c:687:			dev_err(&spi->dev, "transfer timeout\n");
spi-sirf.c:688:			if (sspi->type == SIRF_USP_SPI_P2 ||
spi-sirf.c:689:				sspi->type == SIRF_USP_SPI_A7)
spi-sirf.c:690:				writel(0, sspi->base + sspi->regs->tx_rx_en);
spi-sirf.c:693:		while (!((readl(sspi->base + sspi->regs->rxfifo_st)
spi-sirf.c:695:			sspi->left_rx_word)
spi-sirf.c:696:			sspi->rx_word(sspi);
spi-sirf.c:697:		if (sspi->type == SIRF_USP_SPI_P2 ||
spi-sirf.c:698:			sspi->type == SIRF_USP_SPI_A7)
spi-sirf.c:699:			writel(0, sspi->base + sspi->regs->tx_rx_en);
spi-sirf.c:700:		writel(0, sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:701:		writel(0, sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:702:	} while (sspi->left_tx_word != 0 || sspi->left_rx_word != 0);
spi-sirf.c:709:	sspi = spi_master_get_devdata(spi->master);
spi-sirf.c:710:	sspi->tx = t->tx_buf;
spi-sirf.c:711:	sspi->rx = t->rx_buf;
spi-sirf.c:712:	sspi->left_tx_word = sspi->left_rx_word = t->len / sspi->word_width;
spi-sirf.c:713:	reinit_completion(&sspi->rx_done);
spi-sirf.c:714:	reinit_completion(&sspi->tx_done);
spi-sirf.c:720:	if (sspi->type == SIRF_REAL_SPI && sspi->tx_by_cmd)
spi-sirf.c:727:	return t->len - sspi->left_rx_word * sspi->word_width;
spi-sirf.c:732:	struct sirfsoc_spi *sspi = spi_master_get_devdata(spi->master);
spi-sirf.c:734:	if (sspi->hw_cs) {
spi-sirf.c:737:		switch (sspi->type) {
spi-sirf.c:739:			regval = readl(sspi->base + sspi->regs->spi_ctrl);
spi-sirf.c:742:				if (spi->mode & SPI_CS_HIGH)
spi-sirf.c:748:				if (spi->mode & SPI_CS_HIGH)
spi-sirf.c:754:			writel(regval, sspi->base + sspi->regs->spi_ctrl);
spi-sirf.c:758:			regval = readl(sspi->base +
spi-sirf.c:759:					sspi->regs->usp_pin_io_data);
spi-sirf.c:762:				if (spi->mode & SPI_CS_HIGH)
spi-sirf.c:768:				if (spi->mode & SPI_CS_HIGH)
spi-sirf.c:775:				sspi->base + sspi->regs->usp_pin_io_data);
spi-sirf.c:781:			gpio_direction_output(spi->cs_gpio,
spi-sirf.c:782:					spi->mode & SPI_CS_HIGH ? 1 : 0);
spi-sirf.c:785:			gpio_direction_output(spi->cs_gpio,
spi-sirf.c:786:					spi->mode & SPI_CS_HIGH ? 0 : 1);
spi-sirf.c:797:	sspi = spi_master_get_devdata(spi->master);
spi-sirf.c:798:	regval = readl(sspi->base + sspi->regs->spi_ctrl);
spi-sirf.c:799:	usp_mode1 = readl(sspi->base + sspi->regs->usp_mode1);
spi-sirf.c:800:	if (!(spi->mode & SPI_CS_HIGH)) {
spi-sirf.c:807:	if (!(spi->mode & SPI_LSB_FIRST)) {
spi-sirf.c:814:	if (spi->mode & SPI_CPOL) {
spi-sirf.c:825:	if (((spi->mode & SPI_CPOL) && (spi->mode & SPI_CPHA)) ||
spi-sirf.c:826:	    (!(spi->mode & SPI_CPOL) && !(spi->mode & SPI_CPHA))) {
spi-sirf.c:835:	writel((SIRFSOC_SPI_FIFO_LEVEL_CHK_MASK(sspi, sspi->fifo_size - 2) <<
spi-sirf.c:837:		(SIRFSOC_SPI_FIFO_LEVEL_CHK_MASK(sspi, sspi->fifo_size / 2) <<
spi-sirf.c:841:		sspi->base + sspi->regs->txfifo_level_chk);
spi-sirf.c:844:		(SIRFSOC_SPI_FIFO_LEVEL_CHK_MASK(sspi, sspi->fifo_size / 2) <<
spi-sirf.c:846:		(SIRFSOC_SPI_FIFO_LEVEL_CHK_MASK(sspi, sspi->fifo_size - 2) <<
spi-sirf.c:848:		sspi->base + sspi->regs->rxfifo_level_chk);
spi-sirf.c:853:	switch (sspi->type) {
spi-sirf.c:856:		writel(regval, sspi->base + sspi->regs->spi_ctrl);
spi-sirf.c:863:		writel(usp_mode1, sspi->base + sspi->regs->usp_mode1);
spi-sirf.c:878:	sspi = spi_master_get_devdata(spi->master);
spi-sirf.c:880:	bits_per_word = (t) ? t->bits_per_word : spi->bits_per_word;
spi-sirf.c:881:	hz = t && t->speed_hz ? t->speed_hz : spi->max_speed_hz;
spi-sirf.c:883:	usp_mode2 = regval = (sspi->ctrl_freq / (2 * hz)) - 1;
spi-sirf.c:885:		dev_err(&spi->dev, "Speed %d not supported\n", hz);
spi-sirf.c:886:		return -EINVAL;
spi-sirf.c:891:		sspi->rx_word = spi_sirfsoc_rx_word_u8;
spi-sirf.c:892:		sspi->tx_word = spi_sirfsoc_tx_word_u8;
spi-sirf.c:899:		sspi->rx_word = spi_sirfsoc_rx_word_u16;
spi-sirf.c:900:		sspi->tx_word = spi_sirfsoc_tx_word_u16;
spi-sirf.c:904:		sspi->rx_word = spi_sirfsoc_rx_word_u32;
spi-sirf.c:905:		sspi->tx_word = spi_sirfsoc_tx_word_u32;
spi-sirf.c:908:		dev_err(&spi->dev, "bpw %d not supported\n", bits_per_word);
spi-sirf.c:909:		return -EINVAL;
spi-sirf.c:911:	sspi->word_width = DIV_ROUND_UP(bits_per_word, 8);
spi-sirf.c:912:	txfifo_ctrl = (((sspi->fifo_size / 2) &
spi-sirf.c:915:			(sspi->word_width >> 1);
spi-sirf.c:916:	rxfifo_ctrl = (((sspi->fifo_size / 2) &
spi-sirf.c:919:			(sspi->word_width >> 1);
spi-sirf.c:920:	writel(txfifo_ctrl, sspi->base + sspi->regs->txfifo_ctrl);
spi-sirf.c:921:	writel(rxfifo_ctrl, sspi->base + sspi->regs->rxfifo_ctrl);
spi-sirf.c:922:	if (sspi->type == SIRF_USP_SPI_P2 ||
spi-sirf.c:923:		sspi->type == SIRF_USP_SPI_A7) {
spi-sirf.c:925:		tx_frm_ctl |= ((bits_per_word - 1) & SIRFSOC_USP_TX_DATA_MASK)
spi-sirf.c:928:				- 1) & SIRFSOC_USP_TX_SYNC_MASK) <<
spi-sirf.c:931:				+ 2 - 1) & SIRFSOC_USP_TX_FRAME_MASK) <<
spi-sirf.c:933:		tx_frm_ctl |= ((bits_per_word - 1) &
spi-sirf.c:937:		rx_frm_ctl |= ((bits_per_word - 1) & SIRFSOC_USP_RX_DATA_MASK)
spi-sirf.c:940:				+ 2 - 1) & SIRFSOC_USP_RX_FRAME_MASK) <<
spi-sirf.c:942:		rx_frm_ctl |= ((bits_per_word - 1)
spi-sirf.c:948:			sspi->base + sspi->regs->usp_tx_frame_ctrl);
spi-sirf.c:952:			sspi->base + sspi->regs->usp_rx_frame_ctrl);
spi-sirf.c:953:		writel(readl(sspi->base + sspi->regs->usp_mode2) |
spi-sirf.c:960:			sspi->base + sspi->regs->usp_mode2);
spi-sirf.c:962:	if (sspi->type == SIRF_REAL_SPI)
spi-sirf.c:963:		writel(regval, sspi->base + sspi->regs->spi_ctrl);
spi-sirf.c:965:	if (sspi->type == SIRF_REAL_SPI) {
spi-sirf.c:966:		if (t && t->tx_buf && !t->rx_buf &&
spi-sirf.c:967:			(t->len <= SIRFSOC_MAX_CMD_BYTES)) {
spi-sirf.c:968:			sspi->tx_by_cmd = true;
spi-sirf.c:969:			writel(readl(sspi->base + sspi->regs->spi_ctrl) |
spi-sirf.c:970:				(SIRFSOC_SPI_CMD_BYTE_NUM((t->len - 1)) |
spi-sirf.c:972:				sspi->base + sspi->regs->spi_ctrl);
spi-sirf.c:974:			sspi->tx_by_cmd = false;
spi-sirf.c:975:			writel(readl(sspi->base + sspi->regs->spi_ctrl) &
spi-sirf.c:977:				sspi->base + sspi->regs->spi_ctrl);
spi-sirf.c:982:		writel(0, sspi->base + sspi->regs->tx_dma_io_ctrl);
spi-sirf.c:984:			sspi->base + sspi->regs->rx_dma_io_ctrl);
spi-sirf.c:988:			sspi->base + sspi->regs->tx_dma_io_ctrl);
spi-sirf.c:990:			sspi->base + sspi->regs->rx_dma_io_ctrl);
spi-sirf.c:1000:	sspi = spi_master_get_devdata(spi->master);
spi-sirf.c:1001:	if (spi->cs_gpio == -ENOENT)
spi-sirf.c:1002:		sspi->hw_cs = true;
spi-sirf.c:1004:		sspi->hw_cs = false;
spi-sirf.c:1008:				ret = -ENOMEM;
spi-sirf.c:1011:			ret = gpio_is_valid(spi->cs_gpio);
spi-sirf.c:1013:				dev_err(&spi->dev, "no valid gpio\n");
spi-sirf.c:1014:				ret = -ENOENT;
spi-sirf.c:1017:			ret = gpio_request(spi->cs_gpio, DRIVER_NAME);
spi-sirf.c:1019:				dev_err(&spi->dev, "failed to request gpio\n");
spi-sirf.c:1034:		gpio_free(spi->cs_gpio);
spi-sirf.c:1063:	{ .compatible = "sirf,prima2-spi", .data = &sirf_real_spi},
spi-sirf.c:1064:	{ .compatible = "sirf,prima2-usp-spi", .data = &sirf_usp_spi_p2},
spi-sirf.c:1065:	{ .compatible = "sirf,atlas7-usp-spi", .data = &sirf_usp_spi_a7},
spi-sirf.c:1080:	ret = device_reset(&pdev->dev);
spi-sirf.c:1082:		dev_err(&pdev->dev, "SPI reset failed!\n");
spi-sirf.c:1086:	master = spi_alloc_master(&pdev->dev, sizeof(*sspi));
spi-sirf.c:1088:		dev_err(&pdev->dev, "Unable to allocate SPI master\n");
spi-sirf.c:1089:		return -ENOMEM;
spi-sirf.c:1091:	match = of_match_node(spi_sirfsoc_of_match, pdev->dev.of_node);
spi-sirf.c:1094:	sspi->fifo_full_offset = ilog2(sspi->fifo_size);
spi-sirf.c:1095:	spi_comp_data = (struct sirf_spi_comp_data *)match->data;
spi-sirf.c:1096:	sspi->regs = spi_comp_data->regs;
spi-sirf.c:1097:	sspi->type = spi_comp_data->type;
spi-sirf.c:1098:	sspi->fifo_level_chk_mask = (sspi->fifo_size / 4) - 1;
spi-sirf.c:1099:	sspi->dat_max_frm_len = spi_comp_data->dat_max_frm_len;
spi-sirf.c:1100:	sspi->fifo_size = spi_comp_data->fifo_size;
spi-sirf.c:1102:	sspi->base = devm_ioremap_resource(&pdev->dev, mem_res);
spi-sirf.c:1103:	if (IS_ERR(sspi->base)) {
spi-sirf.c:1104:		ret = PTR_ERR(sspi->base);
spi-sirf.c:1109:		ret = -ENXIO;
spi-sirf.c:1112:	ret = devm_request_irq(&pdev->dev, irq, spi_sirfsoc_irq, 0,
spi-sirf.c:1117:	sspi->bitbang.master = master;
spi-sirf.c:1118:	sspi->bitbang.chipselect = spi_sirfsoc_chipselect;
spi-sirf.c:1119:	sspi->bitbang.setup_transfer = spi_sirfsoc_setup_transfer;
spi-sirf.c:1120:	sspi->bitbang.txrx_bufs = spi_sirfsoc_transfer;
spi-sirf.c:1121:	sspi->bitbang.master->setup = spi_sirfsoc_setup;
spi-sirf.c:1122:	sspi->bitbang.master->cleanup = spi_sirfsoc_cleanup;
spi-sirf.c:1123:	master->bus_num = pdev->id;
spi-sirf.c:1124:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST | SPI_CS_HIGH;
spi-sirf.c:1125:	master->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(12) |
spi-sirf.c:1127:	master->max_speed_hz = SIRFSOC_SPI_DEFAULT_FRQ;
spi-sirf.c:1128:	master->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;
spi-sirf.c:1129:	sspi->bitbang.master->dev.of_node = pdev->dev.of_node;
spi-sirf.c:1132:	sspi->rx_chan = dma_request_slave_channel(&pdev->dev, "rx");
spi-sirf.c:1133:	if (!sspi->rx_chan) {
spi-sirf.c:1134:		dev_err(&pdev->dev, "can not allocate rx dma channel\n");
spi-sirf.c:1135:		ret = -ENODEV;
spi-sirf.c:1138:	sspi->tx_chan = dma_request_slave_channel(&pdev->dev, "tx");
spi-sirf.c:1139:	if (!sspi->tx_chan) {
spi-sirf.c:1140:		dev_err(&pdev->dev, "can not allocate tx dma channel\n");
spi-sirf.c:1141:		ret = -ENODEV;
spi-sirf.c:1145:	sspi->clk = clk_get(&pdev->dev, NULL);
spi-sirf.c:1146:	if (IS_ERR(sspi->clk)) {
spi-sirf.c:1147:		ret = PTR_ERR(sspi->clk);
spi-sirf.c:1150:	clk_prepare_enable(sspi->clk);
spi-sirf.c:1151:	if (spi_comp_data->hwinit)
spi-sirf.c:1152:		spi_comp_data->hwinit(sspi);
spi-sirf.c:1153:	sspi->ctrl_freq = clk_get_rate(sspi->clk);
spi-sirf.c:1155:	init_completion(&sspi->rx_done);
spi-sirf.c:1156:	init_completion(&sspi->tx_done);
spi-sirf.c:1158:	ret = spi_bitbang_start(&sspi->bitbang);
spi-sirf.c:1161:	dev_info(&pdev->dev, "registerred, bus number = %d\n", master->bus_num);
spi-sirf.c:1165:	clk_disable_unprepare(sspi->clk);
spi-sirf.c:1166:	clk_put(sspi->clk);
spi-sirf.c:1168:	dma_release_channel(sspi->tx_chan);
spi-sirf.c:1170:	dma_release_channel(sspi->rx_chan);
spi-sirf.c:1184:	spi_bitbang_stop(&sspi->bitbang);
spi-sirf.c:1185:	clk_disable_unprepare(sspi->clk);
spi-sirf.c:1186:	clk_put(sspi->clk);
spi-sirf.c:1187:	dma_release_channel(sspi->rx_chan);
spi-sirf.c:1188:	dma_release_channel(sspi->tx_chan);
spi-sirf.c:1204:	clk_disable(sspi->clk);
spi-sirf.c:1213:	clk_enable(sspi->clk);
spi-sirf.c:1214:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:1215:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + sspi->regs->rxfifo_op);
spi-sirf.c:1216:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + sspi->regs->txfifo_op);
spi-sirf.c:1217:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + sspi->regs->rxfifo_op);
spi-mxs.c:14: * Based on code from U-Boot bootloader by:
spi-mxs.c:17: * Based on spi-stmp.c, which is:
spi-mxs.c:39:#include <linux/dma-mapping.h>
spi-mxs.c:50:#include <linux/spi/mxs-spi.h>
spi-mxs.c:52:#define DRIVER_NAME		"mxs-spi"
spi-mxs.c:64:#define TXRX_DEASSERT_CS	(1<<1)	/* De-assert CS at end of txrx */
spi-mxs.c:75:	struct mxs_spi *spi = spi_master_get_devdata(dev->master);
spi-mxs.c:76:	struct mxs_ssp *ssp = &spi->ssp;
spi-mxs.c:77:	const unsigned int hz = min(dev->max_speed_hz, t->speed_hz);
spi-mxs.c:80:		dev_err(&dev->dev, "SPI clock rate of zero not allowed\n");
spi-mxs.c:81:		return -EINVAL;
spi-mxs.c:84:	if (hz != spi->sck) {
spi-mxs.c:88:		 * ssp->clk_rate.  Otherwise we would set the rate every transfer
spi-mxs.c:91:		spi->sck = hz;
spi-mxs.c:99:		ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);
spi-mxs.c:103:	       ((dev->mode & SPI_CPOL) ? BM_SSP_CTRL1_POLARITY : 0) |
spi-mxs.c:104:	       ((dev->mode & SPI_CPHA) ? BM_SSP_CTRL1_PHASE : 0),
spi-mxs.c:105:	       ssp->base + HW_SSP_CTRL1(ssp));
spi-mxs.c:107:	writel(0x0, ssp->base + HW_SSP_CMD0);
spi-mxs.c:108:	writel(0x0, ssp->base + HW_SSP_CMD1);
spi-mxs.c:123:	 * toggle the chip-select lines (nCS pins).
spi-mxs.c:136:	struct mxs_ssp *ssp = &spi->ssp;
spi-mxs.c:140:		reg = readl_relaxed(ssp->base + offset);
spi-mxs.c:151:	return -ETIMEDOUT;
spi-mxs.c:158:	complete(&spi->c);
spi-mxs.c:165:	dev_err(ssp->dev, "%s[%i] CTRL1=%08x STATUS=%08x\n",
spi-mxs.c:167:		readl(ssp->base + HW_SSP_CTRL1(ssp)),
spi-mxs.c:168:		readl(ssp->base + HW_SSP_STATUS(ssp)));
spi-mxs.c:176:	struct mxs_ssp *ssp = &spi->ssp;
spi-mxs.c:191:		return -EINVAL;
spi-mxs.c:195:		return -ENOMEM;
spi-mxs.c:197:	reinit_completion(&spi->c);
spi-mxs.c:200:	ctrl0 = readl(ssp->base + HW_SSP_CTRL0);
spi-mxs.c:214:		 * De-assert CS on last segment if flag is set (i.e., no more
spi-mxs.c:220:		if (ssp->devid == IMX23_SSP) {
spi-mxs.c:231:				ret = -ENOMEM;
spi-mxs.c:242:		ret = dma_map_sg(ssp->dev, &dma_xfer[sg_count].sg, 1,
spi-mxs.c:245:		len -= min;
spi-mxs.c:249:		desc = dmaengine_prep_slave_sg(ssp->dmach,
spi-mxs.c:251:				(ssp->devid == IMX23_SSP) ? 1 : 4,
spi-mxs.c:255:			dev_err(ssp->dev,
spi-mxs.c:257:			ret = -EINVAL;
spi-mxs.c:261:		desc = dmaengine_prep_slave_sg(ssp->dmach,
spi-mxs.c:267:			dev_err(ssp->dev,
spi-mxs.c:269:			ret = -EINVAL;
spi-mxs.c:278:	desc->callback = mxs_ssp_dma_irq_callback;
spi-mxs.c:279:	desc->callback_param = spi;
spi-mxs.c:283:	dma_async_issue_pending(ssp->dmach);
spi-mxs.c:285:	if (!wait_for_completion_timeout(&spi->c,
spi-mxs.c:287:		dev_err(ssp->dev, "DMA transfer timeout\n");
spi-mxs.c:288:		ret = -ETIMEDOUT;
spi-mxs.c:289:		dmaengine_terminate_all(ssp->dmach);
spi-mxs.c:296:	while (--sg_count >= 0) {
spi-mxs.c:298:		dma_unmap_sg(ssp->dev, &dma_xfer[sg_count].sg, 1,
spi-mxs.c:311:	struct mxs_ssp *ssp = &spi->ssp;
spi-mxs.c:314:	       ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);
spi-mxs.c:316:	while (len--) {
spi-mxs.c:319:			       ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);
spi-mxs.c:321:		if (ssp->devid == IMX23_SSP) {
spi-mxs.c:323:				ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);
spi-mxs.c:325:				ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);
spi-mxs.c:327:			writel(1, ssp->base + HW_SSP_XFER_SIZE);
spi-mxs.c:332:				ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);
spi-mxs.c:335:				ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);
spi-mxs.c:338:				ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);
spi-mxs.c:341:			return -ETIMEDOUT;
spi-mxs.c:344:			writel(*buf, ssp->base + HW_SSP_DATA(ssp));
spi-mxs.c:347:			     ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);
spi-mxs.c:352:				return -ETIMEDOUT;
spi-mxs.c:354:			*buf = (readl(ssp->base + HW_SSP_DATA(ssp)) & 0xff);
spi-mxs.c:358:			return -ETIMEDOUT;
spi-mxs.c:366:	return -ETIMEDOUT;
spi-mxs.c:373:	struct mxs_ssp *ssp = &spi->ssp;
spi-mxs.c:380:	       ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);
spi-mxs.c:381:	writel(mxs_spi_cs_to_reg(m->spi->chip_select),
spi-mxs.c:382:	       ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);
spi-mxs.c:384:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-mxs.c:386:		status = mxs_spi_setup_transfer(m->spi, t);
spi-mxs.c:390:		/* De-assert on last transfer, inverted by cs_change flag */
spi-mxs.c:391:		flag = (&t->transfer_list == m->transfers.prev) ^ t->cs_change ?
spi-mxs.c:403:		if (t->len < 32) {
spi-mxs.c:405:				ssp->base + HW_SSP_CTRL1(ssp) +
spi-mxs.c:408:			if (t->tx_buf)
spi-mxs.c:410:						(void *)t->tx_buf,
spi-mxs.c:411:						t->len, flag | TXRX_WRITE);
spi-mxs.c:412:			if (t->rx_buf)
spi-mxs.c:414:						t->rx_buf, t->len,
spi-mxs.c:418:				ssp->base + HW_SSP_CTRL1(ssp) +
spi-mxs.c:421:			if (t->tx_buf)
spi-mxs.c:423:						(void *)t->tx_buf, t->len,
spi-mxs.c:425:			if (t->rx_buf)
spi-mxs.c:427:						t->rx_buf, t->len,
spi-mxs.c:432:			stmp_reset_block(ssp->base);
spi-mxs.c:436:		m->actual_length += t->len;
spi-mxs.c:439:	m->status = status;
spi-mxs.c:446:	{ .compatible = "fsl,imx23-spi", .data = (void *) IMX23_SSP, },
spi-mxs.c:447:	{ .compatible = "fsl,imx28-spi", .data = (void *) IMX28_SSP, },
spi-mxs.c:455:			of_match_device(mxs_spi_dt_ids, &pdev->dev);
spi-mxs.c:456:	struct device_node *np = pdev->dev.of_node;
spi-mxs.c:469:	 * as a default. Override with "clock-frequency" DT prop.
spi-mxs.c:478:	base = devm_ioremap_resource(&pdev->dev, iores);
spi-mxs.c:482:	clk = devm_clk_get(&pdev->dev, NULL);
spi-mxs.c:486:	devid = (enum mxs_ssp_id) of_id->data;
spi-mxs.c:487:	ret = of_property_read_u32(np, "clock-frequency",
spi-mxs.c:492:	master = spi_alloc_master(&pdev->dev, sizeof(*spi));
spi-mxs.c:494:		return -ENOMEM;
spi-mxs.c:496:	master->transfer_one_message = mxs_spi_transfer_one;
spi-mxs.c:497:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-mxs.c:498:	master->mode_bits = SPI_CPOL | SPI_CPHA;
spi-mxs.c:499:	master->num_chipselect = 3;
spi-mxs.c:500:	master->dev.of_node = np;
spi-mxs.c:501:	master->flags = SPI_MASTER_HALF_DUPLEX;
spi-mxs.c:504:	ssp = &spi->ssp;
spi-mxs.c:505:	ssp->dev = &pdev->dev;
spi-mxs.c:506:	ssp->clk = clk;
spi-mxs.c:507:	ssp->base = base;
spi-mxs.c:508:	ssp->devid = devid;
spi-mxs.c:510:	init_completion(&spi->c);
spi-mxs.c:512:	ret = devm_request_irq(&pdev->dev, irq_err, mxs_ssp_irq_handler, 0,
spi-mxs.c:513:			       dev_name(&pdev->dev), ssp);
spi-mxs.c:517:	ssp->dmach = dma_request_slave_channel(&pdev->dev, "rx-tx");
spi-mxs.c:518:	if (!ssp->dmach) {
spi-mxs.c:519:		dev_err(ssp->dev, "Failed to request DMA\n");
spi-mxs.c:520:		ret = -ENODEV;
spi-mxs.c:524:	ret = clk_prepare_enable(ssp->clk);
spi-mxs.c:528:	clk_set_rate(ssp->clk, clk_freq);
spi-mxs.c:530:	ret = stmp_reset_block(ssp->base);
spi-mxs.c:536:	ret = devm_spi_register_master(&pdev->dev, master);
spi-mxs.c:538:		dev_err(&pdev->dev, "Cannot register SPI master, %d\n", ret);
spi-mxs.c:545:	clk_disable_unprepare(ssp->clk);
spi-mxs.c:547:	dma_release_channel(ssp->dmach);
spi-mxs.c:561:	ssp = &spi->ssp;
spi-mxs.c:563:	clk_disable_unprepare(ssp->clk);
spi-mxs.c:564:	dma_release_channel(ssp->dmach);
spi-mxs.c:583:MODULE_ALIAS("platform:mxs-spi");
spi-bcm2835.c:9: * spi-ath79.c, Copyright (C) 2009-2011 Gabor Juhos <juhosg@openwrt.org>
spi-bcm2835.c:10: * spi-atmel.c, Copyright (C) 2006 Atmel Corporation
spi-bcm2835.c:27:#include <linux/dma-mapping.h>
spi-bcm2835.c:81:#define DRV_NAME	"spi-bcm2835"
spi-bcm2835.c:96:	return readl(bs->regs + reg);
spi-bcm2835.c:101:	writel(val, bs->regs + reg);
spi-bcm2835.c:108:	while ((bs->rx_len) &&
spi-bcm2835.c:111:		if (bs->rx_buf)
spi-bcm2835.c:112:			*bs->rx_buf++ = byte;
spi-bcm2835.c:113:		bs->rx_len--;
spi-bcm2835.c:121:	while ((bs->tx_len) &&
spi-bcm2835.c:123:		byte = bs->tx_buf ? *bs->tx_buf++ : 0;
spi-bcm2835.c:125:		bs->tx_len--;
spi-bcm2835.c:158:	if (!bs->rx_len) {
spi-bcm2835.c:159:		/* Transfer complete - reset SPI HW */
spi-bcm2835.c:162:		complete(&master->xfer_completion);
spi-bcm2835.c:175:	/* fill in fifo if we have gpio-cs
spi-bcm2835.c:176:	 * note that there have been rare events where the native-CS
spi-bcm2835.c:178:	 * with gpio-cs this does not happen, so it is implemented
spi-bcm2835.c:181:	if (gpio_is_valid(spi->cs_gpio)) {
spi-bcm2835.c:194:	 * first TX bytes. Pre-filling the TX FIFO here to avoid the
spi-bcm2835.c:195:	 * interrupt doesn't work:-(
spi-bcm2835.c:213: * also we currently assume that the scatter-gather fragments are
spi-bcm2835.c:214: * all multiple of 4 (except the last) - otherwise we would need
spi-bcm2835.c:218: * there may be a few more border-cases we may need to address as well
spi-bcm2835.c:219: * but unfortunately this would mean splitting up the scatter-gather
spi-bcm2835.c:230:	/* and terminate tx-dma as we do not have an irq for it
spi-bcm2835.c:232:	 * is called the tx-dma must have finished - can't get to this
spi-bcm2835.c:235:	if (cmpxchg(&bs->dma_pending, true, false)) {
spi-bcm2835.c:236:		dmaengine_terminate_all(master->dma_tx);
spi-bcm2835.c:240:	complete(&master->xfer_completion);
spi-bcm2835.c:258:		chan  = master->dma_tx;
spi-bcm2835.c:259:		nents = tfr->tx_sg.nents;
spi-bcm2835.c:260:		sgl   = tfr->tx_sg.sgl;
spi-bcm2835.c:265:		chan  = master->dma_rx;
spi-bcm2835.c:266:		nents = tfr->rx_sg.nents;
spi-bcm2835.c:267:		sgl   = tfr->rx_sg.sgl;
spi-bcm2835.c:273:		return -EINVAL;
spi-bcm2835.c:277:		desc->callback = bcm2835_spi_dma_done;
spi-bcm2835.c:278:		desc->callback_param = master;
spi-bcm2835.c:281:	/* submit it to DMA-engine */
spi-bcm2835.c:292:	/* check that the sg entries are word-sized (except for last) */
spi-bcm2835.c:293:	for_each_sg(sgt->sgl, sgl, (int)sgt->nents - 1, i) {
spi-bcm2835.c:295:			return -EFAULT;
spi-bcm2835.c:310:	if (bcm2835_check_sg_length(&tfr->tx_sg) ||
spi-bcm2835.c:311:	    bcm2835_check_sg_length(&tfr->rx_sg)) {
spi-bcm2835.c:312:		dev_warn_once(&spi->dev,
spi-bcm2835.c:313:			      "scatter gather segment length is not a multiple of 4 - falling back to interrupt mode\n");
spi-bcm2835.c:317:	/* setup tx-DMA */
spi-bcm2835.c:323:	dma_async_issue_pending(master->dma_tx);
spi-bcm2835.c:326:	bs->dma_pending = 1;
spi-bcm2835.c:329:	bcm2835_wr(bs, BCM2835_SPI_DLEN, tfr->len);
spi-bcm2835.c:335:	/* setup rx-DMA late - to run transfers while
spi-bcm2835.c:342:		dmaengine_terminate_all(master->dma_tx);
spi-bcm2835.c:343:		bs->dma_pending = false;
spi-bcm2835.c:349:	dma_async_issue_pending(master->dma_rx);
spi-bcm2835.c:360:	if (!gpio_is_valid(spi->cs_gpio))
spi-bcm2835.c:364:	if (tfr->len < BCM2835_SPI_DMA_MIN_LENGTH)
spi-bcm2835.c:370:	 * method - ideally this would get done without any more
spi-bcm2835.c:373:	if (tfr->len > 65535) {
spi-bcm2835.c:374:		dev_warn_once(&spi->dev,
spi-bcm2835.c:375:			      "transfer size of %d too big for dma-transfer\n",
spi-bcm2835.c:376:			      tfr->len);
spi-bcm2835.c:381:	if ((((size_t)tfr->rx_buf & 3) == 0) &&
spi-bcm2835.c:382:	    (((size_t)tfr->tx_buf & 3) == 0))
spi-bcm2835.c:388:	if (((size_t)tfr->tx_buf & (PAGE_SIZE - 1)) + tfr->len > PAGE_SIZE) {
spi-bcm2835.c:389:		dev_warn_once(&spi->dev,
spi-bcm2835.c:390:			      "Unaligned spi tx-transfer bridging page\n");
spi-bcm2835.c:393:	if (((size_t)tfr->rx_buf & (PAGE_SIZE - 1)) + tfr->len > PAGE_SIZE) {
spi-bcm2835.c:394:		dev_warn_once(&spi->dev,
spi-bcm2835.c:395:			      "Unaligned spi rx-transfer bridging page\n");
spi-bcm2835.c:405:	if (master->dma_tx) {
spi-bcm2835.c:406:		dmaengine_terminate_all(master->dma_tx);
spi-bcm2835.c:407:		dma_release_channel(master->dma_tx);
spi-bcm2835.c:408:		master->dma_tx = NULL;
spi-bcm2835.c:410:	if (master->dma_rx) {
spi-bcm2835.c:411:		dmaengine_terminate_all(master->dma_rx);
spi-bcm2835.c:412:		dma_release_channel(master->dma_rx);
spi-bcm2835.c:413:		master->dma_rx = NULL;
spi-bcm2835.c:424:	/* base address in dma-space */
spi-bcm2835.c:425:	addr = of_get_address(master->dev.of_node, 0, NULL, NULL);
spi-bcm2835.c:427:		dev_err(dev, "could not get DMA-register address - not using dma mode\n");
spi-bcm2835.c:433:	master->dma_tx = dma_request_slave_channel(dev, "tx");
spi-bcm2835.c:434:	if (!master->dma_tx) {
spi-bcm2835.c:435:		dev_err(dev, "no tx-dma configuration found - not using dma mode\n");
spi-bcm2835.c:438:	master->dma_rx = dma_request_slave_channel(dev, "rx");
spi-bcm2835.c:439:	if (!master->dma_rx) {
spi-bcm2835.c:440:		dev_err(dev, "no rx-dma configuration found - not using dma mode\n");
spi-bcm2835.c:449:	ret = dmaengine_slave_config(master->dma_tx, &slave_config);
spi-bcm2835.c:457:	ret = dmaengine_slave_config(master->dma_rx, &slave_config);
spi-bcm2835.c:462:	master->can_dma = bcm2835_spi_can_dma;
spi-bcm2835.c:463:	master->max_dma_len = 65535; /* limitation by BCM2835_SPI_DLEN */
spi-bcm2835.c:465:	master->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;
spi-bcm2835.c:470:	dev_err(dev, "issue configuring dma: %d - not using DMA mode\n",
spi-bcm2835.c:500:	while (bs->rx_len) {
spi-bcm2835.c:510:		if (bs->rx_len && time_after(jiffies, timeout)) {
spi-bcm2835.c:511:			dev_dbg_ratelimited(&spi->dev,
spi-bcm2835.c:512:					    "timeout period reached: jiffies: %lu remaining tx/rx: %d/%d - falling back to interrupt mode\n",
spi-bcm2835.c:513:					    jiffies - timeout,
spi-bcm2835.c:514:					    bs->tx_len, bs->rx_len);
spi-bcm2835.c:521:	/* Transfer complete - reset SPI HW */
spi-bcm2835.c:538:	spi_hz = tfr->speed_hz;
spi-bcm2835.c:539:	clk_hz = clk_get_rate(bs->clk);
spi-bcm2835.c:556:	/* handle all the 3-wire mode */
spi-bcm2835.c:557:	if (spi->mode & SPI_3WIRE && tfr->rx_buf &&
spi-bcm2835.c:558:	    tfr->rx_buf != master->dummy_rx)
spi-bcm2835.c:563:	/* for gpio_cs set dummy CS so that no HW-CS get changed
spi-bcm2835.c:567:	if (gpio_is_valid(spi->cs_gpio) || (spi->mode & SPI_NO_CS))
spi-bcm2835.c:571:	bs->tx_buf = tfr->tx_buf;
spi-bcm2835.c:572:	bs->rx_buf = tfr->rx_buf;
spi-bcm2835.c:573:	bs->tx_len = tfr->len;
spi-bcm2835.c:574:	bs->rx_len = tfr->len;
spi-bcm2835.c:577:	xfer_time_us = (unsigned long long)tfr->len
spi-bcm2835.c:578:		* 9 /* clocks/byte - SPI-HW waits 1 clock after each byte */
spi-bcm2835.c:588:	if (master->can_dma && bcm2835_spi_can_dma(master, spi, tfr))
spi-bcm2835.c:591:	/* run in interrupt-mode */
spi-bcm2835.c:598:	struct spi_device *spi = msg->spi;
spi-bcm2835.c:604:	if (spi->mode & SPI_CPOL)
spi-bcm2835.c:606:	if (spi->mode & SPI_CPHA)
spi-bcm2835.c:620:	if (cmpxchg(&bs->dma_pending, true, false)) {
spi-bcm2835.c:621:		dmaengine_terminate_all(master->dma_tx);
spi-bcm2835.c:622:		dmaengine_terminate_all(master->dma_rx);
spi-bcm2835.c:640:	struct spi_master *master = spi->master;
spi-bcm2835.c:646:	enable = (spi->mode & SPI_CS_HIGH) ? gpio_level : !gpio_level;
spi-bcm2835.c:649:	if (spi->mode & SPI_CS_HIGH) {
spi-bcm2835.c:650:		/* set the correct CS-bits */
spi-bcm2835.c:652:		cs |= BCM2835_SPI_CS_CSPOL0 << spi->chip_select;
spi-bcm2835.c:654:		/* clean the CS-bits */
spi-bcm2835.c:656:		cs &= ~(BCM2835_SPI_CS_CSPOL0 << spi->chip_select);
spi-bcm2835.c:662:		if (spi->mode & SPI_NO_CS) {
spi-bcm2835.c:663:			/* use the "undefined" chip-select */
spi-bcm2835.c:668:			cs |= spi->chip_select;
spi-bcm2835.c:671:		/* disable CSPOL which puts HW-CS into deselected state */
spi-bcm2835.c:673:		/* use the "undefined" chip-select as precaution */
spi-bcm2835.c:683:	return !strcmp(chip->label, data);
spi-bcm2835.c:691:	 * sanity checking the native-chipselects
spi-bcm2835.c:693:	if (spi->mode & SPI_NO_CS)
spi-bcm2835.c:695:	if (gpio_is_valid(spi->cs_gpio))
spi-bcm2835.c:697:	if (spi->chip_select > 1) {
spi-bcm2835.c:702:		dev_err(&spi->dev,
spi-bcm2835.c:703:			"setup: only two native chip-selects are supported\n");
spi-bcm2835.c:704:		return -EINVAL;
spi-bcm2835.c:709:	chip = gpiochip_find("pinctrl-bcm2835", chip_match_name);
spi-bcm2835.c:714:	spi->cs_gpio = chip->base + 8 - spi->chip_select;
spi-bcm2835.c:717:	dev_info(&spi->dev, "setting up native-CS%i as GPIO %i\n",
spi-bcm2835.c:718:		 spi->chip_select, spi->cs_gpio);
spi-bcm2835.c:721:	err = gpio_direction_output(spi->cs_gpio,
spi-bcm2835.c:722:				    (spi->mode & SPI_CS_HIGH) ? 0 : 1);
spi-bcm2835.c:724:		dev_err(&spi->dev,
spi-bcm2835.c:726:			spi->chip_select, spi->cs_gpio, err);
spi-bcm2835.c:729:	/* the implementation of pinctrl-bcm2835 currently does not
spi-bcm2835.c:733:	gpio_set_value(spi->cs_gpio, (spi->mode & SPI_CS_HIGH) ? 0 : 1);
spi-bcm2835.c:745:	master = spi_alloc_master(&pdev->dev, sizeof(*bs));
spi-bcm2835.c:747:		dev_err(&pdev->dev, "spi_alloc_master() failed\n");
spi-bcm2835.c:748:		return -ENOMEM;
spi-bcm2835.c:753:	master->mode_bits = BCM2835_SPI_MODE_BITS;
spi-bcm2835.c:754:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-bcm2835.c:755:	master->num_chipselect = 3;
spi-bcm2835.c:756:	master->setup = bcm2835_spi_setup;
spi-bcm2835.c:757:	master->set_cs = bcm2835_spi_set_cs;
spi-bcm2835.c:758:	master->transfer_one = bcm2835_spi_transfer_one;
spi-bcm2835.c:759:	master->handle_err = bcm2835_spi_handle_err;
spi-bcm2835.c:760:	master->prepare_message = bcm2835_spi_prepare_message;
spi-bcm2835.c:761:	master->dev.of_node = pdev->dev.of_node;
spi-bcm2835.c:766:	bs->regs = devm_ioremap_resource(&pdev->dev, res);
spi-bcm2835.c:767:	if (IS_ERR(bs->regs)) {
spi-bcm2835.c:768:		err = PTR_ERR(bs->regs);
spi-bcm2835.c:772:	bs->clk = devm_clk_get(&pdev->dev, NULL);
spi-bcm2835.c:773:	if (IS_ERR(bs->clk)) {
spi-bcm2835.c:774:		err = PTR_ERR(bs->clk);
spi-bcm2835.c:775:		dev_err(&pdev->dev, "could not get clk: %d\n", err);
spi-bcm2835.c:779:	bs->irq = platform_get_irq(pdev, 0);
spi-bcm2835.c:780:	if (bs->irq <= 0) {
spi-bcm2835.c:781:		dev_err(&pdev->dev, "could not get IRQ: %d\n", bs->irq);
spi-bcm2835.c:782:		err = bs->irq ? bs->irq : -ENODEV;
spi-bcm2835.c:786:	clk_prepare_enable(bs->clk);
spi-bcm2835.c:788:	bcm2835_dma_init(master, &pdev->dev);
spi-bcm2835.c:794:	err = devm_request_irq(&pdev->dev, bs->irq, bcm2835_spi_interrupt, 0,
spi-bcm2835.c:795:			       dev_name(&pdev->dev), master);
spi-bcm2835.c:797:		dev_err(&pdev->dev, "could not request IRQ: %d\n", err);
spi-bcm2835.c:801:	err = devm_spi_register_master(&pdev->dev, master);
spi-bcm2835.c:803:		dev_err(&pdev->dev, "could not register SPI master: %d\n", err);
spi-bcm2835.c:810:	clk_disable_unprepare(bs->clk);
spi-bcm2835.c:825:	clk_disable_unprepare(bs->clk);
spi-bcm2835.c:833:	{ .compatible = "brcm,bcm2835-spi", },
spi-bfin-sport.c:6: * Copyright 2009-2011 Analog Devices Inc.
spi-bfin-sport.c:8: * Licensed under the GPL-2 or later.
spi-bfin-sport.c:30:#define DRV_NAME	"bfin-sport-spi"
spi-bfin-sport.c:36:MODULE_ALIAS("platform:bfin-sport-spi");
spi-bfin-sport.c:112:	bfin_write_or(&drv_data->regs->tcr1, TSPEN);
spi-bfin-sport.c:113:	bfin_write_or(&drv_data->regs->rcr1, TSPEN);
spi-bfin-sport.c:120:	bfin_write_and(&drv_data->regs->tcr1, ~TSPEN);
spi-bfin-sport.c:121:	bfin_write_and(&drv_data->regs->rcr1, ~TSPEN);
spi-bfin-sport.c:130:	int div = (sclk / (2 * speed_hz)) - 1;
spi-bfin-sport.c:147:	gpio_direction_output(chip->cs_gpio, 0);
spi-bfin-sport.c:153:	gpio_direction_output(chip->cs_gpio, 1);
spi-bfin-sport.c:155:	if (chip->cs_chg_udelay)
spi-bfin-sport.c:156:		udelay(chip->cs_chg_udelay);
spi-bfin-sport.c:163:	while (!(bfin_read(&drv_data->regs->stat) & RXNE)) {
spi-bfin-sport.c:174:	while (drv_data->tx < drv_data->tx_end) {
spi-bfin-sport.c:175:		bfin_write(&drv_data->regs->tx16, *drv_data->tx8++);
spi-bfin-sport.c:177:		dummy = bfin_read(&drv_data->regs->rx16);
spi-bfin-sport.c:184:	u16 tx_val = drv_data->cur_chip->idle_tx_val;
spi-bfin-sport.c:186:	while (drv_data->rx < drv_data->rx_end) {
spi-bfin-sport.c:187:		bfin_write(&drv_data->regs->tx16, tx_val);
spi-bfin-sport.c:189:		*drv_data->rx8++ = bfin_read(&drv_data->regs->rx16);
spi-bfin-sport.c:196:	while (drv_data->rx < drv_data->rx_end) {
spi-bfin-sport.c:197:		bfin_write(&drv_data->regs->tx16, *drv_data->tx8++);
spi-bfin-sport.c:199:		*drv_data->rx8++ = bfin_read(&drv_data->regs->rx16);
spi-bfin-sport.c:214:	while (drv_data->tx < drv_data->tx_end) {
spi-bfin-sport.c:215:		bfin_write(&drv_data->regs->tx16, *drv_data->tx16++);
spi-bfin-sport.c:217:		dummy = bfin_read(&drv_data->regs->rx16);
spi-bfin-sport.c:224:	u16 tx_val = drv_data->cur_chip->idle_tx_val;
spi-bfin-sport.c:226:	while (drv_data->rx < drv_data->rx_end) {
spi-bfin-sport.c:227:		bfin_write(&drv_data->regs->tx16, tx_val);
spi-bfin-sport.c:229:		*drv_data->rx16++ = bfin_read(&drv_data->regs->rx16);
spi-bfin-sport.c:236:	while (drv_data->rx < drv_data->rx_end) {
spi-bfin-sport.c:237:		bfin_write(&drv_data->regs->tx16, *drv_data->tx16++);
spi-bfin-sport.c:239:		*drv_data->rx16++ = bfin_read(&drv_data->regs->rx16);
spi-bfin-sport.c:249:/* stop controller and re-config current chip */
spi-bfin-sport.c:253:	struct bfin_sport_spi_slave_data *chip = drv_data->cur_chip;
spi-bfin-sport.c:256:	dev_dbg(drv_data->dev, "restoring spi ctl state\n");
spi-bfin-sport.c:258:	bfin_write(&drv_data->regs->tcr1, chip->ctl_reg);
spi-bfin-sport.c:259:	bfin_write(&drv_data->regs->tclkdiv, chip->baud);
spi-bfin-sport.c:262:	bfin_write(&drv_data->regs->rcr1, chip->ctl_reg & ~(ITCLK | ITFS));
spi-bfin-sport.c:272:	struct spi_message *msg = drv_data->cur_msg;
spi-bfin-sport.c:273:	struct spi_transfer *trans = drv_data->cur_transfer;
spi-bfin-sport.c:276:	if (trans->transfer_list.next != &msg->transfers) {
spi-bfin-sport.c:277:		drv_data->cur_transfer =
spi-bfin-sport.c:278:		    list_entry(trans->transfer_list.next,
spi-bfin-sport.c:287: * caller already set message->status;
spi-bfin-sport.c:293:	struct bfin_sport_spi_slave_data *chip = drv_data->cur_chip;
spi-bfin-sport.c:297:	spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin-sport.c:298:	msg = drv_data->cur_msg;
spi-bfin-sport.c:299:	drv_data->state = START_STATE;
spi-bfin-sport.c:300:	drv_data->cur_msg = NULL;
spi-bfin-sport.c:301:	drv_data->cur_transfer = NULL;
spi-bfin-sport.c:302:	drv_data->cur_chip = NULL;
spi-bfin-sport.c:303:	queue_work(drv_data->workqueue, &drv_data->pump_messages);
spi-bfin-sport.c:304:	spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin-sport.c:306:	if (!drv_data->cs_change)
spi-bfin-sport.c:309:	if (msg->complete)
spi-bfin-sport.c:310:		msg->complete(msg->context);
spi-bfin-sport.c:319:	dev_dbg(drv_data->dev, "%s enter\n", __func__);
spi-bfin-sport.c:320:	status = bfin_read(&drv_data->regs->stat) & (TOVF | TUVF | ROVF | RUVF);
spi-bfin-sport.c:323:		bfin_write(&drv_data->regs->stat, status);
spi-bfin-sport.c:327:		dev_err(drv_data->dev, "status error:%s%s%s%s\n",
spi-bfin-sport.c:351:	message = drv_data->cur_msg;
spi-bfin-sport.c:352:	transfer = drv_data->cur_transfer;
spi-bfin-sport.c:353:	chip = drv_data->cur_chip;
spi-bfin-sport.c:355:	transfer_speed = bfin_sport_hz_to_spi_baud(transfer->speed_hz);
spi-bfin-sport.c:356:	bfin_write(&drv_data->regs->tclkdiv, transfer_speed);
spi-bfin-sport.c:364:	if (drv_data->state == ERROR_STATE) {
spi-bfin-sport.c:365:		dev_dbg(drv_data->dev, "transfer: we've hit an error\n");
spi-bfin-sport.c:366:		message->status = -EIO;
spi-bfin-sport.c:372:	if (drv_data->state == DONE_STATE) {
spi-bfin-sport.c:373:		dev_dbg(drv_data->dev, "transfer: all done!\n");
spi-bfin-sport.c:374:		message->status = 0;
spi-bfin-sport.c:380:	if (drv_data->state == RUNNING_STATE) {
spi-bfin-sport.c:381:		dev_dbg(drv_data->dev, "transfer: still running ...\n");
spi-bfin-sport.c:382:		previous = list_entry(transfer->transfer_list.prev,
spi-bfin-sport.c:384:		if (previous->delay_usecs)
spi-bfin-sport.c:385:			udelay(previous->delay_usecs);
spi-bfin-sport.c:388:	if (transfer->len == 0) {
spi-bfin-sport.c:390:		drv_data->state = bfin_sport_spi_next_transfer(drv_data);
spi-bfin-sport.c:392:		tasklet_schedule(&drv_data->pump_transfers);
spi-bfin-sport.c:395:	if (transfer->tx_buf != NULL) {
spi-bfin-sport.c:396:		drv_data->tx = (void *)transfer->tx_buf;
spi-bfin-sport.c:397:		drv_data->tx_end = drv_data->tx + transfer->len;
spi-bfin-sport.c:398:		dev_dbg(drv_data->dev, "tx_buf is %p, tx_end is %p\n",
spi-bfin-sport.c:399:			transfer->tx_buf, drv_data->tx_end);
spi-bfin-sport.c:401:		drv_data->tx = NULL;
spi-bfin-sport.c:403:	if (transfer->rx_buf != NULL) {
spi-bfin-sport.c:404:		full_duplex = transfer->tx_buf != NULL;
spi-bfin-sport.c:405:		drv_data->rx = transfer->rx_buf;
spi-bfin-sport.c:406:		drv_data->rx_end = drv_data->rx + transfer->len;
spi-bfin-sport.c:407:		dev_dbg(drv_data->dev, "rx_buf is %p, rx_end is %p\n",
spi-bfin-sport.c:408:			transfer->rx_buf, drv_data->rx_end);
spi-bfin-sport.c:410:		drv_data->rx = NULL;
spi-bfin-sport.c:412:	drv_data->cs_change = transfer->cs_change;
spi-bfin-sport.c:415:	bits_per_word = transfer->bits_per_word;
spi-bfin-sport.c:417:		drv_data->ops = &bfin_sport_transfer_ops_u16;
spi-bfin-sport.c:419:		drv_data->ops = &bfin_sport_transfer_ops_u8;
spi-bfin-sport.c:420:	bfin_write(&drv_data->regs->tcr2, bits_per_word - 1);
spi-bfin-sport.c:421:	bfin_write(&drv_data->regs->tfsdiv, bits_per_word - 1);
spi-bfin-sport.c:422:	bfin_write(&drv_data->regs->rcr2, bits_per_word - 1);
spi-bfin-sport.c:424:	drv_data->state = RUNNING_STATE;
spi-bfin-sport.c:426:	if (drv_data->cs_change)
spi-bfin-sport.c:429:	dev_dbg(drv_data->dev,
spi-bfin-sport.c:431:		bits_per_word, transfer->len);
spi-bfin-sport.c:434:	dev_dbg(drv_data->dev, "doing IO transfer\n");
spi-bfin-sport.c:439:		BUG_ON((drv_data->tx_end - drv_data->tx) !=
spi-bfin-sport.c:440:		       (drv_data->rx_end - drv_data->rx));
spi-bfin-sport.c:441:		drv_data->ops->duplex(drv_data);
spi-bfin-sport.c:443:		if (drv_data->tx != drv_data->tx_end)
spi-bfin-sport.c:445:	} else if (drv_data->tx != NULL) {
spi-bfin-sport.c:448:		drv_data->ops->write(drv_data);
spi-bfin-sport.c:450:		if (drv_data->tx != drv_data->tx_end)
spi-bfin-sport.c:452:	} else if (drv_data->rx != NULL) {
spi-bfin-sport.c:455:		drv_data->ops->read(drv_data);
spi-bfin-sport.c:456:		if (drv_data->rx != drv_data->rx_end)
spi-bfin-sport.c:462:		dev_dbg(drv_data->dev, "IO write error!\n");
spi-bfin-sport.c:463:		drv_data->state = ERROR_STATE;
spi-bfin-sport.c:466:		message->actual_length += transfer->len;
spi-bfin-sport.c:468:		drv_data->state = bfin_sport_spi_next_transfer(drv_data);
spi-bfin-sport.c:469:		if (drv_data->cs_change)
spi-bfin-sport.c:474:	tasklet_schedule(&drv_data->pump_transfers);
spi-bfin-sport.c:488:	spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin-sport.c:489:	if (list_empty(&drv_data->queue) || !drv_data->run) {
spi-bfin-sport.c:491:		drv_data->busy = 0;
spi-bfin-sport.c:492:		spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin-sport.c:497:	if (drv_data->cur_msg) {
spi-bfin-sport.c:498:		spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin-sport.c:503:	next_msg = list_entry(drv_data->queue.next,
spi-bfin-sport.c:506:	drv_data->cur_msg = next_msg;
spi-bfin-sport.c:509:	drv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);
spi-bfin-sport.c:511:	list_del_init(&drv_data->cur_msg->queue);
spi-bfin-sport.c:514:	drv_data->cur_msg->state = START_STATE;
spi-bfin-sport.c:515:	drv_data->cur_transfer = list_entry(drv_data->cur_msg->transfers.next,
spi-bfin-sport.c:518:	dev_dbg(drv_data->dev, "got a message to pump, "
spi-bfin-sport.c:520:		drv_data->cur_chip->baud, drv_data->cur_chip->cs_gpio,
spi-bfin-sport.c:521:		drv_data->cur_chip->ctl_reg);
spi-bfin-sport.c:523:	dev_dbg(drv_data->dev,
spi-bfin-sport.c:525:		drv_data->cur_transfer->len);
spi-bfin-sport.c:528:	tasklet_schedule(&drv_data->pump_transfers);
spi-bfin-sport.c:530:	drv_data->busy = 1;
spi-bfin-sport.c:531:	spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin-sport.c:535: * got a msg to transfer, queue it in drv_data->queue.
spi-bfin-sport.c:541:	struct bfin_sport_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
spi-bfin-sport.c:544:	spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin-sport.c:546:	if (!drv_data->run) {
spi-bfin-sport.c:547:		spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin-sport.c:548:		return -ESHUTDOWN;
spi-bfin-sport.c:551:	msg->actual_length = 0;
spi-bfin-sport.c:552:	msg->status = -EINPROGRESS;
spi-bfin-sport.c:553:	msg->state = START_STATE;
spi-bfin-sport.c:555:	dev_dbg(&spi->dev, "adding an msg in transfer()\n");
spi-bfin-sport.c:556:	list_add_tail(&msg->queue, &drv_data->queue);
spi-bfin-sport.c:558:	if (drv_data->run && !drv_data->busy)
spi-bfin-sport.c:559:		queue_work(drv_data->workqueue, &drv_data->pump_messages);
spi-bfin-sport.c:561:	spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin-sport.c:580:			return -ENOMEM;
spi-bfin-sport.c:583:		chip_info = spi->controller_data;
spi-bfin-sport.c:589:			if (chip_info->ctl_reg || chip_info->enable_dma) {
spi-bfin-sport.c:590:				ret = -EINVAL;
spi-bfin-sport.c:591:				dev_err(&spi->dev, "don't set ctl_reg/enable_dma fields\n");
spi-bfin-sport.c:594:			chip->cs_chg_udelay = chip_info->cs_chg_udelay;
spi-bfin-sport.c:595:			chip->idle_tx_val = chip_info->idle_tx_val;
spi-bfin-sport.c:603:	if (spi->mode & SPI_CPHA)
spi-bfin-sport.c:604:		chip->ctl_reg &= ~TCKFE;
spi-bfin-sport.c:606:		chip->ctl_reg |= TCKFE;
spi-bfin-sport.c:608:	if (spi->mode & SPI_LSB_FIRST)
spi-bfin-sport.c:609:		chip->ctl_reg |= TLSBIT;
spi-bfin-sport.c:611:		chip->ctl_reg &= ~TLSBIT;
spi-bfin-sport.c:614:	chip->ctl_reg |= ITCLK | ITFS | TFSR | LATFS | LTFS;
spi-bfin-sport.c:616:	chip->baud = bfin_sport_hz_to_spi_baud(spi->max_speed_hz);
spi-bfin-sport.c:618:	chip->cs_gpio = spi->chip_select;
spi-bfin-sport.c:619:	ret = gpio_request(chip->cs_gpio, spi->modalias);
spi-bfin-sport.c:623:	dev_dbg(&spi->dev, "setup spi chip %s, width is %d\n",
spi-bfin-sport.c:624:			spi->modalias, spi->bits_per_word);
spi-bfin-sport.c:625:	dev_dbg(&spi->dev, "ctl_reg is 0x%x, GPIO is %i\n",
spi-bfin-sport.c:626:			chip->ctl_reg, spi->chip_select);
spi-bfin-sport.c:651:	gpio_free(chip->cs_gpio);
spi-bfin-sport.c:659:	INIT_LIST_HEAD(&drv_data->queue);
spi-bfin-sport.c:660:	spin_lock_init(&drv_data->lock);
spi-bfin-sport.c:662:	drv_data->run = false;
spi-bfin-sport.c:663:	drv_data->busy = 0;
spi-bfin-sport.c:666:	tasklet_init(&drv_data->pump_transfers,
spi-bfin-sport.c:670:	INIT_WORK(&drv_data->pump_messages, bfin_sport_spi_pump_messages);
spi-bfin-sport.c:671:	drv_data->workqueue =
spi-bfin-sport.c:672:	    create_singlethread_workqueue(dev_name(drv_data->master->dev.parent));
spi-bfin-sport.c:673:	if (drv_data->workqueue == NULL)
spi-bfin-sport.c:674:		return -EBUSY;
spi-bfin-sport.c:684:	spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin-sport.c:686:	if (drv_data->run || drv_data->busy) {
spi-bfin-sport.c:687:		spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin-sport.c:688:		return -EBUSY;
spi-bfin-sport.c:691:	drv_data->run = true;
spi-bfin-sport.c:692:	drv_data->cur_msg = NULL;
spi-bfin-sport.c:693:	drv_data->cur_transfer = NULL;
spi-bfin-sport.c:694:	drv_data->cur_chip = NULL;
spi-bfin-sport.c:695:	spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin-sport.c:697:	queue_work(drv_data->workqueue, &drv_data->pump_messages);
spi-bfin-sport.c:709:	spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin-sport.c:713:	 * A wait_queue on the drv_data->busy could be used, but then the common
spi-bfin-sport.c:717:	drv_data->run = false;
spi-bfin-sport.c:718:	while (!list_empty(&drv_data->queue) && drv_data->busy && limit--) {
spi-bfin-sport.c:719:		spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin-sport.c:721:		spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin-sport.c:724:	if (!list_empty(&drv_data->queue) || drv_data->busy)
spi-bfin-sport.c:725:		status = -EBUSY;
spi-bfin-sport.c:727:	spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin-sport.c:741:	destroy_workqueue(drv_data->workqueue);
spi-bfin-sport.c:748:	struct device *dev = &pdev->dev;
spi-bfin-sport.c:761:		return -ENOMEM;
spi-bfin-sport.c:765:	drv_data->master = master;
spi-bfin-sport.c:766:	drv_data->dev = dev;
spi-bfin-sport.c:767:	drv_data->pin_req = platform_info->pin_req;
spi-bfin-sport.c:769:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;
spi-bfin-sport.c:770:	master->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);
spi-bfin-sport.c:771:	master->bus_num = pdev->id;
spi-bfin-sport.c:772:	master->num_chipselect = platform_info->num_chipselect;
spi-bfin-sport.c:773:	master->cleanup = bfin_sport_spi_cleanup;
spi-bfin-sport.c:774:	master->setup = bfin_sport_spi_setup;
spi-bfin-sport.c:775:	master->transfer = bfin_sport_spi_transfer;
spi-bfin-sport.c:781:		status = -ENOENT;
spi-bfin-sport.c:785:	drv_data->regs = ioremap(res->start, resource_size(res));
spi-bfin-sport.c:786:	if (drv_data->regs == NULL) {
spi-bfin-sport.c:788:		status = -ENXIO;
spi-bfin-sport.c:795:		status = -ENODEV;
spi-bfin-sport.c:798:	drv_data->err_irq = ires->start;
spi-bfin-sport.c:813:	status = request_irq(drv_data->err_irq, sport_err_handler,
spi-bfin-sport.c:820:	status = peripheral_request_list(drv_data->pin_req, DRV_NAME);
spi-bfin-sport.c:834:	dev_info(dev, "%s, regs_base@%p\n", DRV_DESC, drv_data->regs);
spi-bfin-sport.c:838:	peripheral_free_list(drv_data->pin_req);
spi-bfin-sport.c:840:	free_irq(drv_data->err_irq, drv_data);
spi-bfin-sport.c:845:	iounmap(drv_data->regs);
spi-bfin-sport.c:871:	spi_unregister_master(drv_data->master);
spi-bfin-sport.c:873:	peripheral_free_list(drv_data->pin_req);
spi-bfin-sport.c:905:		dev_err(drv_data->dev, "problem resuming queue\n");
spi-adi-v3.c:19:#include <linux/dma-mapping.h>
spi-adi-v3.c:115:	ctl = ioread32(&drv_data->regs->control);
spi-adi-v3.c:117:	iowrite32(ctl, &drv_data->regs->control);
spi-adi-v3.c:124:	ctl = ioread32(&drv_data->regs->control);
spi-adi-v3.c:126:	iowrite32(ctl, &drv_data->regs->control);
spi-adi-v3.c:135:		spi_clock--;
spi-adi-v3.c:144:	while (!(ioread32(&drv_data->regs->status) & SPI_STAT_SPIF) && --limit)
spi-adi-v3.c:147:	iowrite32(0xFFFFFFFF, &drv_data->regs->status);
spi-adi-v3.c:155:	if (likely(chip->cs < MAX_CTRL_CS)) {
spi-adi-v3.c:157:		reg = ioread32(&drv_data->regs->ssel);
spi-adi-v3.c:158:		reg &= ~chip->ssel;
spi-adi-v3.c:159:		iowrite32(reg, &drv_data->regs->ssel);
spi-adi-v3.c:161:		gpio_set_value(chip->cs_gpio, 0);
spi-adi-v3.c:168:	if (likely(chip->cs < MAX_CTRL_CS)) {
spi-adi-v3.c:170:		reg = ioread32(&drv_data->regs->ssel);
spi-adi-v3.c:171:		reg |= chip->ssel;
spi-adi-v3.c:172:		iowrite32(reg, &drv_data->regs->ssel);
spi-adi-v3.c:174:		gpio_set_value(chip->cs_gpio, 1);
spi-adi-v3.c:178:	if (chip->cs_chg_udelay)
spi-adi-v3.c:179:		udelay(chip->cs_chg_udelay);
spi-adi-v3.c:186:	if (chip->cs < MAX_CTRL_CS) {
spi-adi-v3.c:188:		reg = ioread32(&drv_data->regs->ssel);
spi-adi-v3.c:189:		reg |= chip->ssel >> 8;
spi-adi-v3.c:190:		iowrite32(reg, &drv_data->regs->ssel);
spi-adi-v3.c:197:	if (chip->cs < MAX_CTRL_CS) {
spi-adi-v3.c:199:		reg = ioread32(&drv_data->regs->ssel);
spi-adi-v3.c:200:		reg &= ~(chip->ssel >> 8);
spi-adi-v3.c:201:		iowrite32(reg, &drv_data->regs->ssel);
spi-adi-v3.c:205:/* stop controller and re-config current chip*/
spi-adi-v3.c:208:	struct adi_spi_device *chip = drv_data->cur_chip;
spi-adi-v3.c:211:	iowrite32(0xFFFFFFFF, &drv_data->regs->status);
spi-adi-v3.c:212:	iowrite32(0x0, &drv_data->regs->rx_control);
spi-adi-v3.c:213:	iowrite32(0x0, &drv_data->regs->tx_control);
spi-adi-v3.c:217:	iowrite32(chip->control, &drv_data->regs->control);
spi-adi-v3.c:218:	iowrite32(chip->clock, &drv_data->regs->clock);
spi-adi-v3.c:221:	drv_data->tx_num = drv_data->rx_num = 0;
spi-adi-v3.c:223:	iowrite32(SPI_RXCTL_REN, &drv_data->regs->rx_control);
spi-adi-v3.c:224:	iowrite32(SPI_TXCTL_TEN | SPI_TXCTL_TTI, &drv_data->regs->tx_control);
spi-adi-v3.c:231:	while (!(ioread32(&drv_data->regs->status) & SPI_STAT_RFE))
spi-adi-v3.c:232:		ioread32(&drv_data->regs->rfifo);
spi-adi-v3.c:238:	while (drv_data->tx < drv_data->tx_end) {
spi-adi-v3.c:239:		iowrite32(*(u8 *)(drv_data->tx++), &drv_data->regs->tfifo);
spi-adi-v3.c:240:		while (ioread32(&drv_data->regs->status) & SPI_STAT_RFE)
spi-adi-v3.c:242:		ioread32(&drv_data->regs->rfifo);
spi-adi-v3.c:248:	u32 tx_val = drv_data->cur_chip->tx_dummy_val;
spi-adi-v3.c:251:	while (drv_data->rx < drv_data->rx_end) {
spi-adi-v3.c:252:		iowrite32(tx_val, &drv_data->regs->tfifo);
spi-adi-v3.c:253:		while (ioread32(&drv_data->regs->status) & SPI_STAT_RFE)
spi-adi-v3.c:255:		*(u8 *)(drv_data->rx++) = ioread32(&drv_data->regs->rfifo);
spi-adi-v3.c:262:	while (drv_data->rx < drv_data->rx_end) {
spi-adi-v3.c:263:		iowrite32(*(u8 *)(drv_data->tx++), &drv_data->regs->tfifo);
spi-adi-v3.c:264:		while (ioread32(&drv_data->regs->status) & SPI_STAT_RFE)
spi-adi-v3.c:266:		*(u8 *)(drv_data->rx++) = ioread32(&drv_data->regs->rfifo);
spi-adi-v3.c:279:	while (drv_data->tx < drv_data->tx_end) {
spi-adi-v3.c:280:		iowrite32(*(u16 *)drv_data->tx, &drv_data->regs->tfifo);
spi-adi-v3.c:281:		drv_data->tx += 2;
spi-adi-v3.c:282:		while (ioread32(&drv_data->regs->status) & SPI_STAT_RFE)
spi-adi-v3.c:284:		ioread32(&drv_data->regs->rfifo);
spi-adi-v3.c:290:	u32 tx_val = drv_data->cur_chip->tx_dummy_val;
spi-adi-v3.c:293:	while (drv_data->rx < drv_data->rx_end) {
spi-adi-v3.c:294:		iowrite32(tx_val, &drv_data->regs->tfifo);
spi-adi-v3.c:295:		while (ioread32(&drv_data->regs->status) & SPI_STAT_RFE)
spi-adi-v3.c:297:		*(u16 *)drv_data->rx = ioread32(&drv_data->regs->rfifo);
spi-adi-v3.c:298:		drv_data->rx += 2;
spi-adi-v3.c:305:	while (drv_data->rx < drv_data->rx_end) {
spi-adi-v3.c:306:		iowrite32(*(u16 *)drv_data->tx, &drv_data->regs->tfifo);
spi-adi-v3.c:307:		drv_data->tx += 2;
spi-adi-v3.c:308:		while (ioread32(&drv_data->regs->status) & SPI_STAT_RFE)
spi-adi-v3.c:310:		*(u16 *)drv_data->rx = ioread32(&drv_data->regs->rfifo);
spi-adi-v3.c:311:		drv_data->rx += 2;
spi-adi-v3.c:324:	while (drv_data->tx < drv_data->tx_end) {
spi-adi-v3.c:325:		iowrite32(*(u32 *)drv_data->tx, &drv_data->regs->tfifo);
spi-adi-v3.c:326:		drv_data->tx += 4;
spi-adi-v3.c:327:		while (ioread32(&drv_data->regs->status) & SPI_STAT_RFE)
spi-adi-v3.c:329:		ioread32(&drv_data->regs->rfifo);
spi-adi-v3.c:335:	u32 tx_val = drv_data->cur_chip->tx_dummy_val;
spi-adi-v3.c:338:	while (drv_data->rx < drv_data->rx_end) {
spi-adi-v3.c:339:		iowrite32(tx_val, &drv_data->regs->tfifo);
spi-adi-v3.c:340:		while (ioread32(&drv_data->regs->status) & SPI_STAT_RFE)
spi-adi-v3.c:342:		*(u32 *)drv_data->rx = ioread32(&drv_data->regs->rfifo);
spi-adi-v3.c:343:		drv_data->rx += 4;
spi-adi-v3.c:350:	while (drv_data->rx < drv_data->rx_end) {
spi-adi-v3.c:351:		iowrite32(*(u32 *)drv_data->tx, &drv_data->regs->tfifo);
spi-adi-v3.c:352:		drv_data->tx += 4;
spi-adi-v3.c:353:		while (ioread32(&drv_data->regs->status) & SPI_STAT_RFE)
spi-adi-v3.c:355:		*(u32 *)drv_data->rx = ioread32(&drv_data->regs->rfifo);
spi-adi-v3.c:356:		drv_data->rx += 4;
spi-adi-v3.c:370:	struct spi_message *msg = drv->cur_msg;
spi-adi-v3.c:371:	struct spi_transfer *t = drv->cur_transfer;
spi-adi-v3.c:374:	if (t->transfer_list.next != &msg->transfers) {
spi-adi-v3.c:375:		drv->cur_transfer = list_entry(t->transfer_list.next,
spi-adi-v3.c:377:		drv->state = RUNNING_STATE;
spi-adi-v3.c:379:		drv->state = DONE_STATE;
spi-adi-v3.c:380:		drv->cur_transfer = NULL;
spi-adi-v3.c:386:	struct adi_spi_device *chip = drv_data->cur_chip;
spi-adi-v3.c:389:	spi_finalize_current_message(drv_data->master);
spi-adi-v3.c:394:	struct spi_transfer *t = drv->cur_transfer;
spi-adi-v3.c:397:	if (t->tx_buf) {
spi-adi-v3.c:398:		drv->tx = (void *)t->tx_buf;
spi-adi-v3.c:399:		drv->tx_end = drv->tx + t->len;
spi-adi-v3.c:401:		drv->tx = NULL;
spi-adi-v3.c:404:	if (t->rx_buf) {
spi-adi-v3.c:405:		drv->rx = t->rx_buf;
spi-adi-v3.c:406:		drv->rx_end = drv->rx + t->len;
spi-adi-v3.c:408:		drv->rx = NULL;
spi-adi-v3.c:411:	drv->transfer_len = t->len;
spi-adi-v3.c:414:	switch (t->bits_per_word) {
spi-adi-v3.c:417:		drv->ops = &adi_spi_transfer_ops_u8;
spi-adi-v3.c:421:		drv->ops = &adi_spi_transfer_ops_u16;
spi-adi-v3.c:425:		drv->ops = &adi_spi_transfer_ops_u32;
spi-adi-v3.c:428:		return -EINVAL;
spi-adi-v3.c:430:	cr = ioread32(&drv->regs->control) & ~SPI_CTL_SIZE;
spi-adi-v3.c:432:	iowrite32(cr, &drv->regs->control);
spi-adi-v3.c:435:	iowrite32(hz_to_spi_clock(drv->sclk, t->speed_hz), &drv->regs->clock);
spi-adi-v3.c:441:	struct spi_transfer *t = drv_data->cur_transfer;
spi-adi-v3.c:442:	struct spi_message *msg = drv_data->cur_msg;
spi-adi-v3.c:443:	struct adi_spi_device *chip = drv_data->cur_chip;
spi-adi-v3.c:448:	switch (t->bits_per_word) {
spi-adi-v3.c:451:		word_count = drv_data->transfer_len;
spi-adi-v3.c:456:		word_count = drv_data->transfer_len / 2;
spi-adi-v3.c:461:		word_count = drv_data->transfer_len / 4;
spi-adi-v3.c:466:	if (!drv_data->rx) {
spi-adi-v3.c:467:		tx_buf = drv_data->tx;
spi-adi-v3.c:468:		rx_buf = &drv_data->dummy_buffer;
spi-adi-v3.c:469:		drv_data->tx_dma_size = drv_data->transfer_len;
spi-adi-v3.c:470:		drv_data->rx_dma_size = sizeof(drv_data->dummy_buffer);
spi-adi-v3.c:471:		set_dma_x_modify(drv_data->tx_dma, word_size);
spi-adi-v3.c:472:		set_dma_x_modify(drv_data->rx_dma, 0);
spi-adi-v3.c:473:	} else if (!drv_data->tx) {
spi-adi-v3.c:474:		drv_data->dummy_buffer = chip->tx_dummy_val;
spi-adi-v3.c:475:		tx_buf = &drv_data->dummy_buffer;
spi-adi-v3.c:476:		rx_buf = drv_data->rx;
spi-adi-v3.c:477:		drv_data->tx_dma_size = sizeof(drv_data->dummy_buffer);
spi-adi-v3.c:478:		drv_data->rx_dma_size = drv_data->transfer_len;
spi-adi-v3.c:479:		set_dma_x_modify(drv_data->tx_dma, 0);
spi-adi-v3.c:480:		set_dma_x_modify(drv_data->rx_dma, word_size);
spi-adi-v3.c:482:		tx_buf = drv_data->tx;
spi-adi-v3.c:483:		rx_buf = drv_data->rx;
spi-adi-v3.c:484:		drv_data->tx_dma_size = drv_data->rx_dma_size
spi-adi-v3.c:485:					= drv_data->transfer_len;
spi-adi-v3.c:486:		set_dma_x_modify(drv_data->tx_dma, word_size);
spi-adi-v3.c:487:		set_dma_x_modify(drv_data->rx_dma, word_size);
spi-adi-v3.c:490:	drv_data->tx_dma_addr = dma_map_single(&msg->spi->dev,
spi-adi-v3.c:492:				drv_data->tx_dma_size,
spi-adi-v3.c:494:	if (dma_mapping_error(&msg->spi->dev,
spi-adi-v3.c:495:				drv_data->tx_dma_addr))
spi-adi-v3.c:496:		return -ENOMEM;
spi-adi-v3.c:498:	drv_data->rx_dma_addr = dma_map_single(&msg->spi->dev,
spi-adi-v3.c:500:				drv_data->rx_dma_size,
spi-adi-v3.c:502:	if (dma_mapping_error(&msg->spi->dev,
spi-adi-v3.c:503:				drv_data->rx_dma_addr)) {
spi-adi-v3.c:504:		dma_unmap_single(&msg->spi->dev,
spi-adi-v3.c:505:				drv_data->tx_dma_addr,
spi-adi-v3.c:506:				drv_data->tx_dma_size,
spi-adi-v3.c:508:		return -ENOMEM;
spi-adi-v3.c:512:	set_dma_x_count(drv_data->tx_dma, word_count);
spi-adi-v3.c:513:	set_dma_x_count(drv_data->rx_dma, word_count);
spi-adi-v3.c:514:	set_dma_start_addr(drv_data->tx_dma, drv_data->tx_dma_addr);
spi-adi-v3.c:515:	set_dma_start_addr(drv_data->rx_dma, drv_data->rx_dma_addr);
spi-adi-v3.c:517:	set_dma_config(drv_data->tx_dma, dma_config);
spi-adi-v3.c:518:	set_dma_config(drv_data->rx_dma, dma_config | WNR);
spi-adi-v3.c:519:	enable_dma(drv_data->tx_dma);
spi-adi-v3.c:520:	enable_dma(drv_data->rx_dma);
spi-adi-v3.c:523:			&drv_data->regs->rx_control);
spi-adi-v3.c:525:			&drv_data->regs->tx_control);
spi-adi-v3.c:532:	struct spi_message *msg = drv_data->cur_msg;
spi-adi-v3.c:534:	if (!drv_data->rx) {
spi-adi-v3.c:536:		drv_data->ops->write(drv_data);
spi-adi-v3.c:537:		if (drv_data->tx != drv_data->tx_end)
spi-adi-v3.c:538:			return -EIO;
spi-adi-v3.c:539:	} else if (!drv_data->tx) {
spi-adi-v3.c:541:		drv_data->ops->read(drv_data);
spi-adi-v3.c:542:		if (drv_data->rx != drv_data->rx_end)
spi-adi-v3.c:543:			return -EIO;
spi-adi-v3.c:546:		drv_data->ops->duplex(drv_data);
spi-adi-v3.c:547:		if (drv_data->tx != drv_data->tx_end)
spi-adi-v3.c:548:			return -EIO;
spi-adi-v3.c:552:		return -EIO;
spi-adi-v3.c:553:	msg->actual_length += drv_data->transfer_len;
spi-adi-v3.c:554:	tasklet_schedule(&drv_data->pump_transfers);
spi-adi-v3.c:567:	msg = drv_data->cur_msg;
spi-adi-v3.c:568:	t = drv_data->cur_transfer;
spi-adi-v3.c:569:	chip = drv_data->cur_chip;
spi-adi-v3.c:572:	if (drv_data->state == ERROR_STATE) {
spi-adi-v3.c:573:		msg->status = -EIO;
spi-adi-v3.c:578:	if (drv_data->state == RUNNING_STATE) {
spi-adi-v3.c:579:		if (t->delay_usecs)
spi-adi-v3.c:580:			udelay(t->delay_usecs);
spi-adi-v3.c:581:		if (t->cs_change)
spi-adi-v3.c:584:		t = drv_data->cur_transfer;
spi-adi-v3.c:587:	if (drv_data->state == DONE_STATE) {
spi-adi-v3.c:588:		msg->status = 0;
spi-adi-v3.c:593:	if ((t->len == 0) || (t->tx_buf == NULL && t->rx_buf == NULL)) {
spi-adi-v3.c:595:		tasklet_schedule(&drv_data->pump_transfers);
spi-adi-v3.c:601:		msg->status = ret;
spi-adi-v3.c:605:	iowrite32(0xFFFFFFFF, &drv_data->regs->status);
spi-adi-v3.c:607:	drv_data->state = RUNNING_STATE;
spi-adi-v3.c:609:	if (chip->enable_dma)
spi-adi-v3.c:614:		msg->status = ret;
spi-adi-v3.c:624:	drv_data->cur_msg = m;
spi-adi-v3.c:625:	drv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);
spi-adi-v3.c:628:	drv_data->state = START_STATE;
spi-adi-v3.c:629:	drv_data->cur_transfer = list_entry(drv_data->cur_msg->transfers.next,
spi-adi-v3.c:632:	tasklet_schedule(&drv_data->pump_transfers);
spi-adi-v3.c:654:	struct adi_spi_master *drv_data = spi_master_get_devdata(spi->master);
spi-adi-v3.c:657:	int ret = -EINVAL;
spi-adi-v3.c:660:		struct adi_spi3_chip *chip_info = spi->controller_data;
spi-adi-v3.c:664:			return -ENOMEM;
spi-adi-v3.c:667:			if (chip_info->control & ~ctl_reg) {
spi-adi-v3.c:668:				dev_err(&spi->dev,
spi-adi-v3.c:672:			chip->control = chip_info->control;
spi-adi-v3.c:673:			chip->cs_chg_udelay = chip_info->cs_chg_udelay;
spi-adi-v3.c:674:			chip->tx_dummy_val = chip_info->tx_dummy_val;
spi-adi-v3.c:675:			chip->enable_dma = chip_info->enable_dma;
spi-adi-v3.c:677:		chip->cs = spi->chip_select;
spi-adi-v3.c:679:		if (chip->cs < MAX_CTRL_CS) {
spi-adi-v3.c:680:			chip->ssel = (1 << chip->cs) << 8;
spi-adi-v3.c:681:			ret = peripheral_request(ssel[spi->master->bus_num]
spi-adi-v3.c:682:					[chip->cs-1], dev_name(&spi->dev));
spi-adi-v3.c:684:				dev_err(&spi->dev, "peripheral_request() error\n");
spi-adi-v3.c:688:			chip->cs_gpio = chip->cs - MAX_CTRL_CS;
spi-adi-v3.c:689:			ret = gpio_request_one(chip->cs_gpio, GPIOF_OUT_INIT_HIGH,
spi-adi-v3.c:690:						dev_name(&spi->dev));
spi-adi-v3.c:692:				dev_err(&spi->dev, "gpio_request_one() error\n");
spi-adi-v3.c:700:	chip->control &= ctl_reg;
spi-adi-v3.c:702:	if (spi->mode & SPI_CPOL)
spi-adi-v3.c:703:		chip->control |= SPI_CTL_CPOL;
spi-adi-v3.c:704:	if (spi->mode & SPI_CPHA)
spi-adi-v3.c:705:		chip->control |= SPI_CTL_CPHA;
spi-adi-v3.c:706:	if (spi->mode & SPI_LSB_FIRST)
spi-adi-v3.c:707:		chip->control |= SPI_CTL_LSBF;
spi-adi-v3.c:708:	chip->control |= SPI_CTL_MSTR;
spi-adi-v3.c:710:	chip->control &= ~SPI_CTL_ASSEL;
spi-adi-v3.c:712:	chip->clock = hz_to_spi_clock(drv_data->sclk, spi->max_speed_hz);
spi-adi-v3.c:730:	struct adi_spi_master *drv_data = spi_master_get_devdata(spi->master);
spi-adi-v3.c:735:	if (chip->cs < MAX_CTRL_CS) {
spi-adi-v3.c:736:		peripheral_free(ssel[spi->master->bus_num]
spi-adi-v3.c:737:					[chip->cs-1]);
spi-adi-v3.c:740:		gpio_free(chip->cs_gpio);
spi-adi-v3.c:750:	u32 dma_stat = get_dma_curr_irqstat(drv_data->tx_dma);
spi-adi-v3.c:753:	clear_dma_irqstat(drv_data->tx_dma);
spi-adi-v3.c:755:		drv_data->tx_num++;
spi-adi-v3.c:757:		dev_err(&drv_data->master->dev,
spi-adi-v3.c:759:		if (drv_data->tx)
spi-adi-v3.c:760:			drv_data->state = ERROR_STATE;
spi-adi-v3.c:762:	tx_ctl = ioread32(&drv_data->regs->tx_control);
spi-adi-v3.c:764:	iowrite32(tx_ctl, &drv_data->regs->tx_control);
spi-adi-v3.c:771:	struct spi_message *msg = drv_data->cur_msg;
spi-adi-v3.c:772:	u32 dma_stat = get_dma_curr_irqstat(drv_data->rx_dma);
spi-adi-v3.c:774:	clear_dma_irqstat(drv_data->rx_dma);
spi-adi-v3.c:776:		drv_data->rx_num++;
spi-adi-v3.c:778:		if (drv_data->state != ERROR_STATE)
spi-adi-v3.c:779:			msg->actual_length += drv_data->transfer_len;
spi-adi-v3.c:781:		drv_data->state = ERROR_STATE;
spi-adi-v3.c:782:		dev_err(&drv_data->master->dev,
spi-adi-v3.c:785:	iowrite32(0, &drv_data->regs->tx_control);
spi-adi-v3.c:786:	iowrite32(0, &drv_data->regs->rx_control);
spi-adi-v3.c:787:	if (drv_data->rx_num != drv_data->tx_num)
spi-adi-v3.c:788:		dev_dbg(&drv_data->master->dev,
spi-adi-v3.c:790:				drv_data->tx_num, drv_data->rx_num);
spi-adi-v3.c:791:	tasklet_schedule(&drv_data->pump_transfers);
spi-adi-v3.c:797:	struct device *dev = &pdev->dev;
spi-adi-v3.c:808:		return -ENODEV;
spi-adi-v3.c:820:		return -ENXIO;
spi-adi-v3.c:822:	tx_dma = res->start;
spi-adi-v3.c:827:		return -ENXIO;
spi-adi-v3.c:829:	rx_dma = res->start;
spi-adi-v3.c:835:		return -ENOMEM;
spi-adi-v3.c:840:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;
spi-adi-v3.c:842:	master->bus_num = pdev->id;
spi-adi-v3.c:843:	master->num_chipselect = info->num_chipselect;
spi-adi-v3.c:844:	master->cleanup = adi_spi_cleanup;
spi-adi-v3.c:845:	master->setup = adi_spi_setup;
spi-adi-v3.c:846:	master->transfer_one_message = adi_spi_transfer_one_message;
spi-adi-v3.c:847:	master->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(16) |
spi-adi-v3.c:851:	drv_data->master = master;
spi-adi-v3.c:852:	drv_data->tx_dma = tx_dma;
spi-adi-v3.c:853:	drv_data->rx_dma = rx_dma;
spi-adi-v3.c:854:	drv_data->pin_req = info->pin_req;
spi-adi-v3.c:855:	drv_data->sclk = clk_get_rate(sclk);
spi-adi-v3.c:858:	drv_data->regs = devm_ioremap_resource(dev, mem);
spi-adi-v3.c:859:	if (IS_ERR(drv_data->regs)) {
spi-adi-v3.c:860:		ret = PTR_ERR(drv_data->regs);
spi-adi-v3.c:877:	set_dma_callback(drv_data->rx_dma, adi_spi_rx_dma_isr, drv_data);
spi-adi-v3.c:880:	ret = peripheral_request_list(drv_data->pin_req, "adi-spi3");
spi-adi-v3.c:886:	iowrite32(SPI_CTL_MSTR | SPI_CTL_CPHA, &drv_data->regs->control);
spi-adi-v3.c:887:	iowrite32(0x0000FE00, &drv_data->regs->ssel);
spi-adi-v3.c:888:	iowrite32(0x0, &drv_data->regs->delay);
spi-adi-v3.c:890:	tasklet_init(&drv_data->pump_transfers,
spi-adi-v3.c:902:	peripheral_free_list(drv_data->pin_req);
spi-adi-v3.c:919:	peripheral_free_list(drv_data->pin_req);
spi-adi-v3.c:920:	free_dma(drv_data->rx_dma);
spi-adi-v3.c:921:	free_dma(drv_data->tx_dma);
spi-adi-v3.c:933:	drv_data->control = ioread32(&drv_data->regs->control);
spi-adi-v3.c:934:	drv_data->ssel = ioread32(&drv_data->regs->ssel);
spi-adi-v3.c:936:	iowrite32(SPI_CTL_MSTR | SPI_CTL_CPHA, &drv_data->regs->control);
spi-adi-v3.c:937:	iowrite32(0x0000FE00, &drv_data->regs->ssel);
spi-adi-v3.c:938:	dma_disable_irq(drv_data->rx_dma);
spi-adi-v3.c:939:	dma_disable_irq(drv_data->tx_dma);
spi-adi-v3.c:951:	disable_dma(drv_data->rx_dma);
spi-adi-v3.c:953:	dma_enable_irq(drv_data->rx_dma);
spi-adi-v3.c:954:	dma_enable_irq(drv_data->tx_dma);
spi-adi-v3.c:955:	iowrite32(drv_data->control, &drv_data->regs->control);
spi-adi-v3.c:956:	iowrite32(drv_data->ssel, &drv_data->regs->ssel);
spi-adi-v3.c:960:		free_dma(drv_data->rx_dma);
spi-adi-v3.c:961:		free_dma(drv_data->tx_dma);
spi-adi-v3.c:971:MODULE_ALIAS("platform:adi-spi3");
spi-adi-v3.c:974:		.name	= "adi-spi3",
spi-altera.c:66:	return spi_master_get_devdata(sdev->master);
spi-altera.c:73:	if (spi->mode & SPI_CS_HIGH) {
spi-altera.c:76:			writel(1 << spi->chip_select,
spi-altera.c:77:			       hw->base + ALTERA_SPI_SLAVE_SEL);
spi-altera.c:78:			hw->imr |= ALTERA_SPI_CONTROL_SSO_MSK;
spi-altera.c:79:			writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
spi-altera.c:83:			hw->imr &= ~ALTERA_SPI_CONTROL_SSO_MSK;
spi-altera.c:84:			writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
spi-altera.c:85:			writel(0, hw->base + ALTERA_SPI_SLAVE_SEL);
spi-altera.c:91:			hw->imr &= ~ALTERA_SPI_CONTROL_SSO_MSK;
spi-altera.c:92:			writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
spi-altera.c:96:			writel(1 << spi->chip_select,
spi-altera.c:97:			       hw->base + ALTERA_SPI_SLAVE_SEL);
spi-altera.c:98:			hw->imr |= ALTERA_SPI_CONTROL_SSO_MSK;
spi-altera.c:99:			writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
spi-altera.c:107:	if (hw->tx) {
spi-altera.c:108:		switch (hw->bytes_per_word) {
spi-altera.c:110:			return hw->tx[count];
spi-altera.c:112:			return (hw->tx[count * 2]
spi-altera.c:113:				| (hw->tx[count * 2 + 1] << 8));
spi-altera.c:123:	hw->tx = t->tx_buf;
spi-altera.c:124:	hw->rx = t->rx_buf;
spi-altera.c:125:	hw->count = 0;
spi-altera.c:126:	hw->bytes_per_word = DIV_ROUND_UP(t->bits_per_word, 8);
spi-altera.c:127:	hw->len = t->len / hw->bytes_per_word;
spi-altera.c:129:	if (hw->irq >= 0) {
spi-altera.c:131:		hw->imr |= ALTERA_SPI_CONTROL_IRRDY_MSK;
spi-altera.c:132:		writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
spi-altera.c:135:		writel(hw_txbyte(hw, 0), hw->base + ALTERA_SPI_TXDATA);
spi-altera.c:137:		wait_for_completion(&hw->done);
spi-altera.c:139:		hw->imr &= ~ALTERA_SPI_CONTROL_IRRDY_MSK;
spi-altera.c:140:		writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
spi-altera.c:142:		while (hw->count < hw->len) {
spi-altera.c:145:			writel(hw_txbyte(hw, hw->count),
spi-altera.c:146:			       hw->base + ALTERA_SPI_TXDATA);
spi-altera.c:148:			while (!(readl(hw->base + ALTERA_SPI_STATUS) &
spi-altera.c:152:			rxd = readl(hw->base + ALTERA_SPI_RXDATA);
spi-altera.c:153:			if (hw->rx) {
spi-altera.c:154:				switch (hw->bytes_per_word) {
spi-altera.c:156:					hw->rx[hw->count] = rxd;
spi-altera.c:159:					hw->rx[hw->count * 2] = rxd;
spi-altera.c:160:					hw->rx[hw->count * 2 + 1] = rxd >> 8;
spi-altera.c:165:			hw->count++;
spi-altera.c:169:	return hw->count * hw->bytes_per_word;
spi-altera.c:177:	rxd = readl(hw->base + ALTERA_SPI_RXDATA);
spi-altera.c:178:	if (hw->rx) {
spi-altera.c:179:		switch (hw->bytes_per_word) {
spi-altera.c:181:			hw->rx[hw->count] = rxd;
spi-altera.c:184:			hw->rx[hw->count * 2] = rxd;
spi-altera.c:185:			hw->rx[hw->count * 2 + 1] = rxd >> 8;
spi-altera.c:190:	hw->count++;
spi-altera.c:192:	if (hw->count < hw->len)
spi-altera.c:193:		writel(hw_txbyte(hw, hw->count), hw->base + ALTERA_SPI_TXDATA);
spi-altera.c:195:		complete(&hw->done);
spi-altera.c:205:	int err = -ENODEV;
spi-altera.c:207:	master = spi_alloc_master(&pdev->dev, sizeof(struct altera_spi));
spi-altera.c:212:	master->bus_num = pdev->id;
spi-altera.c:213:	master->num_chipselect = 16;
spi-altera.c:214:	master->mode_bits = SPI_CS_HIGH;
spi-altera.c:215:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 16);
spi-altera.c:216:	master->dev.of_node = pdev->dev.of_node;
spi-altera.c:222:	hw->bitbang.master = master;
spi-altera.c:223:	hw->bitbang.chipselect = altera_spi_chipsel;
spi-altera.c:224:	hw->bitbang.txrx_bufs = altera_spi_txrx;
spi-altera.c:228:	hw->base = devm_ioremap_resource(&pdev->dev, res);
spi-altera.c:229:	if (IS_ERR(hw->base)) {
spi-altera.c:230:		err = PTR_ERR(hw->base);
spi-altera.c:234:	hw->imr = 0;		/* disable spi interrupts */
spi-altera.c:235:	writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
spi-altera.c:236:	writel(0, hw->base + ALTERA_SPI_STATUS);	/* clear status reg */
spi-altera.c:237:	if (readl(hw->base + ALTERA_SPI_STATUS) & ALTERA_SPI_STATUS_RRDY_MSK)
spi-altera.c:238:		readl(hw->base + ALTERA_SPI_RXDATA);	/* flush rxdata */
spi-altera.c:240:	hw->irq = platform_get_irq(pdev, 0);
spi-altera.c:241:	if (hw->irq >= 0) {
spi-altera.c:242:		init_completion(&hw->done);
spi-altera.c:243:		err = devm_request_irq(&pdev->dev, hw->irq, altera_spi_irq, 0,
spi-altera.c:244:				       pdev->name, hw);
spi-altera.c:250:	err = spi_bitbang_start(&hw->bitbang);
spi-altera.c:253:	dev_info(&pdev->dev, "base %p, irq %d\n", hw->base, hw->irq);
spi-altera.c:264:	struct spi_master *master = hw->bitbang.master;
spi-altera.c:266:	spi_bitbang_stop(&hw->bitbang);
spi-altera.c:273:	{ .compatible = "ALTR,spi-1.0", },
spi-altera.c:274:	{ .compatible = "altr,spi-1.0", },
spi-omap2-mcspi.c:24:#include <linux/dma-mapping.h>
spi-omap2-mcspi.c:26:#include <linux/omap-dma.h>
spi-omap2-mcspi.c:40:#include <linux/platform_data/spi-omap2-mcspi.h>
spi-omap2-mcspi.c:57:/* per-channel banks, 0x14 bytes each, first is: */
spi-omap2-mcspi.c:64:/* per-register bitmasks: */
spi-omap2-mcspi.c:159:	writel_relaxed(val, mcspi->base + idx);
spi-omap2-mcspi.c:166:	return readl_relaxed(mcspi->base + idx);
spi-omap2-mcspi.c:172:	struct omap2_mcspi_cs	*cs = spi->controller_state;
spi-omap2-mcspi.c:174:	writel_relaxed(val, cs->base +  idx);
spi-omap2-mcspi.c:179:	struct omap2_mcspi_cs	*cs = spi->controller_state;
spi-omap2-mcspi.c:181:	return readl_relaxed(cs->base + idx);
spi-omap2-mcspi.c:186:	struct omap2_mcspi_cs *cs = spi->controller_state;
spi-omap2-mcspi.c:188:	return cs->chconf0;
spi-omap2-mcspi.c:193:	struct omap2_mcspi_cs *cs = spi->controller_state;
spi-omap2-mcspi.c:195:	cs->chconf0 = val;
spi-omap2-mcspi.c:232:	struct omap2_mcspi_cs *cs = spi->controller_state;
spi-omap2-mcspi.c:235:	l = cs->chctrl0;
spi-omap2-mcspi.c:240:	cs->chctrl0 = l;
spi-omap2-mcspi.c:241:	mcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCTRL0, cs->chctrl0);
spi-omap2-mcspi.c:242:	/* Flash post-writes */
spi-omap2-mcspi.c:248:	struct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);
spi-omap2-mcspi.c:255:	if (spi->mode & SPI_CS_HIGH)
spi-omap2-mcspi.c:258:	if (spi->controller_state) {
spi-omap2-mcspi.c:259:		int err = pm_runtime_get_sync(mcspi->dev);
spi-omap2-mcspi.c:261:			dev_err(mcspi->dev, "failed to get sync: %d\n", err);
spi-omap2-mcspi.c:274:		pm_runtime_mark_last_busy(mcspi->dev);
spi-omap2-mcspi.c:275:		pm_runtime_put_autosuspend(mcspi->dev);
spi-omap2-mcspi.c:282:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
spi-omap2-mcspi.c:287:	 * to single-channel master mode
spi-omap2-mcspi.c:294:	ctx->modulctrl = l;
spi-omap2-mcspi.c:300:	struct spi_master *master = spi->master;
spi-omap2-mcspi.c:301:	struct omap2_mcspi_cs *cs = spi->controller_state;
spi-omap2-mcspi.c:311:		bytes_per_word = mcspi_bytes_per_word(cs->word_len);
spi-omap2-mcspi.c:312:		if (t->len % bytes_per_word != 0)
spi-omap2-mcspi.c:315:		if (t->rx_buf != NULL && t->tx_buf != NULL)
spi-omap2-mcspi.c:320:		fifo_depth = gcd(t->len, max_fifo_depth);
spi-omap2-mcspi.c:324:		wcnt = t->len / bytes_per_word;
spi-omap2-mcspi.c:329:		if (t->rx_buf != NULL) {
spi-omap2-mcspi.c:331:			xferlevel |= (fifo_depth - 1) << 8;
spi-omap2-mcspi.c:333:		if (t->tx_buf != NULL) {
spi-omap2-mcspi.c:335:			xferlevel |= fifo_depth - 1;
spi-omap2-mcspi.c:340:		mcspi->fifo_depth = fifo_depth;
spi-omap2-mcspi.c:346:	if (t->rx_buf != NULL)
spi-omap2-mcspi.c:349:	if (t->tx_buf != NULL)
spi-omap2-mcspi.c:353:	mcspi->fifo_depth = 0;
spi-omap2-mcspi.c:358:	struct spi_master	*spi_cntrl = mcspi->master;
spi-omap2-mcspi.c:359:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
spi-omap2-mcspi.c:363:	mcspi_write_reg(spi_cntrl, OMAP2_MCSPI_MODULCTRL, ctx->modulctrl);
spi-omap2-mcspi.c:364:	mcspi_write_reg(spi_cntrl, OMAP2_MCSPI_WAKEUPENABLE, ctx->wakeupenable);
spi-omap2-mcspi.c:366:	list_for_each_entry(cs, &ctx->cs, node)
spi-omap2-mcspi.c:367:		writel_relaxed(cs->chconf0, cs->base + OMAP2_MCSPI_CHCONF0);
spi-omap2-mcspi.c:378:				return -ETIMEDOUT;
spi-omap2-mcspi.c:390:	struct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);
spi-omap2-mcspi.c:391:	struct omap2_mcspi_dma *mcspi_dma = &mcspi->dma_channels[spi->chip_select];
spi-omap2-mcspi.c:396:	complete(&mcspi_dma->dma_rx_completion);
spi-omap2-mcspi.c:402:	struct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);
spi-omap2-mcspi.c:403:	struct omap2_mcspi_dma *mcspi_dma = &mcspi->dma_channels[spi->chip_select];
spi-omap2-mcspi.c:408:	complete(&mcspi_dma->dma_tx_completion);
spi-omap2-mcspi.c:419:	mcspi = spi_master_get_devdata(spi->master);
spi-omap2-mcspi.c:420:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
spi-omap2-mcspi.c:421:	count = xfer->len;
spi-omap2-mcspi.c:423:	if (mcspi_dma->dma_tx) {
spi-omap2-mcspi.c:427:		dmaengine_slave_config(mcspi_dma->dma_tx, &cfg);
spi-omap2-mcspi.c:430:		sg_dma_address(&sg) = xfer->tx_dma;
spi-omap2-mcspi.c:431:		sg_dma_len(&sg) = xfer->len;
spi-omap2-mcspi.c:433:		tx = dmaengine_prep_slave_sg(mcspi_dma->dma_tx, &sg, 1,
spi-omap2-mcspi.c:436:			tx->callback = omap2_mcspi_tx_callback;
spi-omap2-mcspi.c:437:			tx->callback_param = spi;
spi-omap2-mcspi.c:443:	dma_async_issue_pending(mcspi_dma->dma_tx);
spi-omap2-mcspi.c:459:	struct omap2_mcspi_cs	*cs = spi->controller_state;
spi-omap2-mcspi.c:460:	void __iomem		*chstat_reg = cs->base + OMAP2_MCSPI_CHSTAT0;
spi-omap2-mcspi.c:462:	mcspi = spi_master_get_devdata(spi->master);
spi-omap2-mcspi.c:463:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
spi-omap2-mcspi.c:464:	count = xfer->len;
spi-omap2-mcspi.c:465:	dma_count = xfer->len;
spi-omap2-mcspi.c:467:	if (mcspi->fifo_depth == 0)
spi-omap2-mcspi.c:468:		dma_count -= es;
spi-omap2-mcspi.c:470:	word_len = cs->word_len;
spi-omap2-mcspi.c:480:	if (mcspi_dma->dma_rx) {
spi-omap2-mcspi.c:484:		dmaengine_slave_config(mcspi_dma->dma_rx, &cfg);
spi-omap2-mcspi.c:486:		if ((l & OMAP2_MCSPI_CHCONF_TURBO) && mcspi->fifo_depth == 0)
spi-omap2-mcspi.c:487:			dma_count -= es;
spi-omap2-mcspi.c:490:		sg_dma_address(&sg) = xfer->rx_dma;
spi-omap2-mcspi.c:493:		tx = dmaengine_prep_slave_sg(mcspi_dma->dma_rx, &sg, 1,
spi-omap2-mcspi.c:497:			tx->callback = omap2_mcspi_rx_callback;
spi-omap2-mcspi.c:498:			tx->callback_param = spi;
spi-omap2-mcspi.c:505:	dma_async_issue_pending(mcspi_dma->dma_rx);
spi-omap2-mcspi.c:508:	wait_for_completion(&mcspi_dma->dma_rx_completion);
spi-omap2-mcspi.c:509:	dma_unmap_single(mcspi->dev, xfer->rx_dma, count,
spi-omap2-mcspi.c:512:	if (mcspi->fifo_depth > 0)
spi-omap2-mcspi.c:517:	elements = element_count - 1;
spi-omap2-mcspi.c:520:		elements--;
spi-omap2-mcspi.c:528:				((u8 *)xfer->rx_buf)[elements++] = w;
spi-omap2-mcspi.c:530:				((u16 *)xfer->rx_buf)[elements++] = w;
spi-omap2-mcspi.c:532:				((u32 *)xfer->rx_buf)[elements++] = w;
spi-omap2-mcspi.c:535:			dev_err(&spi->dev, "DMA RX penultimate word empty\n");
spi-omap2-mcspi.c:536:			count -= (bytes_per_word << 1);
spi-omap2-mcspi.c:546:			((u8 *)xfer->rx_buf)[elements] = w;
spi-omap2-mcspi.c:548:			((u16 *)xfer->rx_buf)[elements] = w;
spi-omap2-mcspi.c:550:			((u32 *)xfer->rx_buf)[elements] = w;
spi-omap2-mcspi.c:552:		dev_err(&spi->dev, "DMA RX last word empty\n");
spi-omap2-mcspi.c:553:		count -= mcspi_bytes_per_word(word_len);
spi-omap2-mcspi.c:563:	struct omap2_mcspi_cs	*cs = spi->controller_state;
spi-omap2-mcspi.c:577:	mcspi = spi_master_get_devdata(spi->master);
spi-omap2-mcspi.c:578:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
spi-omap2-mcspi.c:582:	if (cs->word_len <= 8) {
spi-omap2-mcspi.c:585:	} else if (cs->word_len <= 16) {
spi-omap2-mcspi.c:593:	count = xfer->len;
spi-omap2-mcspi.c:596:	if (mcspi->fifo_depth > 0) {
spi-omap2-mcspi.c:597:		if (count > mcspi->fifo_depth)
spi-omap2-mcspi.c:598:			burst = mcspi->fifo_depth / es;
spi-omap2-mcspi.c:604:	cfg.src_addr = cs->phys + OMAP2_MCSPI_RX0;
spi-omap2-mcspi.c:605:	cfg.dst_addr = cs->phys + OMAP2_MCSPI_TX0;
spi-omap2-mcspi.c:611:	rx = xfer->rx_buf;
spi-omap2-mcspi.c:612:	tx = xfer->tx_buf;
spi-omap2-mcspi.c:621:		wait_for_completion(&mcspi_dma->dma_tx_completion);
spi-omap2-mcspi.c:622:		dma_unmap_single(mcspi->dev, xfer->tx_dma, xfer->len,
spi-omap2-mcspi.c:625:		if (mcspi->fifo_depth > 0) {
spi-omap2-mcspi.c:626:			irqstat_reg = mcspi->base + OMAP2_MCSPI_IRQSTATUS;
spi-omap2-mcspi.c:630:				dev_err(&spi->dev, "EOW timed out\n");
spi-omap2-mcspi.c:632:			mcspi_write_reg(mcspi->master, OMAP2_MCSPI_IRQSTATUS,
spi-omap2-mcspi.c:638:			chstat_reg = cs->base + OMAP2_MCSPI_CHSTAT0;
spi-omap2-mcspi.c:639:			if (mcspi->fifo_depth > 0) {
spi-omap2-mcspi.c:643:					dev_err(&spi->dev, "TXFFE timed out\n");
spi-omap2-mcspi.c:648:					dev_err(&spi->dev, "TXS timed out\n");
spi-omap2-mcspi.c:653:				dev_err(&spi->dev, "EOT timed out\n");
spi-omap2-mcspi.c:663:	struct omap2_mcspi_cs	*cs = spi->controller_state;
spi-omap2-mcspi.c:666:	void __iomem		*base = cs->base;
spi-omap2-mcspi.c:672:	mcspi = spi_master_get_devdata(spi->master);
spi-omap2-mcspi.c:673:	count = xfer->len;
spi-omap2-mcspi.c:675:	word_len = cs->word_len;
spi-omap2-mcspi.c:679:	/* We store the pre-calculated register addresses on stack to speed
spi-omap2-mcspi.c:692:		rx = xfer->rx_buf;
spi-omap2-mcspi.c:693:		tx = xfer->tx_buf;
spi-omap2-mcspi.c:696:			c -= 1;
spi-omap2-mcspi.c:700:					dev_err(&spi->dev, "TXS timed out\n");
spi-omap2-mcspi.c:703:				dev_vdbg(&spi->dev, "write-%d %02x\n",
spi-omap2-mcspi.c:710:					dev_err(&spi->dev, "RXS timed out\n");
spi-omap2-mcspi.c:718:					dev_vdbg(&spi->dev, "read-%d %02x\n",
spi-omap2-mcspi.c:719:						    word_len, *(rx - 1));
spi-omap2-mcspi.c:722:						dev_err(&spi->dev,
spi-omap2-mcspi.c:732:				dev_vdbg(&spi->dev, "read-%d %02x\n",
spi-omap2-mcspi.c:733:						word_len, *(rx - 1));
spi-omap2-mcspi.c:740:		rx = xfer->rx_buf;
spi-omap2-mcspi.c:741:		tx = xfer->tx_buf;
spi-omap2-mcspi.c:743:			c -= 2;
spi-omap2-mcspi.c:747:					dev_err(&spi->dev, "TXS timed out\n");
spi-omap2-mcspi.c:750:				dev_vdbg(&spi->dev, "write-%d %04x\n",
spi-omap2-mcspi.c:757:					dev_err(&spi->dev, "RXS timed out\n");
spi-omap2-mcspi.c:765:					dev_vdbg(&spi->dev, "read-%d %04x\n",
spi-omap2-mcspi.c:766:						    word_len, *(rx - 1));
spi-omap2-mcspi.c:769:						dev_err(&spi->dev,
spi-omap2-mcspi.c:779:				dev_vdbg(&spi->dev, "read-%d %04x\n",
spi-omap2-mcspi.c:780:						word_len, *(rx - 1));
spi-omap2-mcspi.c:787:		rx = xfer->rx_buf;
spi-omap2-mcspi.c:788:		tx = xfer->tx_buf;
spi-omap2-mcspi.c:790:			c -= 4;
spi-omap2-mcspi.c:794:					dev_err(&spi->dev, "TXS timed out\n");
spi-omap2-mcspi.c:797:				dev_vdbg(&spi->dev, "write-%d %08x\n",
spi-omap2-mcspi.c:804:					dev_err(&spi->dev, "RXS timed out\n");
spi-omap2-mcspi.c:812:					dev_vdbg(&spi->dev, "read-%d %08x\n",
spi-omap2-mcspi.c:813:						    word_len, *(rx - 1));
spi-omap2-mcspi.c:816:						dev_err(&spi->dev,
spi-omap2-mcspi.c:826:				dev_vdbg(&spi->dev, "read-%d %08x\n",
spi-omap2-mcspi.c:827:						word_len, *(rx - 1));
spi-omap2-mcspi.c:833:	if (xfer->rx_buf == NULL) {
spi-omap2-mcspi.c:836:			dev_err(&spi->dev, "TXS timed out\n");
spi-omap2-mcspi.c:839:			dev_err(&spi->dev, "EOT timed out\n");
spi-omap2-mcspi.c:849:	return count - c;
spi-omap2-mcspi.c:867:	struct omap2_mcspi_cs *cs = spi->controller_state;
spi-omap2-mcspi.c:871:	u8 word_len = spi->bits_per_word;
spi-omap2-mcspi.c:872:	u32 speed_hz = spi->max_speed_hz;
spi-omap2-mcspi.c:874:	mcspi = spi_master_get_devdata(spi->master);
spi-omap2-mcspi.c:875:	spi_cntrl = mcspi->master;
spi-omap2-mcspi.c:877:	if (t != NULL && t->bits_per_word)
spi-omap2-mcspi.c:878:		word_len = t->bits_per_word;
spi-omap2-mcspi.c:880:	cs->word_len = word_len;
spi-omap2-mcspi.c:882:	if (t && t->speed_hz)
spi-omap2-mcspi.c:883:		speed_hz = t->speed_hz;
spi-omap2-mcspi.c:891:		div = (OMAP2_MCSPI_MAX_FREQ + speed_hz - 1) / speed_hz;
spi-omap2-mcspi.c:893:		clkd = (div - 1) & 0xf;
spi-omap2-mcspi.c:894:		extclk = (div - 1) >> 4;
spi-omap2-mcspi.c:900:	/* standard 4-wire master mode:  SCK, MOSI/out, MISO/in, nCS
spi-omap2-mcspi.c:903:	if (mcspi->pin_dir == MCSPI_PINDIR_D0_IN_D1_OUT) {
spi-omap2-mcspi.c:915:	l |= (word_len - 1) << 7;
spi-omap2-mcspi.c:918:	if (!(spi->mode & SPI_CS_HIGH))
spi-omap2-mcspi.c:919:		l |= OMAP2_MCSPI_CHCONF_EPOL;	/* active-low; normal */
spi-omap2-mcspi.c:931:		cs->chctrl0 &= ~OMAP2_MCSPI_CHCTRL_EXTCLK_MASK;
spi-omap2-mcspi.c:932:		cs->chctrl0 |= extclk << 8;
spi-omap2-mcspi.c:933:		mcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCTRL0, cs->chctrl0);
spi-omap2-mcspi.c:937:	if (spi->mode & SPI_CPOL)
spi-omap2-mcspi.c:941:	if (spi->mode & SPI_CPHA)
spi-omap2-mcspi.c:948:	cs->mode = spi->mode;
spi-omap2-mcspi.c:950:	dev_dbg(&spi->dev, "setup: speed %d, sample %s edge, clk %s\n",
spi-omap2-mcspi.c:952:			(spi->mode & SPI_CPHA) ? "trailing" : "leading",
spi-omap2-mcspi.c:953:			(spi->mode & SPI_CPOL) ? "inverted" : "normal");
spi-omap2-mcspi.c:964:	struct spi_master	*master = spi->master;
spi-omap2-mcspi.c:971:	mcspi_dma = mcspi->dma_channels + spi->chip_select;
spi-omap2-mcspi.c:973:	init_completion(&mcspi_dma->dma_rx_completion);
spi-omap2-mcspi.c:974:	init_completion(&mcspi_dma->dma_tx_completion);
spi-omap2-mcspi.c:978:	sig = mcspi_dma->dma_rx_sync_dev;
spi-omap2-mcspi.c:980:	mcspi_dma->dma_rx =
spi-omap2-mcspi.c:982:						 &sig, &master->dev,
spi-omap2-mcspi.c:983:						 mcspi_dma->dma_rx_ch_name);
spi-omap2-mcspi.c:984:	if (!mcspi_dma->dma_rx)
spi-omap2-mcspi.c:987:	sig = mcspi_dma->dma_tx_sync_dev;
spi-omap2-mcspi.c:988:	mcspi_dma->dma_tx =
spi-omap2-mcspi.c:990:						 &sig, &master->dev,
spi-omap2-mcspi.c:991:						 mcspi_dma->dma_tx_ch_name);
spi-omap2-mcspi.c:993:	if (!mcspi_dma->dma_tx) {
spi-omap2-mcspi.c:994:		dma_release_channel(mcspi_dma->dma_rx);
spi-omap2-mcspi.c:995:		mcspi_dma->dma_rx = NULL;
spi-omap2-mcspi.c:1002:	dev_warn(&spi->dev, "not using DMA for McSPI\n");
spi-omap2-mcspi.c:1003:	return -EAGAIN;
spi-omap2-mcspi.c:1009:	struct omap2_mcspi	*mcspi = spi_master_get_devdata(spi->master);
spi-omap2-mcspi.c:1010:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
spi-omap2-mcspi.c:1012:	struct omap2_mcspi_cs	*cs = spi->controller_state;
spi-omap2-mcspi.c:1014:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
spi-omap2-mcspi.c:1019:			return -ENOMEM;
spi-omap2-mcspi.c:1020:		cs->base = mcspi->base + spi->chip_select * 0x14;
spi-omap2-mcspi.c:1021:		cs->phys = mcspi->phys + spi->chip_select * 0x14;
spi-omap2-mcspi.c:1022:		cs->mode = 0;
spi-omap2-mcspi.c:1023:		cs->chconf0 = 0;
spi-omap2-mcspi.c:1024:		cs->chctrl0 = 0;
spi-omap2-mcspi.c:1025:		spi->controller_state = cs;
spi-omap2-mcspi.c:1027:		list_add_tail(&cs->node, &ctx->cs);
spi-omap2-mcspi.c:1029:		if (gpio_is_valid(spi->cs_gpio)) {
spi-omap2-mcspi.c:1030:			ret = gpio_request(spi->cs_gpio, dev_name(&spi->dev));
spi-omap2-mcspi.c:1032:				dev_err(&spi->dev, "failed to request gpio\n");
spi-omap2-mcspi.c:1035:			gpio_direction_output(spi->cs_gpio,
spi-omap2-mcspi.c:1036:					 !(spi->mode & SPI_CS_HIGH));
spi-omap2-mcspi.c:1040:	if (!mcspi_dma->dma_rx || !mcspi_dma->dma_tx) {
spi-omap2-mcspi.c:1042:		if (ret < 0 && ret != -EAGAIN)
spi-omap2-mcspi.c:1046:	ret = pm_runtime_get_sync(mcspi->dev);
spi-omap2-mcspi.c:1051:	pm_runtime_mark_last_busy(mcspi->dev);
spi-omap2-mcspi.c:1052:	pm_runtime_put_autosuspend(mcspi->dev);
spi-omap2-mcspi.c:1063:	mcspi = spi_master_get_devdata(spi->master);
spi-omap2-mcspi.c:1065:	if (spi->controller_state) {
spi-omap2-mcspi.c:1067:		cs = spi->controller_state;
spi-omap2-mcspi.c:1068:		list_del(&cs->node);
spi-omap2-mcspi.c:1073:	if (spi->chip_select < spi->master->num_chipselect) {
spi-omap2-mcspi.c:1074:		mcspi_dma = &mcspi->dma_channels[spi->chip_select];
spi-omap2-mcspi.c:1076:		if (mcspi_dma->dma_rx) {
spi-omap2-mcspi.c:1077:			dma_release_channel(mcspi_dma->dma_rx);
spi-omap2-mcspi.c:1078:			mcspi_dma->dma_rx = NULL;
spi-omap2-mcspi.c:1080:		if (mcspi_dma->dma_tx) {
spi-omap2-mcspi.c:1081:			dma_release_channel(mcspi_dma->dma_tx);
spi-omap2-mcspi.c:1082:			mcspi_dma->dma_tx = NULL;
spi-omap2-mcspi.c:1086:	if (gpio_is_valid(spi->cs_gpio))
spi-omap2-mcspi.c:1087:		gpio_free(spi->cs_gpio);
spi-omap2-mcspi.c:1094:	/* We only enable one channel at a time -- the one whose message is
spi-omap2-mcspi.c:1095:	 * -- although this controller would gladly
spi-omap2-mcspi.c:1109:	master = spi->master;
spi-omap2-mcspi.c:1110:	mcspi_dma = mcspi->dma_channels + spi->chip_select;
spi-omap2-mcspi.c:1111:	cs = spi->controller_state;
spi-omap2-mcspi.c:1112:	cd = spi->controller_data;
spi-omap2-mcspi.c:1115:	 * The slave driver could have changed spi->mode in which case
spi-omap2-mcspi.c:1116:	 * it will be different from cs->mode (the current hardware setup).
spi-omap2-mcspi.c:1121:	if (spi->mode != cs->mode)
spi-omap2-mcspi.c:1126:	if (gpio_is_valid(spi->cs_gpio))
spi-omap2-mcspi.c:1127:		omap2_mcspi_set_cs(spi, spi->mode & SPI_CS_HIGH);
spi-omap2-mcspi.c:1130:	    (t->speed_hz != spi->max_speed_hz) ||
spi-omap2-mcspi.c:1131:	    (t->bits_per_word != spi->bits_per_word)) {
spi-omap2-mcspi.c:1136:		if (t->speed_hz == spi->max_speed_hz &&
spi-omap2-mcspi.c:1137:		    t->bits_per_word == spi->bits_per_word)
spi-omap2-mcspi.c:1140:	if (cd && cd->cs_per_word) {
spi-omap2-mcspi.c:1141:		chconf = mcspi->ctx.modulctrl;
spi-omap2-mcspi.c:1144:		mcspi->ctx.modulctrl =
spi-omap2-mcspi.c:1152:	if (t->tx_buf == NULL)
spi-omap2-mcspi.c:1154:	else if (t->rx_buf == NULL)
spi-omap2-mcspi.c:1157:	if (cd && cd->turbo_mode && t->tx_buf == NULL) {
spi-omap2-mcspi.c:1159:		if (t->len > ((cs->word_len + 7) >> 3))
spi-omap2-mcspi.c:1165:	if (t->len) {
spi-omap2-mcspi.c:1168:		if ((mcspi_dma->dma_rx && mcspi_dma->dma_tx) &&
spi-omap2-mcspi.c:1169:		    (t->len >= DMA_MIN_BYTES))
spi-omap2-mcspi.c:1175:		if (t->tx_buf == NULL)
spi-omap2-mcspi.c:1176:			writel_relaxed(0, cs->base
spi-omap2-mcspi.c:1179:		if ((mcspi_dma->dma_rx && mcspi_dma->dma_tx) &&
spi-omap2-mcspi.c:1180:		    (t->len >= DMA_MIN_BYTES))
spi-omap2-mcspi.c:1185:		if (count != t->len) {
spi-omap2-mcspi.c:1186:			status = -EIO;
spi-omap2-mcspi.c:1193:	if (mcspi->fifo_depth > 0)
spi-omap2-mcspi.c:1203:	if (cd && cd->cs_per_word) {
spi-omap2-mcspi.c:1204:		chconf = mcspi->ctx.modulctrl;
spi-omap2-mcspi.c:1207:		mcspi->ctx.modulctrl =
spi-omap2-mcspi.c:1213:	if (gpio_is_valid(spi->cs_gpio))
spi-omap2-mcspi.c:1214:		omap2_mcspi_set_cs(spi, !(spi->mode & SPI_CS_HIGH));
spi-omap2-mcspi.c:1216:	if (mcspi->fifo_depth > 0 && t)
spi-omap2-mcspi.c:1226:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
spi-omap2-mcspi.c:1234:	list_for_each_entry(cs, &ctx->cs, node) {
spi-omap2-mcspi.c:1235:		if (msg->spi->controller_state == cs)
spi-omap2-mcspi.c:1238:		if ((cs->chconf0 & OMAP2_MCSPI_CHCONF_FORCE)) {
spi-omap2-mcspi.c:1239:			cs->chconf0 &= ~OMAP2_MCSPI_CHCONF_FORCE;
spi-omap2-mcspi.c:1240:			writel_relaxed(cs->chconf0,
spi-omap2-mcspi.c:1241:					cs->base + OMAP2_MCSPI_CHCONF0);
spi-omap2-mcspi.c:1242:			readl_relaxed(cs->base + OMAP2_MCSPI_CHCONF0);
spi-omap2-mcspi.c:1254:	const void	*tx_buf = t->tx_buf;
spi-omap2-mcspi.c:1255:	void		*rx_buf = t->rx_buf;
spi-omap2-mcspi.c:1256:	unsigned	len = t->len;
spi-omap2-mcspi.c:1259:	mcspi_dma = mcspi->dma_channels + spi->chip_select;
spi-omap2-mcspi.c:1262:		dev_dbg(mcspi->dev, "transfer: %d Hz, %d %s%s, %d bpw\n",
spi-omap2-mcspi.c:1263:				t->speed_hz,
spi-omap2-mcspi.c:1267:				t->bits_per_word);
spi-omap2-mcspi.c:1268:		return -EINVAL;
spi-omap2-mcspi.c:1274:	if (mcspi_dma->dma_tx && tx_buf != NULL) {
spi-omap2-mcspi.c:1275:		t->tx_dma = dma_map_single(mcspi->dev, (void *) tx_buf,
spi-omap2-mcspi.c:1277:		if (dma_mapping_error(mcspi->dev, t->tx_dma)) {
spi-omap2-mcspi.c:1278:			dev_dbg(mcspi->dev, "dma %cX %d bytes error\n",
spi-omap2-mcspi.c:1280:			return -EINVAL;
spi-omap2-mcspi.c:1283:	if (mcspi_dma->dma_rx && rx_buf != NULL) {
spi-omap2-mcspi.c:1284:		t->rx_dma = dma_map_single(mcspi->dev, rx_buf, t->len,
spi-omap2-mcspi.c:1286:		if (dma_mapping_error(mcspi->dev, t->rx_dma)) {
spi-omap2-mcspi.c:1287:			dev_dbg(mcspi->dev, "dma %cX %d bytes error\n",
spi-omap2-mcspi.c:1290:				dma_unmap_single(mcspi->dev, t->tx_dma,
spi-omap2-mcspi.c:1292:			return -EINVAL;
spi-omap2-mcspi.c:1302:	struct spi_master	*master = mcspi->master;
spi-omap2-mcspi.c:1303:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
spi-omap2-mcspi.c:1306:	ret = pm_runtime_get_sync(mcspi->dev);
spi-omap2-mcspi.c:1312:	ctx->wakeupenable = OMAP2_MCSPI_WAKEUPENABLE_WKEN;
spi-omap2-mcspi.c:1315:	pm_runtime_mark_last_busy(mcspi->dev);
spi-omap2-mcspi.c:1316:	pm_runtime_put_autosuspend(mcspi->dev);
spi-omap2-mcspi.c:1342:		.compatible = "ti,omap2-mcspi",
spi-omap2-mcspi.c:1346:		.compatible = "ti,omap4-mcspi",
spi-omap2-mcspi.c:1362:	struct device_node	*node = pdev->dev.of_node;
spi-omap2-mcspi.c:1365:	master = spi_alloc_master(&pdev->dev, sizeof *mcspi);
spi-omap2-mcspi.c:1367:		dev_dbg(&pdev->dev, "master allocation failed\n");
spi-omap2-mcspi.c:1368:		return -ENOMEM;
spi-omap2-mcspi.c:1371:	/* the spi->mode bits understood by this driver: */
spi-omap2-mcspi.c:1372:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-omap2-mcspi.c:1373:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);
spi-omap2-mcspi.c:1374:	master->setup = omap2_mcspi_setup;
spi-omap2-mcspi.c:1375:	master->auto_runtime_pm = true;
spi-omap2-mcspi.c:1376:	master->prepare_message = omap2_mcspi_prepare_message;
spi-omap2-mcspi.c:1377:	master->transfer_one = omap2_mcspi_transfer_one;
spi-omap2-mcspi.c:1378:	master->set_cs = omap2_mcspi_set_cs;
spi-omap2-mcspi.c:1379:	master->cleanup = omap2_mcspi_cleanup;
spi-omap2-mcspi.c:1380:	master->dev.of_node = node;
spi-omap2-mcspi.c:1381:	master->max_speed_hz = OMAP2_MCSPI_MAX_FREQ;
spi-omap2-mcspi.c:1382:	master->min_speed_hz = OMAP2_MCSPI_MAX_FREQ >> 15;
spi-omap2-mcspi.c:1387:	mcspi->master = master;
spi-omap2-mcspi.c:1389:	match = of_match_device(omap_mcspi_of_match, &pdev->dev);
spi-omap2-mcspi.c:1392:		pdata = match->data;
spi-omap2-mcspi.c:1394:		of_property_read_u32(node, "ti,spi-num-cs", &num_cs);
spi-omap2-mcspi.c:1395:		master->num_chipselect = num_cs;
spi-omap2-mcspi.c:1396:		master->bus_num = bus_num++;
spi-omap2-mcspi.c:1397:		if (of_get_property(node, "ti,pindir-d0-out-d1-in", NULL))
spi-omap2-mcspi.c:1398:			mcspi->pin_dir = MCSPI_PINDIR_D0_OUT_D1_IN;
spi-omap2-mcspi.c:1400:		pdata = dev_get_platdata(&pdev->dev);
spi-omap2-mcspi.c:1401:		master->num_chipselect = pdata->num_cs;
spi-omap2-mcspi.c:1402:		if (pdev->id != -1)
spi-omap2-mcspi.c:1403:			master->bus_num = pdev->id;
spi-omap2-mcspi.c:1404:		mcspi->pin_dir = pdata->pin_dir;
spi-omap2-mcspi.c:1406:	regs_offset = pdata->regs_offset;
spi-omap2-mcspi.c:1410:		status = -ENODEV;
spi-omap2-mcspi.c:1414:	r->start += regs_offset;
spi-omap2-mcspi.c:1415:	r->end += regs_offset;
spi-omap2-mcspi.c:1416:	mcspi->phys = r->start;
spi-omap2-mcspi.c:1418:	mcspi->base = devm_ioremap_resource(&pdev->dev, r);
spi-omap2-mcspi.c:1419:	if (IS_ERR(mcspi->base)) {
spi-omap2-mcspi.c:1420:		status = PTR_ERR(mcspi->base);
spi-omap2-mcspi.c:1424:	mcspi->dev = &pdev->dev;
spi-omap2-mcspi.c:1426:	INIT_LIST_HEAD(&mcspi->ctx.cs);
spi-omap2-mcspi.c:1428:	mcspi->dma_channels = devm_kcalloc(&pdev->dev, master->num_chipselect,
spi-omap2-mcspi.c:1431:	if (mcspi->dma_channels == NULL) {
spi-omap2-mcspi.c:1432:		status = -ENOMEM;
spi-omap2-mcspi.c:1436:	for (i = 0; i < master->num_chipselect; i++) {
spi-omap2-mcspi.c:1437:		char *dma_rx_ch_name = mcspi->dma_channels[i].dma_rx_ch_name;
spi-omap2-mcspi.c:1438:		char *dma_tx_ch_name = mcspi->dma_channels[i].dma_tx_ch_name;
spi-omap2-mcspi.c:1442:		if (!pdev->dev.of_node) {
spi-omap2-mcspi.c:1448:				dev_dbg(&pdev->dev,
spi-omap2-mcspi.c:1450:				status = -ENODEV;
spi-omap2-mcspi.c:1454:			mcspi->dma_channels[i].dma_rx_sync_dev =
spi-omap2-mcspi.c:1455:				dma_res->start;
spi-omap2-mcspi.c:1458:		if (!pdev->dev.of_node) {
spi-omap2-mcspi.c:1464:				dev_dbg(&pdev->dev,
spi-omap2-mcspi.c:1466:				status = -ENODEV;
spi-omap2-mcspi.c:1470:			mcspi->dma_channels[i].dma_tx_sync_dev =
spi-omap2-mcspi.c:1471:				dma_res->start;
spi-omap2-mcspi.c:1478:	pm_runtime_use_autosuspend(&pdev->dev);
spi-omap2-mcspi.c:1479:	pm_runtime_set_autosuspend_delay(&pdev->dev, SPI_AUTOSUSPEND_TIMEOUT);
spi-omap2-mcspi.c:1480:	pm_runtime_enable(&pdev->dev);
spi-omap2-mcspi.c:1486:	status = devm_spi_register_master(&pdev->dev, master);
spi-omap2-mcspi.c:1493:	pm_runtime_disable(&pdev->dev);
spi-omap2-mcspi.c:1504:	pm_runtime_put_sync(mcspi->dev);
spi-omap2-mcspi.c:1505:	pm_runtime_disable(&pdev->dev);
spi-omap2-mcspi.c:1515: * When SPI wake up from off-mode, CS is in activate state. If it was in
spi-omap2-mcspi.c:1523:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
spi-omap2-mcspi.c:1526:	pm_runtime_get_sync(mcspi->dev);
spi-omap2-mcspi.c:1527:	list_for_each_entry(cs, &ctx->cs, node) {
spi-omap2-mcspi.c:1528:		if ((cs->chconf0 & OMAP2_MCSPI_CHCONF_FORCE) == 0) {
spi-omap2-mcspi.c:1533:			cs->chconf0 |= OMAP2_MCSPI_CHCONF_FORCE;
spi-omap2-mcspi.c:1534:			writel_relaxed(cs->chconf0, cs->base + OMAP2_MCSPI_CHCONF0);
spi-omap2-mcspi.c:1535:			cs->chconf0 &= ~OMAP2_MCSPI_CHCONF_FORCE;
spi-omap2-mcspi.c:1536:			writel_relaxed(cs->chconf0, cs->base + OMAP2_MCSPI_CHCONF0);
spi-omap2-mcspi.c:1539:	pm_runtime_mark_last_busy(mcspi->dev);
spi-omap2-mcspi.c:1540:	pm_runtime_put_autosuspend(mcspi->dev);
spi-fsl-spi.c:23:#include <linux/dma-mapping.h>
spi-fsl-spi.c:42:#include "spi-fsl-lib.h"
spi-fsl-spi.c:43:#include "spi-fsl-cpm.h"
spi-fsl-spi.c:44:#include "spi-fsl-spi.h"
spi-fsl-spi.c:78:	if (dev->of_node) {
spi-fsl-spi.c:79:		match = of_match_node(of_fsl_spi_match, dev->of_node);
spi-fsl-spi.c:80:		if (match && match->data)
spi-fsl-spi.c:81:			return ((struct fsl_spi_match_data *)match->data)->type;
spi-fsl-spi.c:88:	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
spi-fsl-spi.c:89:	struct spi_mpc8xxx_cs *cs = spi->controller_state;
spi-fsl-spi.c:90:	struct fsl_spi_reg *reg_base = mspi->reg_base;
spi-fsl-spi.c:91:	__be32 __iomem *mode = &reg_base->mode;
spi-fsl-spi.c:94:	if (cs->hw_mode == mpc8xxx_spi_read_reg(mode))
spi-fsl-spi.c:101:	mpc8xxx_spi_write_reg(mode, cs->hw_mode & ~SPMODE_ENABLE);
spi-fsl-spi.c:104:	if (mspi->flags & SPI_CPM_MODE) {
spi-fsl-spi.c:107:	mpc8xxx_spi_write_reg(mode, cs->hw_mode);
spi-fsl-spi.c:113:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
spi-fsl-spi.c:115:	bool pol = spi->mode & SPI_CS_HIGH;
spi-fsl-spi.c:116:	struct spi_mpc8xxx_cs	*cs = spi->controller_state;
spi-fsl-spi.c:118:	pdata = spi->dev.parent->parent->platform_data;
spi-fsl-spi.c:121:		if (pdata->cs_control)
spi-fsl-spi.c:122:			pdata->cs_control(spi, !pol);
spi-fsl-spi.c:126:		mpc8xxx_spi->rx_shift = cs->rx_shift;
spi-fsl-spi.c:127:		mpc8xxx_spi->tx_shift = cs->tx_shift;
spi-fsl-spi.c:128:		mpc8xxx_spi->get_rx = cs->get_rx;
spi-fsl-spi.c:129:		mpc8xxx_spi->get_tx = cs->get_tx;
spi-fsl-spi.c:133:		if (pdata->cs_control)
spi-fsl-spi.c:134:			pdata->cs_control(spi, pol);
spi-fsl-spi.c:165:			*tx_shift = 32 - bits_per_word; /* MSB in bit 31 */
spi-fsl-spi.c:167:			*rx_shift = 16 - bits_per_word; /* MSB in bit 15 */
spi-fsl-spi.c:177:	cs->rx_shift = 0;
spi-fsl-spi.c:178:	cs->tx_shift = 0;
spi-fsl-spi.c:180:		cs->get_rx = mpc8xxx_spi_rx_buf_u8;
spi-fsl-spi.c:181:		cs->get_tx = mpc8xxx_spi_tx_buf_u8;
spi-fsl-spi.c:183:		cs->get_rx = mpc8xxx_spi_rx_buf_u16;
spi-fsl-spi.c:184:		cs->get_tx = mpc8xxx_spi_tx_buf_u16;
spi-fsl-spi.c:186:		cs->get_rx = mpc8xxx_spi_rx_buf_u32;
spi-fsl-spi.c:187:		cs->get_tx = mpc8xxx_spi_tx_buf_u32;
spi-fsl-spi.c:189:		return -EINVAL;
spi-fsl-spi.c:191:	if (mpc8xxx_spi->set_shifts)
spi-fsl-spi.c:192:		mpc8xxx_spi->set_shifts(&cs->rx_shift, &cs->tx_shift,
spi-fsl-spi.c:194:					!(spi->mode & SPI_LSB_FIRST));
spi-fsl-spi.c:196:	mpc8xxx_spi->rx_shift = cs->rx_shift;
spi-fsl-spi.c:197:	mpc8xxx_spi->tx_shift = cs->tx_shift;
spi-fsl-spi.c:198:	mpc8xxx_spi->get_rx = cs->get_rx;
spi-fsl-spi.c:199:	mpc8xxx_spi->get_tx = cs->get_tx;
spi-fsl-spi.c:214:	if (spi->mode & SPI_LSB_FIRST &&
spi-fsl-spi.c:216:		return -EINVAL;
spi-fsl-spi.c:229:	struct spi_mpc8xxx_cs	*cs = spi->controller_state;
spi-fsl-spi.c:231:	mpc8xxx_spi = spi_master_get_devdata(spi->master);
spi-fsl-spi.c:234:		bits_per_word = t->bits_per_word;
spi-fsl-spi.c:235:		hz = t->speed_hz;
spi-fsl-spi.c:238:	/* spi_transfer level calls that work per-word */
spi-fsl-spi.c:240:		bits_per_word = spi->bits_per_word;
spi-fsl-spi.c:243:		hz = spi->max_speed_hz;
spi-fsl-spi.c:245:	if (!(mpc8xxx_spi->flags & SPI_CPM_MODE))
spi-fsl-spi.c:249:	else if (mpc8xxx_spi->flags & SPI_QE)
spi-fsl-spi.c:259:		bits_per_word = bits_per_word - 1;
spi-fsl-spi.c:262:	cs->hw_mode &= ~(SPMODE_LEN(0xF) | SPMODE_DIV16
spi-fsl-spi.c:265:	cs->hw_mode |= SPMODE_LEN(bits_per_word);
spi-fsl-spi.c:267:	if ((mpc8xxx_spi->spibrg / hz) > 64) {
spi-fsl-spi.c:268:		cs->hw_mode |= SPMODE_DIV16;
spi-fsl-spi.c:269:		pm = (mpc8xxx_spi->spibrg - 1) / (hz * 64) + 1;
spi-fsl-spi.c:272:			  "Will use %d Hz instead.\n", dev_name(&spi->dev),
spi-fsl-spi.c:273:			  hz, mpc8xxx_spi->spibrg / 1024);
spi-fsl-spi.c:277:		pm = (mpc8xxx_spi->spibrg - 1) / (hz * 4) + 1;
spi-fsl-spi.c:280:		pm--;
spi-fsl-spi.c:282:	cs->hw_mode |= SPMODE_PM(pm);
spi-fsl-spi.c:292:	struct fsl_spi_reg *reg_base = mspi->reg_base;
spi-fsl-spi.c:294:	mspi->count = len;
spi-fsl-spi.c:297:	mpc8xxx_spi_write_reg(&reg_base->mask, SPIM_NE);
spi-fsl-spi.c:300:	word = mspi->get_tx(mspi);
spi-fsl-spi.c:301:	mpc8xxx_spi_write_reg(&reg_base->transmit, word);
spi-fsl-spi.c:309:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
spi-fsl-spi.c:311:	unsigned int len = t->len;
spi-fsl-spi.c:315:	reg_base = mpc8xxx_spi->reg_base;
spi-fsl-spi.c:316:	bits_per_word = spi->bits_per_word;
spi-fsl-spi.c:317:	if (t->bits_per_word)
spi-fsl-spi.c:318:		bits_per_word = t->bits_per_word;
spi-fsl-spi.c:323:			return -EINVAL;
spi-fsl-spi.c:329:			return -EINVAL;
spi-fsl-spi.c:333:	mpc8xxx_spi->tx = t->tx_buf;
spi-fsl-spi.c:334:	mpc8xxx_spi->rx = t->rx_buf;
spi-fsl-spi.c:336:	reinit_completion(&mpc8xxx_spi->done);
spi-fsl-spi.c:338:	if (mpc8xxx_spi->flags & SPI_CPM_MODE)
spi-fsl-spi.c:345:	wait_for_completion(&mpc8xxx_spi->done);
spi-fsl-spi.c:348:	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
spi-fsl-spi.c:350:	if (mpc8xxx_spi->flags & SPI_CPM_MODE)
spi-fsl-spi.c:353:	return mpc8xxx_spi->count;
spi-fsl-spi.c:359:	struct spi_device *spi = m->spi;
spi-fsl-spi.c:366:	first = list_first_entry(&m->transfers, struct spi_transfer,
spi-fsl-spi.c:368:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-fsl-spi.c:369:		if ((first->bits_per_word != t->bits_per_word) ||
spi-fsl-spi.c:370:			(first->speed_hz != t->speed_hz)) {
spi-fsl-spi.c:371:			dev_err(&spi->dev,
spi-fsl-spi.c:373:			return -EINVAL;
spi-fsl-spi.c:378:	status = -EINVAL;
spi-fsl-spi.c:379:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-fsl-spi.c:380:		if (t->bits_per_word || t->speed_hz) {
spi-fsl-spi.c:391:		cs_change = t->cs_change;
spi-fsl-spi.c:392:		if (t->len)
spi-fsl-spi.c:393:			status = fsl_spi_bufs(spi, t, m->is_dma_mapped);
spi-fsl-spi.c:395:			status = -EMSGSIZE;
spi-fsl-spi.c:398:		m->actual_length += t->len;
spi-fsl-spi.c:400:		if (t->delay_usecs)
spi-fsl-spi.c:401:			udelay(t->delay_usecs);
spi-fsl-spi.c:410:	m->status = status;
spi-fsl-spi.c:430:	if (!spi->max_speed_hz)
spi-fsl-spi.c:431:		return -EINVAL;
spi-fsl-spi.c:436:			return -ENOMEM;
spi-fsl-spi.c:439:	mpc8xxx_spi = spi_master_get_devdata(spi->master);
spi-fsl-spi.c:441:	reg_base = mpc8xxx_spi->reg_base;
spi-fsl-spi.c:443:	hw_mode = cs->hw_mode; /* Save original settings */
spi-fsl-spi.c:444:	cs->hw_mode = mpc8xxx_spi_read_reg(&reg_base->mode);
spi-fsl-spi.c:446:	cs->hw_mode &= ~(SPMODE_CP_BEGIN_EDGECLK | SPMODE_CI_INACTIVEHIGH
spi-fsl-spi.c:449:	if (spi->mode & SPI_CPHA)
spi-fsl-spi.c:450:		cs->hw_mode |= SPMODE_CP_BEGIN_EDGECLK;
spi-fsl-spi.c:451:	if (spi->mode & SPI_CPOL)
spi-fsl-spi.c:452:		cs->hw_mode |= SPMODE_CI_INACTIVEHIGH;
spi-fsl-spi.c:453:	if (!(spi->mode & SPI_LSB_FIRST))
spi-fsl-spi.c:454:		cs->hw_mode |= SPMODE_REV;
spi-fsl-spi.c:455:	if (spi->mode & SPI_LOOP)
spi-fsl-spi.c:456:		cs->hw_mode |= SPMODE_LOOP;
spi-fsl-spi.c:460:		cs->hw_mode = hw_mode; /* Restore settings */
spi-fsl-spi.c:464:	if (mpc8xxx_spi->type == TYPE_GRLIB) {
spi-fsl-spi.c:465:		if (gpio_is_valid(spi->cs_gpio)) {
spi-fsl-spi.c:468:			retval = gpio_request(spi->cs_gpio,
spi-fsl-spi.c:469:					      dev_name(&spi->dev));
spi-fsl-spi.c:473:			desel = !(spi->mode & SPI_CS_HIGH);
spi-fsl-spi.c:474:			retval = gpio_direction_output(spi->cs_gpio, desel);
spi-fsl-spi.c:476:				gpio_free(spi->cs_gpio);
spi-fsl-spi.c:479:		} else if (spi->cs_gpio != -ENOENT) {
spi-fsl-spi.c:480:			if (spi->cs_gpio < 0)
spi-fsl-spi.c:481:				return spi->cs_gpio;
spi-fsl-spi.c:482:			return -EINVAL;
spi-fsl-spi.c:484:		/* When spi->cs_gpio == -ENOENT, a hole in the phandle list
spi-fsl-spi.c:490:	/* Initialize chipselect - might be active for SPI_CS_HIGH mode */
spi-fsl-spi.c:498:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
spi-fsl-spi.c:501:	if (mpc8xxx_spi->type == TYPE_GRLIB && gpio_is_valid(spi->cs_gpio))
spi-fsl-spi.c:502:		gpio_free(spi->cs_gpio);
spi-fsl-spi.c:510:	struct fsl_spi_reg *reg_base = mspi->reg_base;
spi-fsl-spi.c:514:		u32 rx_data = mpc8xxx_spi_read_reg(&reg_base->receive);
spi-fsl-spi.c:516:		if (mspi->rx)
spi-fsl-spi.c:517:			mspi->get_rx(rx_data, mspi);
spi-fsl-spi.c:523:			mpc8xxx_spi_read_reg(&reg_base->event)) &
spi-fsl-spi.c:528:	mpc8xxx_spi_write_reg(&reg_base->event, events);
spi-fsl-spi.c:530:	mspi->count -= 1;
spi-fsl-spi.c:531:	if (mspi->count) {
spi-fsl-spi.c:532:		u32 word = mspi->get_tx(mspi);
spi-fsl-spi.c:534:		mpc8xxx_spi_write_reg(&reg_base->transmit, word);
spi-fsl-spi.c:536:		complete(&mspi->done);
spi-fsl-spi.c:545:	struct fsl_spi_reg *reg_base = mspi->reg_base;
spi-fsl-spi.c:548:	events = mpc8xxx_spi_read_reg(&reg_base->event);
spi-fsl-spi.c:552:	dev_dbg(mspi->dev, "%s: events %x\n", __func__, events);
spi-fsl-spi.c:554:	if (mspi->flags & SPI_CPM_MODE)
spi-fsl-spi.c:564:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
spi-fsl-spi.c:565:	struct fsl_spi_reg *reg_base = mpc8xxx_spi->reg_base;
spi-fsl-spi.c:567:	u16 cs = spi->chip_select;
spi-fsl-spi.c:569:	if (gpio_is_valid(spi->cs_gpio)) {
spi-fsl-spi.c:570:		gpio_set_value(spi->cs_gpio, on);
spi-fsl-spi.c:571:	} else if (cs < mpc8xxx_spi->native_chipselects) {
spi-fsl-spi.c:572:		slvsel = mpc8xxx_spi_read_reg(&reg_base->slvsel);
spi-fsl-spi.c:574:		mpc8xxx_spi_write_reg(&reg_base->slvsel, slvsel);
spi-fsl-spi.c:583:	struct fsl_spi_reg *reg_base = mpc8xxx_spi->reg_base;
spi-fsl-spi.c:587:	capabilities = mpc8xxx_spi_read_reg(&reg_base->cap);
spi-fsl-spi.c:589:	mpc8xxx_spi->set_shifts = fsl_spi_grlib_set_shifts;
spi-fsl-spi.c:592:		mpc8xxx_spi->max_bits_per_word = mbits + 1;
spi-fsl-spi.c:594:	mpc8xxx_spi->native_chipselects = 0;
spi-fsl-spi.c:596:		mpc8xxx_spi->native_chipselects = SPCAP_SSSZ(capabilities);
spi-fsl-spi.c:597:		mpc8xxx_spi_write_reg(&reg_base->slvsel, 0xffffffff);
spi-fsl-spi.c:599:	master->num_chipselect = mpc8xxx_spi->native_chipselects;
spi-fsl-spi.c:600:	pdata->cs_control = fsl_spi_grlib_cs_control;
spi-fsl-spi.c:615:		ret = -ENOMEM;
spi-fsl-spi.c:623:	master->setup = fsl_spi_setup;
spi-fsl-spi.c:624:	master->cleanup = fsl_spi_cleanup;
spi-fsl-spi.c:625:	master->transfer_one_message = fsl_spi_do_one_msg;
spi-fsl-spi.c:628:	mpc8xxx_spi->max_bits_per_word = 32;
spi-fsl-spi.c:629:	mpc8xxx_spi->type = fsl_spi_get_type(dev);
spi-fsl-spi.c:635:	mpc8xxx_spi->reg_base = devm_ioremap_resource(dev, mem);
spi-fsl-spi.c:636:	if (IS_ERR(mpc8xxx_spi->reg_base)) {
spi-fsl-spi.c:637:		ret = PTR_ERR(mpc8xxx_spi->reg_base);
spi-fsl-spi.c:641:	if (mpc8xxx_spi->type == TYPE_GRLIB)
spi-fsl-spi.c:644:	master->bits_per_word_mask =
spi-fsl-spi.c:646:		SPI_BPW_RANGE_MASK(1, mpc8xxx_spi->max_bits_per_word);
spi-fsl-spi.c:648:	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE)
spi-fsl-spi.c:649:		mpc8xxx_spi->set_shifts = fsl_spi_qe_cpu_set_shifts;
spi-fsl-spi.c:651:	if (mpc8xxx_spi->set_shifts)
spi-fsl-spi.c:653:		mpc8xxx_spi->set_shifts(&mpc8xxx_spi->rx_shift,
spi-fsl-spi.c:654:					&mpc8xxx_spi->tx_shift, 8, 1);
spi-fsl-spi.c:657:	ret = devm_request_irq(dev, mpc8xxx_spi->irq, fsl_spi_irq,
spi-fsl-spi.c:663:	reg_base = mpc8xxx_spi->reg_base;
spi-fsl-spi.c:666:	mpc8xxx_spi_write_reg(&reg_base->mode, 0);
spi-fsl-spi.c:667:	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
spi-fsl-spi.c:668:	mpc8xxx_spi_write_reg(&reg_base->command, 0);
spi-fsl-spi.c:669:	mpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);
spi-fsl-spi.c:672:	regval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;
spi-fsl-spi.c:673:	if (mpc8xxx_spi->max_bits_per_word < 8) {
spi-fsl-spi.c:675:		regval |= SPMODE_LEN(mpc8xxx_spi->max_bits_per_word - 1);
spi-fsl-spi.c:677:	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE)
spi-fsl-spi.c:680:	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
spi-fsl-spi.c:687:		 mpc8xxx_spi->irq, mpc8xxx_spi_strmode(mpc8xxx_spi->flags));
spi-fsl-spi.c:701:	struct device *dev = spi->dev.parent->parent;
spi-fsl-spi.c:704:	u16 cs = spi->chip_select;
spi-fsl-spi.c:705:	int gpio = pinfo->gpios[cs];
spi-fsl-spi.c:706:	bool alow = pinfo->alow_flags[cs];
spi-fsl-spi.c:713:	struct device_node *np = dev->of_node;
spi-fsl-spi.c:723:		 * SPI w/o chip-select line. One SPI device is still permitted
spi-fsl-spi.c:726:		pdata->max_chipselect = 1;
spi-fsl-spi.c:730:	pinfo->gpios = kmalloc(ngpios * sizeof(*pinfo->gpios), GFP_KERNEL);
spi-fsl-spi.c:731:	if (!pinfo->gpios)
spi-fsl-spi.c:732:		return -ENOMEM;
spi-fsl-spi.c:733:	memset(pinfo->gpios, -1, ngpios * sizeof(*pinfo->gpios));
spi-fsl-spi.c:735:	pinfo->alow_flags = kzalloc(ngpios * sizeof(*pinfo->alow_flags),
spi-fsl-spi.c:737:	if (!pinfo->alow_flags) {
spi-fsl-spi.c:738:		ret = -ENOMEM;
spi-fsl-spi.c:759:		pinfo->gpios[i] = gpio;
spi-fsl-spi.c:760:		pinfo->alow_flags[i] = flags & OF_GPIO_ACTIVE_LOW;
spi-fsl-spi.c:762:		ret = gpio_direction_output(pinfo->gpios[i],
spi-fsl-spi.c:763:					    pinfo->alow_flags[i]);
spi-fsl-spi.c:771:	pdata->max_chipselect = ngpios;
spi-fsl-spi.c:772:	pdata->cs_control = fsl_spi_cs_control;
spi-fsl-spi.c:778:		if (gpio_is_valid(pinfo->gpios[i]))
spi-fsl-spi.c:779:			gpio_free(pinfo->gpios[i]);
spi-fsl-spi.c:780:		i--;
spi-fsl-spi.c:783:	kfree(pinfo->alow_flags);
spi-fsl-spi.c:784:	pinfo->alow_flags = NULL;
spi-fsl-spi.c:786:	kfree(pinfo->gpios);
spi-fsl-spi.c:787:	pinfo->gpios = NULL;
spi-fsl-spi.c:797:	if (!pinfo->gpios)
spi-fsl-spi.c:800:	for (i = 0; i < pdata->max_chipselect; i++) {
spi-fsl-spi.c:801:		if (gpio_is_valid(pinfo->gpios[i]))
spi-fsl-spi.c:802:			gpio_free(pinfo->gpios[i]);
spi-fsl-spi.c:805:	kfree(pinfo->gpios);
spi-fsl-spi.c:806:	kfree(pinfo->alow_flags);
spi-fsl-spi.c:812:	struct device *dev = &ofdev->dev;
spi-fsl-spi.c:813:	struct device_node *np = ofdev->dev.of_node;
spi-fsl-spi.c:817:	int ret = -ENOMEM;
spi-fsl-spi.c:823:	type = fsl_spi_get_type(&ofdev->dev);
spi-fsl-spi.c:836:		ret = -EINVAL;
spi-fsl-spi.c:860:	if (mpc8xxx_spi->type == TYPE_FSL)
spi-fsl-spi.c:861:		of_fsl_spi_free_chipselects(&ofdev->dev);
spi-fsl-spi.c:877: * This is "legacy" platform driver, was used by the MPC8323E-RDB boards
spi-fsl-spi.c:878: * only. The driver should go away soon, since newer MPC8323E-RDB's device
spi-fsl-spi.c:888:	if (!dev_get_platdata(&pdev->dev))
spi-fsl-spi.c:889:		return -EINVAL;
spi-fsl-spi.c:893:		return -EINVAL;
spi-fsl-spi.c:897:		return -EINVAL;
spi-fsl-spi.c:899:	master = fsl_spi_probe(&pdev->dev, mem, irq);
spi-tegra20-sflash.c:102:#define SPI_DMA_BLK_COUNT(count)	(((count) - 1) & 0xFFFF)
spi-tegra20-sflash.c:153:	return readl(tsd->base + reg);
spi-tegra20-sflash.c:159:	writel(val, tsd->base + reg);
spi-tegra20-sflash.c:172:	unsigned remain_len = t->len - tsd->cur_pos;
spi-tegra20-sflash.c:175:	tsd->bytes_per_word = DIV_ROUND_UP(t->bits_per_word, 8);
spi-tegra20-sflash.c:176:	max_word = remain_len / tsd->bytes_per_word;
spi-tegra20-sflash.c:179:	tsd->curr_xfer_words = max_word;
spi-tegra20-sflash.c:188:	unsigned max_n_32bit = tsd->curr_xfer_words;
spi-tegra20-sflash.c:189:	u8 *tx_buf = (u8 *)t->tx_buf + tsd->cur_tx_pos;
spi-tegra20-sflash.c:193:	nbytes = max_n_32bit * tsd->bytes_per_word;
spi-tegra20-sflash.c:200:		for (i = 0; nbytes && (i < tsd->bytes_per_word);
spi-tegra20-sflash.c:201:							i++, nbytes--)
spi-tegra20-sflash.c:209:	tsd->cur_tx_pos += max_n_32bit * tsd->bytes_per_word;
spi-tegra20-sflash.c:218:	u8 *rx_buf = (u8 *)t->rx_buf + tsd->cur_rx_pos;
spi-tegra20-sflash.c:225:		for (i = 0; (i < tsd->bytes_per_word); i++)
spi-tegra20-sflash.c:230:	tsd->cur_rx_pos += read_words * tsd->bytes_per_word;
spi-tegra20-sflash.c:240:	if (tsd->cur_direction & DATA_DIR_TX)
spi-tegra20-sflash.c:243:	if (tsd->cur_direction & DATA_DIR_RX)
spi-tegra20-sflash.c:247:	tsd->dma_control_reg = val;
spi-tegra20-sflash.c:249:	if (tsd->cur_direction & DATA_DIR_TX)
spi-tegra20-sflash.c:252:		cur_words = tsd->curr_xfer_words;
spi-tegra20-sflash.c:255:	tsd->dma_control_reg = val;
spi-tegra20-sflash.c:265:	struct tegra_sflash_data *tsd = spi_master_get_devdata(spi->master);
spi-tegra20-sflash.c:269:	speed = t->speed_hz;
spi-tegra20-sflash.c:270:	if (speed != tsd->cur_speed) {
spi-tegra20-sflash.c:271:		clk_set_rate(tsd->clk, speed);
spi-tegra20-sflash.c:272:		tsd->cur_speed = speed;
spi-tegra20-sflash.c:275:	tsd->cur_spi = spi;
spi-tegra20-sflash.c:276:	tsd->cur_pos = 0;
spi-tegra20-sflash.c:277:	tsd->cur_rx_pos = 0;
spi-tegra20-sflash.c:278:	tsd->cur_tx_pos = 0;
spi-tegra20-sflash.c:279:	tsd->curr_xfer = t;
spi-tegra20-sflash.c:282:		command = tsd->def_command_reg;
spi-tegra20-sflash.c:283:		command |= SPI_BIT_LENGTH(t->bits_per_word - 1);
spi-tegra20-sflash.c:287:		if (spi->mode & SPI_CPHA)
spi-tegra20-sflash.c:290:		if (spi->mode & SPI_CPOL)
spi-tegra20-sflash.c:294:		command |= SPI_CS0_EN << spi->chip_select;
spi-tegra20-sflash.c:296:		command = tsd->command_reg;
spi-tegra20-sflash.c:298:		command |= SPI_BIT_LENGTH(t->bits_per_word - 1);
spi-tegra20-sflash.c:302:	tsd->cur_direction = 0;
spi-tegra20-sflash.c:303:	if (t->rx_buf) {
spi-tegra20-sflash.c:305:		tsd->cur_direction |= DATA_DIR_RX;
spi-tegra20-sflash.c:307:	if (t->tx_buf) {
spi-tegra20-sflash.c:309:		tsd->cur_direction |= DATA_DIR_TX;
spi-tegra20-sflash.c:312:	tsd->command_reg = command;
spi-tegra20-sflash.c:324:	struct spi_device *spi = msg->spi;
spi-tegra20-sflash.c:327:	msg->status = 0;
spi-tegra20-sflash.c:328:	msg->actual_length = 0;
spi-tegra20-sflash.c:329:	single_xfer = list_is_singular(&msg->transfers);
spi-tegra20-sflash.c:330:	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
spi-tegra20-sflash.c:331:		reinit_completion(&tsd->xfer_completion);
spi-tegra20-sflash.c:335:			dev_err(tsd->dev,
spi-tegra20-sflash.c:340:		ret = wait_for_completion_timeout(&tsd->xfer_completion,
spi-tegra20-sflash.c:343:			dev_err(tsd->dev,
spi-tegra20-sflash.c:345:			ret = -EIO;
spi-tegra20-sflash.c:349:		if (tsd->tx_status ||  tsd->rx_status) {
spi-tegra20-sflash.c:350:			dev_err(tsd->dev, "Error in Transfer\n");
spi-tegra20-sflash.c:351:			ret = -EIO;
spi-tegra20-sflash.c:354:		msg->actual_length += xfer->len;
spi-tegra20-sflash.c:355:		if (xfer->cs_change && xfer->delay_usecs) {
spi-tegra20-sflash.c:356:			tegra_sflash_writel(tsd, tsd->def_command_reg,
spi-tegra20-sflash.c:358:			udelay(xfer->delay_usecs);
spi-tegra20-sflash.c:363:	tegra_sflash_writel(tsd, tsd->def_command_reg, SPI_COMMAND);
spi-tegra20-sflash.c:364:	msg->status = ret;
spi-tegra20-sflash.c:371:	struct spi_transfer *t = tsd->curr_xfer;
spi-tegra20-sflash.c:374:	spin_lock_irqsave(&tsd->lock, flags);
spi-tegra20-sflash.c:375:	if (tsd->tx_status || tsd->rx_status || (tsd->status_reg & SPI_BSY)) {
spi-tegra20-sflash.c:376:		dev_err(tsd->dev,
spi-tegra20-sflash.c:377:			"CpuXfer ERROR bit set 0x%x\n", tsd->status_reg);
spi-tegra20-sflash.c:378:		dev_err(tsd->dev,
spi-tegra20-sflash.c:379:			"CpuXfer 0x%08x:0x%08x\n", tsd->command_reg,
spi-tegra20-sflash.c:380:				tsd->dma_control_reg);
spi-tegra20-sflash.c:381:		reset_control_assert(tsd->rst);
spi-tegra20-sflash.c:383:		reset_control_deassert(tsd->rst);
spi-tegra20-sflash.c:384:		complete(&tsd->xfer_completion);
spi-tegra20-sflash.c:388:	if (tsd->cur_direction & DATA_DIR_RX)
spi-tegra20-sflash.c:391:	if (tsd->cur_direction & DATA_DIR_TX)
spi-tegra20-sflash.c:392:		tsd->cur_pos = tsd->cur_tx_pos;
spi-tegra20-sflash.c:394:		tsd->cur_pos = tsd->cur_rx_pos;
spi-tegra20-sflash.c:396:	if (tsd->cur_pos == t->len) {
spi-tegra20-sflash.c:397:		complete(&tsd->xfer_completion);
spi-tegra20-sflash.c:401:	tegra_sflash_calculate_curr_xfer_param(tsd->cur_spi, tsd, t);
spi-tegra20-sflash.c:404:	spin_unlock_irqrestore(&tsd->lock, flags);
spi-tegra20-sflash.c:412:	tsd->status_reg = tegra_sflash_readl(tsd, SPI_STATUS);
spi-tegra20-sflash.c:413:	if (tsd->cur_direction & DATA_DIR_TX)
spi-tegra20-sflash.c:414:		tsd->tx_status = tsd->status_reg & SPI_TX_OVF;
spi-tegra20-sflash.c:416:	if (tsd->cur_direction & DATA_DIR_RX)
spi-tegra20-sflash.c:417:		tsd->rx_status = tsd->status_reg & SPI_RX_UNF;
spi-tegra20-sflash.c:424:	{ .compatible = "nvidia,tegra20-sflash", },
spi-tegra20-sflash.c:437:	match = of_match_device(tegra_sflash_of_match, &pdev->dev);
spi-tegra20-sflash.c:439:		dev_err(&pdev->dev, "Error: No device match found\n");
spi-tegra20-sflash.c:440:		return -ENODEV;
spi-tegra20-sflash.c:443:	master = spi_alloc_master(&pdev->dev, sizeof(*tsd));
spi-tegra20-sflash.c:445:		dev_err(&pdev->dev, "master allocation failed\n");
spi-tegra20-sflash.c:446:		return -ENOMEM;
spi-tegra20-sflash.c:449:	/* the spi->mode bits understood by this driver: */
spi-tegra20-sflash.c:450:	master->mode_bits = SPI_CPOL | SPI_CPHA;
spi-tegra20-sflash.c:451:	master->transfer_one_message = tegra_sflash_transfer_one_message;
spi-tegra20-sflash.c:452:	master->auto_runtime_pm = true;
spi-tegra20-sflash.c:453:	master->num_chipselect = MAX_CHIP_SELECT;
spi-tegra20-sflash.c:457:	tsd->master = master;
spi-tegra20-sflash.c:458:	tsd->dev = &pdev->dev;
spi-tegra20-sflash.c:459:	spin_lock_init(&tsd->lock);
spi-tegra20-sflash.c:461:	if (of_property_read_u32(tsd->dev->of_node, "spi-max-frequency",
spi-tegra20-sflash.c:462:				 &master->max_speed_hz))
spi-tegra20-sflash.c:463:		master->max_speed_hz = 25000000; /* 25MHz */
spi-tegra20-sflash.c:466:	tsd->base = devm_ioremap_resource(&pdev->dev, r);
spi-tegra20-sflash.c:467:	if (IS_ERR(tsd->base)) {
spi-tegra20-sflash.c:468:		ret = PTR_ERR(tsd->base);
spi-tegra20-sflash.c:472:	tsd->irq = platform_get_irq(pdev, 0);
spi-tegra20-sflash.c:473:	ret = request_irq(tsd->irq, tegra_sflash_isr, 0,
spi-tegra20-sflash.c:474:			dev_name(&pdev->dev), tsd);
spi-tegra20-sflash.c:476:		dev_err(&pdev->dev, "Failed to register ISR for IRQ %d\n",
spi-tegra20-sflash.c:477:					tsd->irq);
spi-tegra20-sflash.c:481:	tsd->clk = devm_clk_get(&pdev->dev, NULL);
spi-tegra20-sflash.c:482:	if (IS_ERR(tsd->clk)) {
spi-tegra20-sflash.c:483:		dev_err(&pdev->dev, "can not get clock\n");
spi-tegra20-sflash.c:484:		ret = PTR_ERR(tsd->clk);
spi-tegra20-sflash.c:488:	tsd->rst = devm_reset_control_get(&pdev->dev, "spi");
spi-tegra20-sflash.c:489:	if (IS_ERR(tsd->rst)) {
spi-tegra20-sflash.c:490:		dev_err(&pdev->dev, "can not get reset\n");
spi-tegra20-sflash.c:491:		ret = PTR_ERR(tsd->rst);
spi-tegra20-sflash.c:495:	init_completion(&tsd->xfer_completion);
spi-tegra20-sflash.c:496:	pm_runtime_enable(&pdev->dev);
spi-tegra20-sflash.c:497:	if (!pm_runtime_enabled(&pdev->dev)) {
spi-tegra20-sflash.c:498:		ret = tegra_sflash_runtime_resume(&pdev->dev);
spi-tegra20-sflash.c:503:	ret = pm_runtime_get_sync(&pdev->dev);
spi-tegra20-sflash.c:505:		dev_err(&pdev->dev, "pm runtime get failed, e = %d\n", ret);
spi-tegra20-sflash.c:510:	reset_control_assert(tsd->rst);
spi-tegra20-sflash.c:512:	reset_control_deassert(tsd->rst);
spi-tegra20-sflash.c:514:	tsd->def_command_reg  = SPI_M_S | SPI_CS_SW;
spi-tegra20-sflash.c:515:	tegra_sflash_writel(tsd, tsd->def_command_reg, SPI_COMMAND);
spi-tegra20-sflash.c:516:	pm_runtime_put(&pdev->dev);
spi-tegra20-sflash.c:518:	master->dev.of_node = pdev->dev.of_node;
spi-tegra20-sflash.c:519:	ret = devm_spi_register_master(&pdev->dev, master);
spi-tegra20-sflash.c:521:		dev_err(&pdev->dev, "can not register to master err %d\n", ret);
spi-tegra20-sflash.c:527:	pm_runtime_disable(&pdev->dev);
spi-tegra20-sflash.c:528:	if (!pm_runtime_status_suspended(&pdev->dev))
spi-tegra20-sflash.c:529:		tegra_sflash_runtime_suspend(&pdev->dev);
spi-tegra20-sflash.c:531:	free_irq(tsd->irq, tsd);
spi-tegra20-sflash.c:542:	free_irq(tsd->irq, tsd);
spi-tegra20-sflash.c:544:	pm_runtime_disable(&pdev->dev);
spi-tegra20-sflash.c:545:	if (!pm_runtime_status_suspended(&pdev->dev))
spi-tegra20-sflash.c:546:		tegra_sflash_runtime_suspend(&pdev->dev);
spi-tegra20-sflash.c:570:	tegra_sflash_writel(tsd, tsd->command_reg, SPI_COMMAND);
spi-tegra20-sflash.c:585:	clk_disable_unprepare(tsd->clk);
spi-tegra20-sflash.c:595:	ret = clk_prepare_enable(tsd->clk);
spi-tegra20-sflash.c:597:		dev_err(tsd->dev, "clk_prepare failed: %d\n", ret);
spi-tegra20-sflash.c:610:		.name		= "spi-tegra-sflash",
spi-tegra20-sflash.c:619:MODULE_ALIAS("platform:spi-tegra-sflash");
spi-s3c24xx-fiq.S:6: * S3C24XX SPI - FIQ pseudo-DMA transfer code
spi-s3c24xx-fiq.S:17:#include <mach/regs-irq.h>
spi-s3c24xx-fiq.S:18:#include <plat/regs-spi.h>
spi-s3c24xx-fiq.S:20:#include "spi-s3c24xx-fiq.h"
spi-s3c24xx-fiq.S:40:	.word	fiq_rx_end - fiq_rx_start
spi-s3c24xx-fiq.S:41:	.word	fiq_rx_irq_ack - fiq_rx_start
spi-s3c24xx-fiq.S:44:	str	fiq_rtmp, [ fiq_rirq, # S3C2410_SRCPND - S3C24XX_VA_IRQ ]
spi-s3c24xx-fiq.S:57:	str	fiq_rtmp, [ fiq_rirq, # S3C2410_INTMOD  - S3C24XX_VA_IRQ ]
spi-s3c24xx-fiq.S:66:	.word	fiq_txrx_end - fiq_txrx_start
spi-s3c24xx-fiq.S:67:	.word	fiq_txrx_irq_ack - fiq_txrx_start
spi-s3c24xx-fiq.S:74:	str	fiq_rtmp, [ fiq_rirq, # S3C2410_SRCPND - S3C24XX_VA_IRQ ]
spi-s3c24xx-fiq.S:83:	str	fiq_rtmp, [ fiq_rirq, # S3C2410_INTMOD  - S3C24XX_VA_IRQ ]
spi-s3c24xx-fiq.S:93:	.word	fiq_tx_end - fiq_tx_start
spi-s3c24xx-fiq.S:94:	.word	fiq_tx_irq_ack - fiq_tx_start
spi-s3c24xx-fiq.S:99:	str	fiq_rtmp, [ fiq_rirq, # S3C2410_SRCPND - S3C24XX_VA_IRQ ]
spi-s3c24xx-fiq.S:108:	str	fiq_rtmp, [ fiq_rirq, # S3C2410_INTMOD  - S3C24XX_VA_IRQ ]
spi-fsl-cpm.h:22:#include "spi-fsl-lib.h"
spi-ep93xx.c:4: * Copyright (C) 2010-2011 Mika Westerberg
spi-ep93xx.c:6: * Explicit FIFO handling code was inspired by amba-pl022 driver.
spi-ep93xx.c:8: * Chip select support using other than built-in GPIOs by H. Hartley Sweeten.
spi-ep93xx.c:33:#include <linux/platform_data/dma-ep93xx.h>
spi-ep93xx.c:34:#include <linux/platform_data/spi-ep93xx.h>
spi-ep93xx.c:71: * struct ep93xx_spi - EP93xx SPI controller structure
spi-ep93xx.c:80: * @fifo_level: how full is FIFO (%0..%SPI_FIFO_SIZE - %1). Receiving one
spi-ep93xx.c:111: * struct ep93xx_spi_chip - SPI device hardware settings
spi-ep93xx.c:121:#define bits_per_word_to_dss(bpw)	((bpw) - 1)
spi-ep93xx.c:126:	writeb(value, espi->regs_base + reg);
spi-ep93xx.c:131:	return readb(spi->regs_base + reg);
spi-ep93xx.c:137:	writew(value, espi->regs_base + reg);
spi-ep93xx.c:142:	return readw(spi->regs_base + reg);
spi-ep93xx.c:150:	err = clk_enable(espi->clk);
spi-ep93xx.c:169:	clk_disable(espi->clk);
spi-ep93xx.c:191: * ep93xx_spi_calc_divisors() - calculates SPI clock divisors
spi-ep93xx.c:194: * @div_cpsr: pointer to return the cpsr (pre-scaler) divider
spi-ep93xx.c:200:	struct spi_master *master = platform_get_drvdata(espi->pdev);
spi-ep93xx.c:201:	unsigned long spi_clk_rate = clk_get_rate(espi->clk);
spi-ep93xx.c:209:	rate = clamp(rate, master->min_speed_hz, master->max_speed_hz);
spi-ep93xx.c:229:	return -EINVAL;
spi-ep93xx.c:235:	int value = (spi->mode & SPI_CS_HIGH) ? control : !control;
spi-ep93xx.c:237:	if (chip->ops && chip->ops->cs_control)
spi-ep93xx.c:238:		chip->ops->cs_control(spi, value);
spi-ep93xx.c:242: * ep93xx_spi_setup() - setup an SPI device
spi-ep93xx.c:252:	struct ep93xx_spi *espi = spi_master_get_devdata(spi->master);
spi-ep93xx.c:257:		dev_dbg(&espi->pdev->dev, "initial setup for %s\n",
spi-ep93xx.c:258:			spi->modalias);
spi-ep93xx.c:262:			return -ENOMEM;
spi-ep93xx.c:264:		chip->spi = spi;
spi-ep93xx.c:265:		chip->ops = spi->controller_data;
spi-ep93xx.c:267:		if (chip->ops && chip->ops->setup) {
spi-ep93xx.c:268:			int ret = chip->ops->setup(spi);
spi-ep93xx.c:284: * ep93xx_spi_cleanup() - cleans up master controller specific state
spi-ep93xx.c:296:		if (chip->ops && chip->ops->cleanup)
spi-ep93xx.c:297:			chip->ops->cleanup(spi);
spi-ep93xx.c:304: * ep93xx_spi_chip_setup() - configures hardware according to given @chip
spi-ep93xx.c:325:	cr0 |= (chip->spi->mode & (SPI_CPHA|SPI_CPOL)) << SSPCR0_MODE_SHIFT;
spi-ep93xx.c:328:	dev_dbg(&espi->pdev->dev, "setup: mode %d, cpsr %d, scr %d, dss %d\n",
spi-ep93xx.c:329:		chip->spi->mode, div_cpsr, div_scr, dss);
spi-ep93xx.c:330:	dev_dbg(&espi->pdev->dev, "setup: cr0 %#x\n", cr0);
spi-ep93xx.c:340:	if (t->bits_per_word > 8) {
spi-ep93xx.c:343:		if (t->tx_buf)
spi-ep93xx.c:344:			tx_val = ((u16 *)t->tx_buf)[espi->tx];
spi-ep93xx.c:346:		espi->tx += sizeof(tx_val);
spi-ep93xx.c:350:		if (t->tx_buf)
spi-ep93xx.c:351:			tx_val = ((u8 *)t->tx_buf)[espi->tx];
spi-ep93xx.c:353:		espi->tx += sizeof(tx_val);
spi-ep93xx.c:359:	if (t->bits_per_word > 8) {
spi-ep93xx.c:363:		if (t->rx_buf)
spi-ep93xx.c:364:			((u16 *)t->rx_buf)[espi->rx] = rx_val;
spi-ep93xx.c:365:		espi->rx += sizeof(rx_val);
spi-ep93xx.c:370:		if (t->rx_buf)
spi-ep93xx.c:371:			((u8 *)t->rx_buf)[espi->rx] = rx_val;
spi-ep93xx.c:372:		espi->rx += sizeof(rx_val);
spi-ep93xx.c:377: * ep93xx_spi_read_write() - perform next RX/TX transfer
spi-ep93xx.c:380: * This function transfers next bytes (or half-words) to/from RX/TX FIFOs. If
spi-ep93xx.c:382: * %-EINPROGRESS when current transfer was not yet completed otherwise %0.
spi-ep93xx.c:389:	struct spi_message *msg = espi->current_msg;
spi-ep93xx.c:390:	struct spi_transfer *t = msg->state;
spi-ep93xx.c:395:		espi->fifo_level--;
spi-ep93xx.c:399:	while (espi->fifo_level < SPI_FIFO_SIZE && espi->tx < t->len) {
spi-ep93xx.c:401:		espi->fifo_level++;
spi-ep93xx.c:404:	if (espi->rx == t->len)
spi-ep93xx.c:407:	return -EINPROGRESS;
spi-ep93xx.c:418:		wait_for_completion(&espi->wait);
spi-ep93xx.c:423: * ep93xx_spi_dma_prepare() - prepares a DMA transfer
spi-ep93xx.c:434:	struct spi_transfer *t = espi->current_msg->state;
spi-ep93xx.c:442:	size_t len = t->len;
spi-ep93xx.c:445:	if (t->bits_per_word > 8)
spi-ep93xx.c:454:		chan = espi->dma_rx;
spi-ep93xx.c:455:		buf = t->rx_buf;
spi-ep93xx.c:456:		sgt = &espi->rx_sgt;
spi-ep93xx.c:458:		conf.src_addr = espi->sspdr_phys;
spi-ep93xx.c:461:		chan = espi->dma_tx;
spi-ep93xx.c:462:		buf = t->tx_buf;
spi-ep93xx.c:463:		sgt = &espi->tx_sgt;
spi-ep93xx.c:465:		conf.dst_addr = espi->sspdr_phys;
spi-ep93xx.c:475:	 * because we are using @espi->zeropage to provide a zero RX buffer
spi-ep93xx.c:479:	 * needed. Otherwise we will re-use the current one. Eventually the
spi-ep93xx.c:484:	if (nents != sgt->nents) {
spi-ep93xx.c:493:	for_each_sg(sgt->sgl, sg, sgt->nents, i) {
spi-ep93xx.c:500:			sg_set_page(sg, virt_to_page(espi->zeropage),
spi-ep93xx.c:505:		len -= bytes;
spi-ep93xx.c:509:		dev_warn(&espi->pdev->dev, "len = %zu expected 0!\n", len);
spi-ep93xx.c:510:		return ERR_PTR(-EINVAL);
spi-ep93xx.c:513:	nents = dma_map_sg(chan->device->dev, sgt->sgl, sgt->nents, dir);
spi-ep93xx.c:515:		return ERR_PTR(-ENOMEM);
spi-ep93xx.c:517:	txd = dmaengine_prep_slave_sg(chan, sgt->sgl, nents, dir, DMA_CTRL_ACK);
spi-ep93xx.c:519:		dma_unmap_sg(chan->device->dev, sgt->sgl, sgt->nents, dir);
spi-ep93xx.c:520:		return ERR_PTR(-ENOMEM);
spi-ep93xx.c:526: * ep93xx_spi_dma_finish() - finishes with a DMA transfer
spi-ep93xx.c:540:		chan = espi->dma_rx;
spi-ep93xx.c:541:		sgt = &espi->rx_sgt;
spi-ep93xx.c:543:		chan = espi->dma_tx;
spi-ep93xx.c:544:		sgt = &espi->tx_sgt;
spi-ep93xx.c:547:	dma_unmap_sg(chan->device->dev, sgt->sgl, sgt->nents, dir);
spi-ep93xx.c:557:	struct spi_message *msg = espi->current_msg;
spi-ep93xx.c:562:		dev_err(&espi->pdev->dev, "DMA RX failed: %ld\n", PTR_ERR(rxd));
spi-ep93xx.c:563:		msg->status = PTR_ERR(rxd);
spi-ep93xx.c:570:		dev_err(&espi->pdev->dev, "DMA TX failed: %ld\n", PTR_ERR(rxd));
spi-ep93xx.c:571:		msg->status = PTR_ERR(txd);
spi-ep93xx.c:576:	rxd->callback = ep93xx_spi_dma_callback;
spi-ep93xx.c:577:	rxd->callback_param = &espi->wait;
spi-ep93xx.c:583:	dma_async_issue_pending(espi->dma_rx);
spi-ep93xx.c:584:	dma_async_issue_pending(espi->dma_tx);
spi-ep93xx.c:586:	wait_for_completion(&espi->wait);
spi-ep93xx.c:593: * ep93xx_spi_process_transfer() - processes one SPI transfer
spi-ep93xx.c:599: * transfer is complete (may sleep) and updates @msg->status based on whether
spi-ep93xx.c:606:	struct ep93xx_spi_chip *chip = spi_get_ctldata(msg->spi);
spi-ep93xx.c:609:	msg->state = t;
spi-ep93xx.c:611:	err = ep93xx_spi_chip_setup(espi, chip, t->speed_hz, t->bits_per_word);
spi-ep93xx.c:613:		dev_err(&espi->pdev->dev,
spi-ep93xx.c:615:		msg->status = err;
spi-ep93xx.c:619:	espi->rx = 0;
spi-ep93xx.c:620:	espi->tx = 0;
spi-ep93xx.c:627:	if (espi->dma_rx && t->len > SPI_FIFO_SIZE)
spi-ep93xx.c:636:	if (msg->status)
spi-ep93xx.c:639:	msg->actual_length += t->len;
spi-ep93xx.c:643:	 * post-transfer actions requested by the protocol driver.
spi-ep93xx.c:645:	if (t->delay_usecs) {
spi-ep93xx.c:647:		schedule_timeout(usecs_to_jiffies(t->delay_usecs));
spi-ep93xx.c:649:	if (t->cs_change) {
spi-ep93xx.c:650:		if (!list_is_last(&t->transfer_list, &msg->transfers)) {
spi-ep93xx.c:656:			ep93xx_spi_cs_control(msg->spi, false);
spi-ep93xx.c:658:			ep93xx_spi_cs_control(msg->spi, true);
spi-ep93xx.c:664: * ep93xx_spi_process_message() - process one SPI message
spi-ep93xx.c:672: * @msg->status contains %0 in case of success or negative error code in case of
spi-ep93xx.c:687:		dev_err(&espi->pdev->dev, "failed to enable SPI controller\n");
spi-ep93xx.c:688:		msg->status = err;
spi-ep93xx.c:698:			dev_warn(&espi->pdev->dev,
spi-ep93xx.c:700:			msg->status = -ETIMEDOUT;
spi-ep93xx.c:710:	espi->fifo_level = 0;
spi-ep93xx.c:715:	ep93xx_spi_cs_control(msg->spi, true);
spi-ep93xx.c:717:	list_for_each_entry(t, &msg->transfers, transfer_list) {
spi-ep93xx.c:719:		if (msg->status)
spi-ep93xx.c:727:	ep93xx_spi_cs_control(msg->spi, false);
spi-ep93xx.c:736:	msg->state = NULL;
spi-ep93xx.c:737:	msg->status = 0;
spi-ep93xx.c:738:	msg->actual_length = 0;
spi-ep93xx.c:740:	espi->current_msg = msg;
spi-ep93xx.c:742:	espi->current_msg = NULL;
spi-ep93xx.c:761:		dev_warn(&espi->pdev->dev,
spi-ep93xx.c:763:		espi->current_msg->status = -EIO;
spi-ep93xx.c:782:	 * any post-processing of the message.
spi-ep93xx.c:785:	complete(&espi->wait);
spi-ep93xx.c:794:	chan->private = filter_param;
spi-ep93xx.c:803:	espi->zeropage = (void *)get_zeroed_page(GFP_KERNEL);
spi-ep93xx.c:804:	if (!espi->zeropage)
spi-ep93xx.c:805:		return -ENOMEM;
spi-ep93xx.c:810:	espi->dma_rx_data.port = EP93XX_DMA_SSP;
spi-ep93xx.c:811:	espi->dma_rx_data.direction = DMA_DEV_TO_MEM;
spi-ep93xx.c:812:	espi->dma_rx_data.name = "ep93xx-spi-rx";
spi-ep93xx.c:814:	espi->dma_rx = dma_request_channel(mask, ep93xx_spi_dma_filter,
spi-ep93xx.c:815:					   &espi->dma_rx_data);
spi-ep93xx.c:816:	if (!espi->dma_rx) {
spi-ep93xx.c:817:		ret = -ENODEV;
spi-ep93xx.c:821:	espi->dma_tx_data.port = EP93XX_DMA_SSP;
spi-ep93xx.c:822:	espi->dma_tx_data.direction = DMA_MEM_TO_DEV;
spi-ep93xx.c:823:	espi->dma_tx_data.name = "ep93xx-spi-tx";
spi-ep93xx.c:825:	espi->dma_tx = dma_request_channel(mask, ep93xx_spi_dma_filter,
spi-ep93xx.c:826:					   &espi->dma_tx_data);
spi-ep93xx.c:827:	if (!espi->dma_tx) {
spi-ep93xx.c:828:		ret = -ENODEV;
spi-ep93xx.c:835:	dma_release_channel(espi->dma_rx);
spi-ep93xx.c:836:	espi->dma_rx = NULL;
spi-ep93xx.c:838:	free_page((unsigned long)espi->zeropage);
spi-ep93xx.c:845:	if (espi->dma_rx) {
spi-ep93xx.c:846:		dma_release_channel(espi->dma_rx);
spi-ep93xx.c:847:		sg_free_table(&espi->rx_sgt);
spi-ep93xx.c:849:	if (espi->dma_tx) {
spi-ep93xx.c:850:		dma_release_channel(espi->dma_tx);
spi-ep93xx.c:851:		sg_free_table(&espi->tx_sgt);
spi-ep93xx.c:854:	if (espi->zeropage)
spi-ep93xx.c:855:		free_page((unsigned long)espi->zeropage);
spi-ep93xx.c:867:	info = dev_get_platdata(&pdev->dev);
spi-ep93xx.c:871:		dev_err(&pdev->dev, "failed to get irq resources\n");
spi-ep93xx.c:872:		return -EBUSY;
spi-ep93xx.c:877:		dev_err(&pdev->dev, "unable to get iomem resource\n");
spi-ep93xx.c:878:		return -ENODEV;
spi-ep93xx.c:881:	master = spi_alloc_master(&pdev->dev, sizeof(*espi));
spi-ep93xx.c:883:		return -ENOMEM;
spi-ep93xx.c:885:	master->setup = ep93xx_spi_setup;
spi-ep93xx.c:886:	master->transfer_one_message = ep93xx_spi_transfer_one_message;
spi-ep93xx.c:887:	master->cleanup = ep93xx_spi_cleanup;
spi-ep93xx.c:888:	master->bus_num = pdev->id;
spi-ep93xx.c:889:	master->num_chipselect = info->num_chipselect;
spi-ep93xx.c:890:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-ep93xx.c:891:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
spi-ep93xx.c:897:	espi->clk = devm_clk_get(&pdev->dev, NULL);
spi-ep93xx.c:898:	if (IS_ERR(espi->clk)) {
spi-ep93xx.c:899:		dev_err(&pdev->dev, "unable to get spi clock\n");
spi-ep93xx.c:900:		error = PTR_ERR(espi->clk);
spi-ep93xx.c:904:	init_completion(&espi->wait);
spi-ep93xx.c:910:	master->max_speed_hz = clk_get_rate(espi->clk) / 2;
spi-ep93xx.c:911:	master->min_speed_hz = clk_get_rate(espi->clk) / (254 * 256);
spi-ep93xx.c:912:	espi->pdev = pdev;
spi-ep93xx.c:914:	espi->sspdr_phys = res->start + SSPDR;
spi-ep93xx.c:916:	espi->regs_base = devm_ioremap_resource(&pdev->dev, res);
spi-ep93xx.c:917:	if (IS_ERR(espi->regs_base)) {
spi-ep93xx.c:918:		error = PTR_ERR(espi->regs_base);
spi-ep93xx.c:922:	error = devm_request_irq(&pdev->dev, irq, ep93xx_spi_interrupt,
spi-ep93xx.c:923:				0, "ep93xx-spi", espi);
spi-ep93xx.c:925:		dev_err(&pdev->dev, "failed to request irq\n");
spi-ep93xx.c:929:	if (info->use_dma && ep93xx_spi_setup_dma(espi))
spi-ep93xx.c:930:		dev_warn(&pdev->dev, "DMA setup failed. Falling back to PIO\n");
spi-ep93xx.c:935:	error = devm_spi_register_master(&pdev->dev, master);
spi-ep93xx.c:937:		dev_err(&pdev->dev, "failed to register SPI master\n");
spi-ep93xx.c:941:	dev_info(&pdev->dev, "EP93xx SPI Controller at 0x%08lx irq %d\n",
spi-ep93xx.c:942:		 (unsigned long)res->start, irq);
spi-ep93xx.c:966:		.name	= "ep93xx-spi",
spi-ep93xx.c:976:MODULE_ALIAS("platform:ep93xx-spi");
 spi-bitbang.o
.spi-bitbang.o.cmd:1:cmd_drivers/spi/spi-bitbang.o := arm-zlgmcu-linux-uclibcgnueabi-gcc -Wp,-MD,drivers/spi/.spi-bitbang.o.d  -nostdinc -isystem /data/TKM07010C/arm-zlgmcu-linux-uclibcgnueabi/bin/../lib/gcc/arm-zlgmcu-linux-uclibcgnueabi/4.9.4/include -I./arch/arm/include -Iarch/arm/include/generated/uapi -Iarch/arm/include/generated  -Iinclude -I./arch/arm/include/uapi -Iarch/arm/include/generated/uapi -I./include/uapi -Iinclude/generated/uapi -include ./include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-zmp110x/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -fno-PIE -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp -marm -D__LINUX_ARM_ARCH__=5 -march=armv5te -mtune=arm9tdmi -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-maybe-uninitialized -O2 --param=allow-store-data-races=0 -DCC_HAVE_ASM_GOTO -Wframe-larger-than=4096 -fno-stack-protector -Wno-unused-but-set-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-merge-all-constants -fmerge-constants -fno-stack-check -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time    -D"KBUILD_STR(s)=$(pound)s" -D"KBUILD_BASENAME=KBUILD_STR(spi_bitbang)"  -D"KBUILD_MODNAME=KBUILD_STR(spi_bitbang)" -c -o drivers/spi/spi-bitbang.o drivers/spi/spi-bitbang.c
.spi-bitbang.o.cmd:3:source_drivers/spi/spi-bitbang.o := drivers/spi/spi-bitbang.c
.spi-bitbang.o.cmd:5:deps_drivers/spi/spi-bitbang.o := \
.spi-bitbang.o.cmd:27:  include/linux/compiler-gcc.h \
.spi-bitbang.o.cmd:34:  include/asm-generic/int-ll64.h \
.spi-bitbang.o.cmd:35:  include/uapi/asm-generic/int-ll64.h \
.spi-bitbang.o.cmd:37:  include/asm-generic/bitsperlong.h \
.spi-bitbang.o.cmd:39:  include/uapi/asm-generic/bitsperlong.h \
.spi-bitbang.o.cmd:44:  include/uapi/asm-generic/posix_types.h \
.spi-bitbang.o.cmd:71:  /data/TKM07010C/arm-zlgmcu-linux-uclibcgnueabi/lib/gcc/arm-zlgmcu-linux-uclibcgnueabi/4.9.4/include/stdarg.h \
.spi-bitbang.o.cmd:88:  include/asm-generic/irqflags.h \
.spi-bitbang.o.cmd:96:  include/asm-generic/bitops/non-atomic.h \
.spi-bitbang.o.cmd:97:  include/asm-generic/bitops/fls64.h \
.spi-bitbang.o.cmd:98:  include/asm-generic/bitops/sched.h \
.spi-bitbang.o.cmd:99:  include/asm-generic/bitops/hweight.h \
.spi-bitbang.o.cmd:100:  include/asm-generic/bitops/arch_hweight.h \
.spi-bitbang.o.cmd:101:  include/asm-generic/bitops/const_hweight.h \
.spi-bitbang.o.cmd:102:  include/asm-generic/bitops/lock.h \
.spi-bitbang.o.cmd:103:  include/asm-generic/bitops/le.h \
.spi-bitbang.o.cmd:112:  include/asm-generic/bitops/ext2-atomic-setbit.h \
.spi-bitbang.o.cmd:141:  include/asm-generic/bug.h \
.spi-bitbang.o.cmd:145:  include/asm-generic/preempt.h \
.spi-bitbang.o.cmd:166:  arch/arm/include/asm/pgtable-2level-types.h \
.spi-bitbang.o.cmd:178:  include/asm-generic/memory_model.h \
.spi-bitbang.o.cmd:184:  include/asm-generic/getorder.h \
.spi-bitbang.o.cmd:208:  include/asm-generic/cmpxchg-local.h \
.spi-bitbang.o.cmd:209:  include/asm-generic/cmpxchg.h \
.spi-bitbang.o.cmd:210:  include/asm-generic/atomic64.h \
.spi-bitbang.o.cmd:211:  include/asm-generic/atomic-long.h \
.spi-bitbang.o.cmd:233:  include/asm-generic/param.h \
.spi-bitbang.o.cmd:235:  include/uapi/asm-generic/param.h \
.spi-bitbang.o.cmd:284:  include/uapi/asm-generic/errno.h \
.spi-bitbang.o.cmd:285:  include/uapi/asm-generic/errno-base.h \
.spi-bitbang.o.cmd:289:  include/asm-generic/percpu.h \
.spi-bitbang.o.cmd:290:  include/linux/percpu-defs.h \
.spi-bitbang.o.cmd:301:  arch/arm/mach-zmp110x/include/mach/irqs.h \
.spi-bitbang.o.cmd:324:  include/asm-generic/current.h \
.spi-bitbang.o.cmd:382:  include/linux/pageblock-flags.h \
.spi-bitbang.o.cmd:385:  include/linux/page-flags-layout.h \
.spi-bitbang.o.cmd:396:  include/asm-generic/rwsem.h \
.spi-bitbang.o.cmd:403:  include/asm-generic/topology.h \
.spi-bitbang.o.cmd:415:  include/uapi/linux/elf-em.h \
.spi-bitbang.o.cmd:433:  include/asm-generic/module.h \
.spi-bitbang.o.cmd:482:  include/linux/radix-tree.h \
.spi-bitbang.o.cmd:489:  include/linux/percpu-rwsem.h \
.spi-bitbang.o.cmd:498:  include/asm-generic/ioctl.h \
.spi-bitbang.o.cmd:499:  include/uapi/asm-generic/ioctl.h \
.spi-bitbang.o.cmd:513:  include/uapi/asm-generic/fcntl.h \
.spi-bitbang.o.cmd:522:  include/linux/pinctrl/pinctrl-state.h \
.spi-bitbang.o.cmd:614:  include/asm-generic/cputime.h \
.spi-bitbang.o.cmd:615:  include/asm-generic/cputime_jiffies.h \
.spi-bitbang.o.cmd:621:  include/uapi/asm-generic/ipcbuf.h \
.spi-bitbang.o.cmd:623:  include/uapi/asm-generic/sembuf.h \
.spi-bitbang.o.cmd:627:  include/uapi/asm-generic/shmbuf.h \
.spi-bitbang.o.cmd:634:  include/uapi/asm-generic/signal-defs.h \
.spi-bitbang.o.cmd:637:  include/asm-generic/siginfo.h \
.spi-bitbang.o.cmd:638:  include/uapi/asm-generic/siginfo.h \
.spi-bitbang.o.cmd:651:  include/asm-generic/resource.h \
.spi-bitbang.o.cmd:652:  include/uapi/asm-generic/resource.h \
.spi-bitbang.o.cmd:657:  include/linux/cgroup-defs.h \
.spi-bitbang.o.cmd:658:  include/linux/percpu-refcount.h \
.spi-bitbang.o.cmd:684:  arch/arm/include/asm/proc-fns.h \
.spi-bitbang.o.cmd:685:  arch/arm/include/asm/glue-proc.h \
.spi-bitbang.o.cmd:705:  include/asm-generic/pgtable-nopud.h \
.spi-bitbang.o.cmd:706:  arch/arm/include/asm/pgtable-hwdef.h \
.spi-bitbang.o.cmd:707:  arch/arm/include/asm/pgtable-2level-hwdef.h \
.spi-bitbang.o.cmd:719:  arch/arm/include/asm/pgtable-2level.h \
.spi-bitbang.o.cmd:720:  include/asm-generic/pgtable.h \
.spi-bitbang.o.cmd:723:  include/linux/page-flags.h \
.spi-bitbang.o.cmd:742:  include/asm-generic/pci_iomap.h \
.spi-bitbang.o.cmd:749:  include/asm-generic/io.h \
.spi-bitbang.o.cmd:755:drivers/spi/spi-bitbang.o: $(deps_drivers/spi/spi-bitbang.o)
.spi-bitbang.o.cmd:757:$(deps_drivers/spi/spi-bitbang.o):
.spi-zmp.o.cmd:1:cmd_drivers/spi/spi-zmp.o := arm-zlgmcu-linux-uclibcgnueabi-gcc -Wp,-MD,drivers/spi/.spi-zmp.o.d  -nostdinc -isystem /data/TKM07010C/arm-zlgmcu-linux-uclibcgnueabi/bin/../lib/gcc/arm-zlgmcu-linux-uclibcgnueabi/4.9.4/include -I./arch/arm/include -Iarch/arm/include/generated/uapi -Iarch/arm/include/generated  -Iinclude -I./arch/arm/include/uapi -Iarch/arm/include/generated/uapi -I./include/uapi -Iinclude/generated/uapi -include ./include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-zmp110x/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -fno-PIE -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp -marm -D__LINUX_ARM_ARCH__=5 -march=armv5te -mtune=arm9tdmi -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-maybe-uninitialized -O2 --param=allow-store-data-races=0 -DCC_HAVE_ASM_GOTO -Wframe-larger-than=4096 -fno-stack-protector -Wno-unused-but-set-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-merge-all-constants -fmerge-constants -fno-stack-check -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time    -D"KBUILD_STR(s)=$(pound)s" -D"KBUILD_BASENAME=KBUILD_STR(spi_zmp)"  -D"KBUILD_MODNAME=KBUILD_STR(spi_zmp)" -c -o drivers/spi/spi-zmp.o drivers/spi/spi-zmp.c
.spi-zmp.o.cmd:3:source_drivers/spi/spi-zmp.o := drivers/spi/spi-zmp.c
.spi-zmp.o.cmd:5:deps_drivers/spi/spi-zmp.o := \
.spi-zmp.o.cmd:18:  include/linux/compiler-gcc.h \
.spi-zmp.o.cmd:25:  include/asm-generic/int-ll64.h \
.spi-zmp.o.cmd:26:  include/uapi/asm-generic/int-ll64.h \
.spi-zmp.o.cmd:28:  include/asm-generic/bitsperlong.h \
.spi-zmp.o.cmd:30:  include/uapi/asm-generic/bitsperlong.h \
.spi-zmp.o.cmd:35:  include/uapi/asm-generic/posix_types.h \
.spi-zmp.o.cmd:75:  /data/TKM07010C/arm-zlgmcu-linux-uclibcgnueabi/lib/gcc/arm-zlgmcu-linux-uclibcgnueabi/4.9.4/include/stdarg.h \
.spi-zmp.o.cmd:92:  include/asm-generic/irqflags.h \
.spi-zmp.o.cmd:100:  include/asm-generic/bitops/non-atomic.h \
.spi-zmp.o.cmd:101:  include/asm-generic/bitops/fls64.h \
.spi-zmp.o.cmd:102:  include/asm-generic/bitops/sched.h \
.spi-zmp.o.cmd:103:  include/asm-generic/bitops/hweight.h \
.spi-zmp.o.cmd:104:  include/asm-generic/bitops/arch_hweight.h \
.spi-zmp.o.cmd:105:  include/asm-generic/bitops/const_hweight.h \
.spi-zmp.o.cmd:106:  include/asm-generic/bitops/lock.h \
.spi-zmp.o.cmd:107:  include/asm-generic/bitops/le.h \
.spi-zmp.o.cmd:116:  include/asm-generic/bitops/ext2-atomic-setbit.h \
.spi-zmp.o.cmd:142:  include/asm-generic/bug.h \
.spi-zmp.o.cmd:146:  include/asm-generic/preempt.h \
.spi-zmp.o.cmd:167:  arch/arm/include/asm/pgtable-2level-types.h \
.spi-zmp.o.cmd:179:  include/asm-generic/memory_model.h \
.spi-zmp.o.cmd:185:  include/asm-generic/getorder.h \
.spi-zmp.o.cmd:209:  include/asm-generic/cmpxchg-local.h \
.spi-zmp.o.cmd:210:  include/asm-generic/cmpxchg.h \
.spi-zmp.o.cmd:211:  include/asm-generic/atomic64.h \
.spi-zmp.o.cmd:212:  include/asm-generic/atomic-long.h \
.spi-zmp.o.cmd:234:  include/asm-generic/param.h \
.spi-zmp.o.cmd:236:  include/uapi/asm-generic/param.h \
.spi-zmp.o.cmd:285:  include/uapi/asm-generic/errno.h \
.spi-zmp.o.cmd:286:  include/uapi/asm-generic/errno-base.h \
.spi-zmp.o.cmd:290:  include/asm-generic/percpu.h \
.spi-zmp.o.cmd:291:  include/linux/percpu-defs.h \
.spi-zmp.o.cmd:302:  arch/arm/mach-zmp110x/include/mach/irqs.h \
.spi-zmp.o.cmd:325:  include/asm-generic/current.h \
.spi-zmp.o.cmd:347:  include/asm-generic/rwsem.h \
.spi-zmp.o.cmd:413:  include/linux/radix-tree.h \
.spi-zmp.o.cmd:420:  include/linux/percpu-rwsem.h \
.spi-zmp.o.cmd:429:  include/asm-generic/ioctl.h \
.spi-zmp.o.cmd:430:  include/uapi/asm-generic/ioctl.h \
.spi-zmp.o.cmd:459:  include/linux/pageblock-flags.h \
.spi-zmp.o.cmd:462:  include/linux/page-flags-layout.h \
.spi-zmp.o.cmd:471:  include/asm-generic/topology.h \
.spi-zmp.o.cmd:482:  include/uapi/asm-generic/fcntl.h \
.spi-zmp.o.cmd:494:  include/linux/pinctrl/pinctrl-state.h \
.spi-zmp.o.cmd:551:  include/uapi/linux/elf-em.h \
.spi-zmp.o.cmd:560:  include/asm-generic/module.h \
.spi-zmp.o.cmd:573:  include/asm-generic/pci_iomap.h \
.spi-zmp.o.cmd:580:  include/asm-generic/io.h \
.spi-zmp.o.cmd:588:  include/asm-generic/gpio.h \
.spi-zmp.o.cmd:600:  include/asm-generic/irq_regs.h \
.spi-zmp.o.cmd:689:  include/asm-generic/cputime.h \
.spi-zmp.o.cmd:690:  include/asm-generic/cputime_jiffies.h \
.spi-zmp.o.cmd:696:  include/uapi/asm-generic/ipcbuf.h \
.spi-zmp.o.cmd:698:  include/uapi/asm-generic/sembuf.h \
.spi-zmp.o.cmd:702:  include/uapi/asm-generic/shmbuf.h \
.spi-zmp.o.cmd:709:  include/uapi/asm-generic/signal-defs.h \
.spi-zmp.o.cmd:712:  include/asm-generic/siginfo.h \
.spi-zmp.o.cmd:713:  include/uapi/asm-generic/siginfo.h \
.spi-zmp.o.cmd:726:  include/asm-generic/resource.h \
.spi-zmp.o.cmd:727:  include/uapi/asm-generic/resource.h \
.spi-zmp.o.cmd:732:  include/linux/cgroup-defs.h \
.spi-zmp.o.cmd:733:  include/linux/percpu-refcount.h \
.spi-zmp.o.cmd:758:  arch/arm/include/asm/proc-fns.h \
.spi-zmp.o.cmd:759:  arch/arm/include/asm/glue-proc.h \
.spi-zmp.o.cmd:779:  include/asm-generic/pgtable-nopud.h \
.spi-zmp.o.cmd:780:  arch/arm/include/asm/pgtable-hwdef.h \
.spi-zmp.o.cmd:781:  arch/arm/include/asm/pgtable-2level-hwdef.h \
.spi-zmp.o.cmd:793:  arch/arm/include/asm/pgtable-2level.h \
.spi-zmp.o.cmd:794:  include/asm-generic/pgtable.h \
.spi-zmp.o.cmd:796:  include/linux/page-flags.h \
.spi-zmp.o.cmd:809:  arch/arm/mach-zmp110x/include/mach/zmp_types.h \
.spi-zmp.o.cmd:810:  arch/arm/mach-zmp110x/include/mach/zmp_l2.h \
.spi-zmp.o.cmd:811:  arch/arm/mach-zmp110x/include/mach/map.h \
.spi-zmp.o.cmd:812:  include/linux/dma-mapping.h \
.spi-zmp.o.cmd:817:  include/linux/dma-attrs.h \
.spi-zmp.o.cmd:818:  include/linux/dma-direction.h \
.spi-zmp.o.cmd:819:  arch/arm/include/asm/dma-mapping.h \
.spi-zmp.o.cmd:820:  include/linux/dma-debug.h \
.spi-zmp.o.cmd:823:  include/asm-generic/dma-mapping-common.h \
.spi-zmp.o.cmd:825:  include/asm-generic/dma-coherent.h \
.spi-zmp.o.cmd:827:  drivers/spi/spi-zmp.h \
.spi-zmp.o.cmd:829:drivers/spi/spi-zmp.o: $(deps_drivers/spi/spi-zmp.o)
.spi-zmp.o.cmd:831:$(deps_drivers/spi/spi-zmp.o):
spi-imx.c:2: * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
spi-imx.c:18: * Boston, MA  02110-1301, USA.
spi-imx.c:25:#include <linux/dma-mapping.h>
spi-imx.c:42:#include <linux/platform_data/dma-imx.h>
spi-imx.c:43:#include <linux/platform_data/spi-imx.h>
spi-imx.c:119:	return d->devtype_data->devtype == IMX27_CSPI;
spi-imx.c:124:	return d->devtype_data->devtype == IMX35_CSPI;
spi-imx.c:129:	return (d->devtype_data->devtype == IMX51_ECSPI) ? 64 : 8;
spi-imx.c:135:	unsigned int val = readl(spi_imx->base + MXC_CSPIRXDATA);	\
spi-imx.c:137:	if (spi_imx->rx_buf) {						\
spi-imx.c:138:		*(type *)spi_imx->rx_buf = val;				\
spi-imx.c:139:		spi_imx->rx_buf += sizeof(type);			\
spi-imx.c:148:	if (spi_imx->tx_buf) {						\
spi-imx.c:149:		val = *(type *)spi_imx->tx_buf;				\
spi-imx.c:150:		spi_imx->tx_buf += sizeof(type);			\
spi-imx.c:153:	spi_imx->count -= sizeof(type);					\
spi-imx.c:155:	writel(val, spi_imx->base + MXC_CSPITXDATA);			\
spi-imx.c:204:	if (spi_imx->dma_is_inited
spi-imx.c:205:	    && transfer->len > spi_imx->rx_wml * sizeof(u32)
spi-imx.c:206:	    && transfer->len > spi_imx->tx_wml * sizeof(u32))
spi-imx.c:252:	 * there are two 4-bit dividers, the pre-divider divides by
spi-imx.c:253:	 * $pre, the post-divider by 2^$post
spi-imx.c:260:	post = fls(fin) - fls(fspi);
spi-imx.c:266:	post = max(4U, post) - 4;
spi-imx.c:273:	pre = DIV_ROUND_UP(fin, fspi << post) - 1;
spi-imx.c:295:	writel(val, spi_imx->base + MX51_ECSPI_INT);
spi-imx.c:300:	u32 reg = readl(spi_imx->base + MX51_ECSPI_CTRL);
spi-imx.c:302:	if (!spi_imx->usedma)
spi-imx.c:304:	else if (!spi_imx->dma_finished)
spi-imx.c:308:	writel(reg, spi_imx->base + MX51_ECSPI_CTRL);
spi-imx.c:316:	u32 clk = config->speed_hz, delay;
spi-imx.c:328:	ctrl |= mx51_ecspi_clkdiv(spi_imx->spi_clk, config->speed_hz, &clk);
spi-imx.c:331:	ctrl |= MX51_ECSPI_CTRL_CS(config->cs);
spi-imx.c:333:	ctrl |= (config->bpw - 1) << MX51_ECSPI_CTRL_BL_OFFSET;
spi-imx.c:335:	cfg |= MX51_ECSPI_CONFIG_SBBCTRL(config->cs);
spi-imx.c:337:	if (config->mode & SPI_CPHA)
spi-imx.c:338:		cfg |= MX51_ECSPI_CONFIG_SCLKPHA(config->cs);
spi-imx.c:340:		cfg &= ~MX51_ECSPI_CONFIG_SCLKPHA(config->cs);
spi-imx.c:342:	if (config->mode & SPI_CPOL) {
spi-imx.c:343:		cfg |= MX51_ECSPI_CONFIG_SCLKPOL(config->cs);
spi-imx.c:344:		cfg |= MX51_ECSPI_CONFIG_SCLKCTL(config->cs);
spi-imx.c:346:		cfg &= ~MX51_ECSPI_CONFIG_SCLKPOL(config->cs);
spi-imx.c:347:		cfg &= ~MX51_ECSPI_CONFIG_SCLKCTL(config->cs);
spi-imx.c:349:	if (config->mode & SPI_CS_HIGH)
spi-imx.c:350:		cfg |= MX51_ECSPI_CONFIG_SSBPOL(config->cs);
spi-imx.c:352:		cfg &= ~MX51_ECSPI_CONFIG_SSBPOL(config->cs);
spi-imx.c:354:	writel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);
spi-imx.c:355:	writel(cfg, spi_imx->base + MX51_ECSPI_CONFIG);
spi-imx.c:378:	if (spi_imx->dma_is_inited) {
spi-imx.c:379:		dma = readl(spi_imx->base + MX51_ECSPI_DMA);
spi-imx.c:381:		spi_imx->rxt_wml = spi_imx_get_fifosize(spi_imx) / 2;
spi-imx.c:382:		rx_wml_cfg = spi_imx->rx_wml << MX51_ECSPI_DMA_RX_WML_OFFSET;
spi-imx.c:383:		tx_wml_cfg = spi_imx->tx_wml << MX51_ECSPI_DMA_TX_WML_OFFSET;
spi-imx.c:384:		rxt_wml_cfg = spi_imx->rxt_wml << MX51_ECSPI_DMA_RXT_WML_OFFSET;
spi-imx.c:393:		writel(dma, spi_imx->base + MX51_ECSPI_DMA);
spi-imx.c:401:	return readl(spi_imx->base + MX51_ECSPI_STAT) & MX51_ECSPI_STAT_RR;
spi-imx.c:408:		readl(spi_imx->base + MXC_CSPIRXDATA);
spi-imx.c:443:	writel(val, spi_imx->base + MXC_CSPIINT);
spi-imx.c:450:	reg = readl(spi_imx->base + MXC_CSPICTRL);
spi-imx.c:452:	writel(reg, spi_imx->base + MXC_CSPICTRL);
spi-imx.c:459:	int cs = spi_imx->chipselect[config->cs];
spi-imx.c:461:	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, config->speed_hz) <<
spi-imx.c:465:		reg |= (config->bpw - 1) << MX35_CSPICTRL_BL_SHIFT;
spi-imx.c:468:		reg |= (config->bpw - 1) << MX31_CSPICTRL_BC_SHIFT;
spi-imx.c:471:	if (config->mode & SPI_CPHA)
spi-imx.c:473:	if (config->mode & SPI_CPOL)
spi-imx.c:475:	if (config->mode & SPI_CS_HIGH)
spi-imx.c:482:	writel(reg, spi_imx->base + MXC_CSPICTRL);
spi-imx.c:489:	return readl(spi_imx->base + MX31_CSPISTATUS) & MX31_STATUS_RR;
spi-imx.c:495:	while (readl(spi_imx->base + MX31_CSPISTATUS) & MX31_STATUS_RR)
spi-imx.c:496:		readl(spi_imx->base + MXC_CSPIRXDATA);
spi-imx.c:521:	writel(val, spi_imx->base + MXC_CSPIINT);
spi-imx.c:528:	reg = readl(spi_imx->base + MXC_CSPICTRL);
spi-imx.c:530:	writel(reg, spi_imx->base + MXC_CSPICTRL);
spi-imx.c:537:	int cs = spi_imx->chipselect[config->cs];
spi-imx.c:540:	reg |= spi_imx_clkdiv_1(spi_imx->spi_clk, config->speed_hz, max) <<
spi-imx.c:542:	reg |= config->bpw - 1;
spi-imx.c:544:	if (config->mode & SPI_CPHA)
spi-imx.c:546:	if (config->mode & SPI_CPOL)
spi-imx.c:548:	if (config->mode & SPI_CS_HIGH)
spi-imx.c:553:	writel(reg, spi_imx->base + MXC_CSPICTRL);
spi-imx.c:560:	return readl(spi_imx->base + MXC_CSPIINT) & MX21_INTREG_RR;
spi-imx.c:565:	writel(1, spi_imx->base + MXC_RESET);
spi-imx.c:588:	writel(val, spi_imx->base + MXC_CSPIINT);
spi-imx.c:595:	reg = readl(spi_imx->base + MXC_CSPICTRL);
spi-imx.c:597:	writel(reg, spi_imx->base + MXC_CSPICTRL);
spi-imx.c:605:	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, config->speed_hz) <<
spi-imx.c:607:	reg |= config->bpw - 1;
spi-imx.c:609:	if (config->mode & SPI_CPHA)
spi-imx.c:611:	if (config->mode & SPI_CPOL)
spi-imx.c:614:	writel(reg, spi_imx->base + MXC_CSPICTRL);
spi-imx.c:621:	return readl(spi_imx->base + MXC_CSPIINT) & MX1_INTREG_RR;
spi-imx.c:626:	writel(1, spi_imx->base + MXC_RESET);
spi-imx.c:687:		.name = "imx1-cspi",
spi-imx.c:690:		.name = "imx21-cspi",
spi-imx.c:693:		.name = "imx27-cspi",
spi-imx.c:696:		.name = "imx31-cspi",
spi-imx.c:699:		.name = "imx35-cspi",
spi-imx.c:702:		.name = "imx51-ecspi",
spi-imx.c:710:	{ .compatible = "fsl,imx1-cspi", .data = &imx1_cspi_devtype_data, },
spi-imx.c:711:	{ .compatible = "fsl,imx21-cspi", .data = &imx21_cspi_devtype_data, },
spi-imx.c:712:	{ .compatible = "fsl,imx27-cspi", .data = &imx27_cspi_devtype_data, },
spi-imx.c:713:	{ .compatible = "fsl,imx31-cspi", .data = &imx31_cspi_devtype_data, },
spi-imx.c:714:	{ .compatible = "fsl,imx35-cspi", .data = &imx35_cspi_devtype_data, },
spi-imx.c:715:	{ .compatible = "fsl,imx51-ecspi", .data = &imx51_ecspi_devtype_data, },
spi-imx.c:722:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
spi-imx.c:723:	int gpio = spi_imx->chipselect[spi->chip_select];
spi-imx.c:725:	int dev_is_lowactive = !(spi->mode & SPI_CS_HIGH);
spi-imx.c:735:	while (spi_imx->txfifo < spi_imx_get_fifosize(spi_imx)) {
spi-imx.c:736:		if (!spi_imx->count)
spi-imx.c:738:		spi_imx->tx(spi_imx);
spi-imx.c:739:		spi_imx->txfifo++;
spi-imx.c:742:	spi_imx->devtype_data->trigger(spi_imx);
spi-imx.c:749:	while (spi_imx->devtype_data->rx_available(spi_imx)) {
spi-imx.c:750:		spi_imx->rx(spi_imx);
spi-imx.c:751:		spi_imx->txfifo--;
spi-imx.c:754:	if (spi_imx->count) {
spi-imx.c:759:	if (spi_imx->txfifo) {
spi-imx.c:763:		spi_imx->devtype_data->intctrl(
spi-imx.c:768:	spi_imx->devtype_data->intctrl(spi_imx, 0);
spi-imx.c:769:	complete(&spi_imx->xfer_done);
spi-imx.c:777:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
spi-imx.c:780:	config.bpw = t ? t->bits_per_word : spi->bits_per_word;
spi-imx.c:781:	config.speed_hz  = t ? t->speed_hz : spi->max_speed_hz;
spi-imx.c:782:	config.mode = spi->mode;
spi-imx.c:783:	config.cs = spi->chip_select;
spi-imx.c:786:		config.speed_hz = spi->max_speed_hz;
spi-imx.c:788:		config.bpw = spi->bits_per_word;
spi-imx.c:792:		spi_imx->rx = spi_imx_buf_rx_u8;
spi-imx.c:793:		spi_imx->tx = spi_imx_buf_tx_u8;
spi-imx.c:795:		spi_imx->rx = spi_imx_buf_rx_u16;
spi-imx.c:796:		spi_imx->tx = spi_imx_buf_tx_u16;
spi-imx.c:798:		spi_imx->rx = spi_imx_buf_rx_u32;
spi-imx.c:799:		spi_imx->tx = spi_imx_buf_tx_u32;
spi-imx.c:802:	spi_imx->devtype_data->config(spi_imx, &config);
spi-imx.c:809:	struct spi_master *master = spi_imx->bitbang.master;
spi-imx.c:811:	if (master->dma_rx) {
spi-imx.c:812:		dma_release_channel(master->dma_rx);
spi-imx.c:813:		master->dma_rx = NULL;
spi-imx.c:816:	if (master->dma_tx) {
spi-imx.c:817:		dma_release_channel(master->dma_tx);
spi-imx.c:818:		master->dma_tx = NULL;
spi-imx.c:821:	spi_imx->dma_is_inited = 0;
spi-imx.c:836:	master->dma_tx = dma_request_slave_channel(dev, "tx");
spi-imx.c:837:	if (!master->dma_tx) {
spi-imx.c:839:		ret = -EINVAL;
spi-imx.c:844:	slave_config.dst_addr = res->start + MXC_CSPITXDATA;
spi-imx.c:847:	ret = dmaengine_slave_config(master->dma_tx, &slave_config);
spi-imx.c:854:	master->dma_rx = dma_request_slave_channel(dev, "rx");
spi-imx.c:855:	if (!master->dma_rx) {
spi-imx.c:857:		ret = -EINVAL;
spi-imx.c:862:	slave_config.src_addr = res->start + MXC_CSPIRXDATA;
spi-imx.c:865:	ret = dmaengine_slave_config(master->dma_rx, &slave_config);
spi-imx.c:871:	init_completion(&spi_imx->dma_rx_completion);
spi-imx.c:872:	init_completion(&spi_imx->dma_tx_completion);
spi-imx.c:873:	master->can_dma = spi_imx_can_dma;
spi-imx.c:874:	master->max_dma_len = MAX_SDMA_BD_BYTES;
spi-imx.c:875:	spi_imx->bitbang.master->flags = SPI_MASTER_MUST_RX |
spi-imx.c:877:	spi_imx->tx_wml = spi_imx_get_fifosize(spi_imx) / 2;
spi-imx.c:878:	spi_imx->rx_wml = spi_imx_get_fifosize(spi_imx) / 2;
spi-imx.c:879:	spi_imx->dma_is_inited = 1;
spi-imx.c:891:	complete(&spi_imx->dma_rx_completion);
spi-imx.c:898:	complete(&spi_imx->dma_tx_completion);
spi-imx.c:909:	struct spi_master *master = spi_imx->bitbang.master;
spi-imx.c:910:	struct sg_table *tx = &transfer->tx_sg, *rx = &transfer->rx_sg;
spi-imx.c:913:		desc_tx = dmaengine_prep_slave_sg(master->dma_tx,
spi-imx.c:914:					tx->sgl, tx->nents, DMA_MEM_TO_DEV,
spi-imx.c:919:		desc_tx->callback = spi_imx_dma_tx_callback;
spi-imx.c:920:		desc_tx->callback_param = (void *)spi_imx;
spi-imx.c:925:		desc_rx = dmaengine_prep_slave_sg(master->dma_rx,
spi-imx.c:926:					rx->sgl, rx->nents, DMA_DEV_TO_MEM,
spi-imx.c:931:		desc_rx->callback = spi_imx_dma_rx_callback;
spi-imx.c:932:		desc_rx->callback_param = (void *)spi_imx;
spi-imx.c:936:	reinit_completion(&spi_imx->dma_rx_completion);
spi-imx.c:937:	reinit_completion(&spi_imx->dma_tx_completion);
spi-imx.c:940:	spi_imx->dma_finished = 0;
spi-imx.c:942:	dma = readl(spi_imx->base + MX51_ECSPI_DMA);
spi-imx.c:945:	left = transfer->len % spi_imx->rxt_wml;
spi-imx.c:948:				spi_imx->base + MX51_ECSPI_DMA);
spi-imx.c:949:	spi_imx->devtype_data->trigger(spi_imx);
spi-imx.c:951:	dma_async_issue_pending(master->dma_tx);
spi-imx.c:952:	dma_async_issue_pending(master->dma_rx);
spi-imx.c:954:	timeout = wait_for_completion_timeout(&spi_imx->dma_tx_completion,
spi-imx.c:958:			dev_driver_string(&master->dev),
spi-imx.c:959:			dev_name(&master->dev));
spi-imx.c:960:		dmaengine_terminate_all(master->dma_tx);
spi-imx.c:963:				&spi_imx->dma_rx_completion, IMX_DMA_TIMEOUT);
spi-imx.c:966:				dev_driver_string(&master->dev),
spi-imx.c:967:				dev_name(&master->dev));
spi-imx.c:968:			spi_imx->devtype_data->reset(spi_imx);
spi-imx.c:969:			dmaengine_terminate_all(master->dma_rx);
spi-imx.c:972:		       spi_imx->rxt_wml << MX51_ECSPI_DMA_RXT_WML_OFFSET,
spi-imx.c:973:		       spi_imx->base + MX51_ECSPI_DMA);
spi-imx.c:976:	spi_imx->dma_finished = 1;
spi-imx.c:977:	spi_imx->devtype_data->trigger(spi_imx);
spi-imx.c:980:		ret = -ETIMEDOUT;
spi-imx.c:982:		ret = transfer->len;
spi-imx.c:988:		     dev_driver_string(&master->dev),
spi-imx.c:989:		     dev_name(&master->dev));
spi-imx.c:990:	return -EAGAIN;
spi-imx.c:996:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
spi-imx.c:998:	spi_imx->tx_buf = transfer->tx_buf;
spi-imx.c:999:	spi_imx->rx_buf = transfer->rx_buf;
spi-imx.c:1000:	spi_imx->count = transfer->len;
spi-imx.c:1001:	spi_imx->txfifo = 0;
spi-imx.c:1003:	reinit_completion(&spi_imx->xfer_done);
spi-imx.c:1007:	spi_imx->devtype_data->intctrl(spi_imx, MXC_INT_TE);
spi-imx.c:1009:	wait_for_completion(&spi_imx->xfer_done);
spi-imx.c:1011:	return transfer->len;
spi-imx.c:1018:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
spi-imx.c:1020:	if (spi_imx->bitbang.master->can_dma &&
spi-imx.c:1021:	    spi_imx_can_dma(spi_imx->bitbang.master, spi, transfer)) {
spi-imx.c:1022:		spi_imx->usedma = true;
spi-imx.c:1024:		if (ret != -EAGAIN)
spi-imx.c:1027:	spi_imx->usedma = false;
spi-imx.c:1034:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
spi-imx.c:1035:	int gpio = spi_imx->chipselect[spi->chip_select];
spi-imx.c:1037:	dev_dbg(&spi->dev, "%s: mode %d, %u bpw, %d hz\n", __func__,
spi-imx.c:1038:		 spi->mode, spi->bits_per_word, spi->max_speed_hz);
spi-imx.c:1041:		gpio_direction_output(gpio, spi->mode & SPI_CS_HIGH ? 0 : 1);
spi-imx.c:1058:	ret = clk_enable(spi_imx->clk_per);
spi-imx.c:1062:	ret = clk_enable(spi_imx->clk_ipg);
spi-imx.c:1064:		clk_disable(spi_imx->clk_per);
spi-imx.c:1076:	clk_disable(spi_imx->clk_ipg);
spi-imx.c:1077:	clk_disable(spi_imx->clk_per);
spi-imx.c:1083:	struct device_node *np = pdev->dev.of_node;
spi-imx.c:1085:			of_match_device(spi_imx_dt_ids, &pdev->dev);
spi-imx.c:1087:			dev_get_platdata(&pdev->dev);
spi-imx.c:1094:		dev_err(&pdev->dev, "can't get the platform data\n");
spi-imx.c:1095:		return -EINVAL;
spi-imx.c:1098:	ret = of_property_read_u32(np, "fsl,spi-num-chipselects", &num_cs);
spi-imx.c:1101:			num_cs = mxc_platform_info->num_chipselect;
spi-imx.c:1106:	master = spi_alloc_master(&pdev->dev,
spi-imx.c:1109:		return -ENOMEM;
spi-imx.c:1113:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);
spi-imx.c:1114:	master->bus_num = pdev->id;
spi-imx.c:1115:	master->num_chipselect = num_cs;
spi-imx.c:1118:	spi_imx->bitbang.master = master;
spi-imx.c:1120:	for (i = 0; i < master->num_chipselect; i++) {
spi-imx.c:1121:		int cs_gpio = of_get_named_gpio(np, "cs-gpios", i);
spi-imx.c:1123:			cs_gpio = mxc_platform_info->chipselect[i];
spi-imx.c:1125:		spi_imx->chipselect[i] = cs_gpio;
spi-imx.c:1129:		ret = devm_gpio_request(&pdev->dev, spi_imx->chipselect[i],
spi-imx.c:1132:			dev_err(&pdev->dev, "can't get cs gpios\n");
spi-imx.c:1137:	spi_imx->bitbang.chipselect = spi_imx_chipselect;
spi-imx.c:1138:	spi_imx->bitbang.setup_transfer = spi_imx_setupxfer;
spi-imx.c:1139:	spi_imx->bitbang.txrx_bufs = spi_imx_transfer;
spi-imx.c:1140:	spi_imx->bitbang.master->setup = spi_imx_setup;
spi-imx.c:1141:	spi_imx->bitbang.master->cleanup = spi_imx_cleanup;
spi-imx.c:1142:	spi_imx->bitbang.master->prepare_message = spi_imx_prepare_message;
spi-imx.c:1143:	spi_imx->bitbang.master->unprepare_message = spi_imx_unprepare_message;
spi-imx.c:1144:	spi_imx->bitbang.master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-imx.c:1146:	init_completion(&spi_imx->xfer_done);
spi-imx.c:1148:	spi_imx->devtype_data = of_id ? of_id->data :
spi-imx.c:1149:		(struct spi_imx_devtype_data *) pdev->id_entry->driver_data;
spi-imx.c:1152:	spi_imx->base = devm_ioremap_resource(&pdev->dev, res);
spi-imx.c:1153:	if (IS_ERR(spi_imx->base)) {
spi-imx.c:1154:		ret = PTR_ERR(spi_imx->base);
spi-imx.c:1164:	ret = devm_request_irq(&pdev->dev, irq, spi_imx_isr, 0,
spi-imx.c:1165:			       dev_name(&pdev->dev), spi_imx);
spi-imx.c:1167:		dev_err(&pdev->dev, "can't get irq%d: %d\n", irq, ret);
spi-imx.c:1171:	spi_imx->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
spi-imx.c:1172:	if (IS_ERR(spi_imx->clk_ipg)) {
spi-imx.c:1173:		ret = PTR_ERR(spi_imx->clk_ipg);
spi-imx.c:1177:	spi_imx->clk_per = devm_clk_get(&pdev->dev, "per");
spi-imx.c:1178:	if (IS_ERR(spi_imx->clk_per)) {
spi-imx.c:1179:		ret = PTR_ERR(spi_imx->clk_per);
spi-imx.c:1183:	ret = clk_prepare_enable(spi_imx->clk_per);
spi-imx.c:1187:	ret = clk_prepare_enable(spi_imx->clk_ipg);
spi-imx.c:1191:	spi_imx->spi_clk = clk_get_rate(spi_imx->clk_per);
spi-imx.c:1196:	if (spi_imx->devtype_data == &imx51_ecspi_devtype_data
spi-imx.c:1197:	    && spi_imx_sdma_init(&pdev->dev, spi_imx, master, res))
spi-imx.c:1198:		dev_err(&pdev->dev, "dma setup error,use pio instead\n");
spi-imx.c:1200:	spi_imx->devtype_data->reset(spi_imx);
spi-imx.c:1202:	spi_imx->devtype_data->intctrl(spi_imx, 0);
spi-imx.c:1204:	master->dev.of_node = pdev->dev.of_node;
spi-imx.c:1205:	ret = spi_bitbang_start(&spi_imx->bitbang);
spi-imx.c:1207:		dev_err(&pdev->dev, "bitbang start failed with %d\n", ret);
spi-imx.c:1211:	dev_info(&pdev->dev, "probed\n");
spi-imx.c:1213:	clk_disable(spi_imx->clk_ipg);
spi-imx.c:1214:	clk_disable(spi_imx->clk_per);
spi-imx.c:1218:	clk_disable_unprepare(spi_imx->clk_ipg);
spi-imx.c:1220:	clk_disable_unprepare(spi_imx->clk_per);
spi-imx.c:1233:	spi_bitbang_stop(&spi_imx->bitbang);
spi-imx.c:1235:	ret = clk_enable(spi_imx->clk_per);
spi-imx.c:1239:	ret = clk_enable(spi_imx->clk_ipg);
spi-imx.c:1241:		clk_disable(spi_imx->clk_per);
spi-imx.c:1245:	writel(0, spi_imx->base + MXC_CSPICTRL);
spi-imx.c:1246:	clk_disable_unprepare(spi_imx->clk_ipg);
spi-imx.c:1247:	clk_disable_unprepare(spi_imx->clk_per);
spi-mt65xx.c:25:#include <linux/platform_data/spi-mt65xx.h>
spi-mt65xx.c:115:	{ .compatible = "mediatek,mt6589-spi", .data = (void *)&mt6589_compat },
spi-mt65xx.c:116:	{ .compatible = "mediatek,mt8135-spi", .data = (void *)&mt8135_compat },
spi-mt65xx.c:117:	{ .compatible = "mediatek,mt8173-spi", .data = (void *)&mt8173_compat },
spi-mt65xx.c:127:	reg_val = readl(mdata->base + SPI_CMD_REG);
spi-mt65xx.c:129:	writel(reg_val, mdata->base + SPI_CMD_REG);
spi-mt65xx.c:131:	reg_val = readl(mdata->base + SPI_CMD_REG);
spi-mt65xx.c:133:	writel(reg_val, mdata->base + SPI_CMD_REG);
spi-mt65xx.c:141:	struct spi_device *spi = msg->spi;
spi-mt65xx.c:142:	struct mtk_chip_config *chip_config = spi->controller_data;
spi-mt65xx.c:145:	cpha = spi->mode & SPI_CPHA ? 1 : 0;
spi-mt65xx.c:146:	cpol = spi->mode & SPI_CPOL ? 1 : 0;
spi-mt65xx.c:148:	reg_val = readl(mdata->base + SPI_CMD_REG);
spi-mt65xx.c:157:	writel(reg_val, mdata->base + SPI_CMD_REG);
spi-mt65xx.c:159:	reg_val = readl(mdata->base + SPI_CMD_REG);
spi-mt65xx.c:162:	if (chip_config->tx_mlsb)
spi-mt65xx.c:166:	if (chip_config->rx_mlsb)
spi-mt65xx.c:189:	writel(reg_val, mdata->base + SPI_CMD_REG);
spi-mt65xx.c:192:	if (mdata->dev_comp->need_pad_sel)
spi-mt65xx.c:193:		writel(mdata->pad_sel[spi->chip_select],
spi-mt65xx.c:194:		       mdata->base + SPI_PAD_SEL_REG);
spi-mt65xx.c:202:	struct mtk_spi *mdata = spi_master_get_devdata(spi->master);
spi-mt65xx.c:204:	reg_val = readl(mdata->base + SPI_CMD_REG);
spi-mt65xx.c:207:		writel(reg_val, mdata->base + SPI_CMD_REG);
spi-mt65xx.c:210:		writel(reg_val, mdata->base + SPI_CMD_REG);
spi-mt65xx.c:211:		mdata->state = MTK_SPI_IDLE;
spi-mt65xx.c:222:	spi_clk_hz = clk_get_rate(mdata->spi_clk);
spi-mt65xx.c:223:	if (xfer->speed_hz < spi_clk_hz / 2)
spi-mt65xx.c:224:		div = DIV_ROUND_UP(spi_clk_hz, xfer->speed_hz);
spi-mt65xx.c:231:	reg_val |= (((sck_time - 1) & 0xff) << SPI_CFG0_SCK_HIGH_OFFSET);
spi-mt65xx.c:232:	reg_val |= (((sck_time - 1) & 0xff) << SPI_CFG0_SCK_LOW_OFFSET);
spi-mt65xx.c:233:	reg_val |= (((cs_time - 1) & 0xff) << SPI_CFG0_CS_HOLD_OFFSET);
spi-mt65xx.c:234:	reg_val |= (((cs_time - 1) & 0xff) << SPI_CFG0_CS_SETUP_OFFSET);
spi-mt65xx.c:235:	writel(reg_val, mdata->base + SPI_CFG0_REG);
spi-mt65xx.c:237:	reg_val = readl(mdata->base + SPI_CFG1_REG);
spi-mt65xx.c:239:	reg_val |= (((cs_time - 1) & 0xff) << SPI_CFG1_CS_IDLE_OFFSET);
spi-mt65xx.c:240:	writel(reg_val, mdata->base + SPI_CFG1_REG);
spi-mt65xx.c:248:	packet_size = min_t(u32, mdata->xfer_len, MTK_SPI_PACKET_SIZE);
spi-mt65xx.c:249:	packet_loop = mdata->xfer_len / packet_size;
spi-mt65xx.c:251:	reg_val = readl(mdata->base + SPI_CFG1_REG);
spi-mt65xx.c:253:	reg_val |= (packet_size - 1) << SPI_CFG1_PACKET_LENGTH_OFFSET;
spi-mt65xx.c:254:	reg_val |= (packet_loop - 1) << SPI_CFG1_PACKET_LOOP_OFFSET;
spi-mt65xx.c:255:	writel(reg_val, mdata->base + SPI_CFG1_REG);
spi-mt65xx.c:263:	cmd = readl(mdata->base + SPI_CMD_REG);
spi-mt65xx.c:264:	if (mdata->state == MTK_SPI_IDLE)
spi-mt65xx.c:268:	writel(cmd, mdata->base + SPI_CMD_REG);
spi-mt65xx.c:288:	if (mdata->tx_sgl_len && mdata->rx_sgl_len) {
spi-mt65xx.c:289:		if (mdata->tx_sgl_len > mdata->rx_sgl_len) {
spi-mt65xx.c:290:			mult_delta = mtk_spi_get_mult_delta(mdata->rx_sgl_len);
spi-mt65xx.c:291:			mdata->xfer_len = mdata->rx_sgl_len - mult_delta;
spi-mt65xx.c:292:			mdata->rx_sgl_len = mult_delta;
spi-mt65xx.c:293:			mdata->tx_sgl_len -= mdata->xfer_len;
spi-mt65xx.c:295:			mult_delta = mtk_spi_get_mult_delta(mdata->tx_sgl_len);
spi-mt65xx.c:296:			mdata->xfer_len = mdata->tx_sgl_len - mult_delta;
spi-mt65xx.c:297:			mdata->tx_sgl_len = mult_delta;
spi-mt65xx.c:298:			mdata->rx_sgl_len -= mdata->xfer_len;
spi-mt65xx.c:300:	} else if (mdata->tx_sgl_len) {
spi-mt65xx.c:301:		mult_delta = mtk_spi_get_mult_delta(mdata->tx_sgl_len);
spi-mt65xx.c:302:		mdata->xfer_len = mdata->tx_sgl_len - mult_delta;
spi-mt65xx.c:303:		mdata->tx_sgl_len = mult_delta;
spi-mt65xx.c:304:	} else if (mdata->rx_sgl_len) {
spi-mt65xx.c:305:		mult_delta = mtk_spi_get_mult_delta(mdata->rx_sgl_len);
spi-mt65xx.c:306:		mdata->xfer_len = mdata->rx_sgl_len - mult_delta;
spi-mt65xx.c:307:		mdata->rx_sgl_len = mult_delta;
spi-mt65xx.c:316:	if (mdata->tx_sgl)
spi-mt65xx.c:317:		writel(xfer->tx_dma, mdata->base + SPI_TX_SRC_REG);
spi-mt65xx.c:318:	if (mdata->rx_sgl)
spi-mt65xx.c:319:		writel(xfer->rx_dma, mdata->base + SPI_RX_DST_REG);
spi-mt65xx.c:329:	mdata->cur_transfer = xfer;
spi-mt65xx.c:330:	mdata->xfer_len = xfer->len;
spi-mt65xx.c:334:	if (xfer->len % 4)
spi-mt65xx.c:335:		cnt = xfer->len / 4 + 1;
spi-mt65xx.c:337:		cnt = xfer->len / 4;
spi-mt65xx.c:338:	iowrite32_rep(mdata->base + SPI_TX_DATA_REG, xfer->tx_buf, cnt);
spi-mt65xx.c:352:	mdata->tx_sgl = NULL;
spi-mt65xx.c:353:	mdata->rx_sgl = NULL;
spi-mt65xx.c:354:	mdata->tx_sgl_len = 0;
spi-mt65xx.c:355:	mdata->rx_sgl_len = 0;
spi-mt65xx.c:356:	mdata->cur_transfer = xfer;
spi-mt65xx.c:360:	cmd = readl(mdata->base + SPI_CMD_REG);
spi-mt65xx.c:361:	if (xfer->tx_buf)
spi-mt65xx.c:363:	if (xfer->rx_buf)
spi-mt65xx.c:365:	writel(cmd, mdata->base + SPI_CMD_REG);
spi-mt65xx.c:367:	if (xfer->tx_buf)
spi-mt65xx.c:368:		mdata->tx_sgl = xfer->tx_sg.sgl;
spi-mt65xx.c:369:	if (xfer->rx_buf)
spi-mt65xx.c:370:		mdata->rx_sgl = xfer->rx_sg.sgl;
spi-mt65xx.c:372:	if (mdata->tx_sgl) {
spi-mt65xx.c:373:		xfer->tx_dma = sg_dma_address(mdata->tx_sgl);
spi-mt65xx.c:374:		mdata->tx_sgl_len = sg_dma_len(mdata->tx_sgl);
spi-mt65xx.c:376:	if (mdata->rx_sgl) {
spi-mt65xx.c:377:		xfer->rx_dma = sg_dma_address(mdata->rx_sgl);
spi-mt65xx.c:378:		mdata->rx_sgl_len = sg_dma_len(mdata->rx_sgl);
spi-mt65xx.c:393:	if (master->can_dma(master, spi, xfer))
spi-mt65xx.c:403:	return xfer->len > MTK_SPI_MAX_FIFO_SIZE;
spi-mt65xx.c:408:	struct mtk_spi *mdata = spi_master_get_devdata(spi->master);
spi-mt65xx.c:410:	if (!spi->controller_data)
spi-mt65xx.c:411:		spi->controller_data = (void *)&mtk_default_chip_info;
spi-mt65xx.c:413:	if (mdata->dev_comp->need_pad_sel && gpio_is_valid(spi->cs_gpio))
spi-mt65xx.c:414:		gpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
spi-mt65xx.c:424:	struct spi_transfer *trans = mdata->cur_transfer;
spi-mt65xx.c:426:	reg_val = readl(mdata->base + SPI_STATUS0_REG);
spi-mt65xx.c:428:		mdata->state = MTK_SPI_PAUSED;
spi-mt65xx.c:430:		mdata->state = MTK_SPI_IDLE;
spi-mt65xx.c:432:	if (!master->can_dma(master, master->cur_msg->spi, trans)) {
spi-mt65xx.c:433:		if (trans->rx_buf) {
spi-mt65xx.c:434:			if (mdata->xfer_len % 4)
spi-mt65xx.c:435:				cnt = mdata->xfer_len / 4 + 1;
spi-mt65xx.c:437:				cnt = mdata->xfer_len / 4;
spi-mt65xx.c:438:			ioread32_rep(mdata->base + SPI_RX_DATA_REG,
spi-mt65xx.c:439:				     trans->rx_buf, cnt);
spi-mt65xx.c:445:	if (mdata->tx_sgl)
spi-mt65xx.c:446:		trans->tx_dma += mdata->xfer_len;
spi-mt65xx.c:447:	if (mdata->rx_sgl)
spi-mt65xx.c:448:		trans->rx_dma += mdata->xfer_len;
spi-mt65xx.c:450:	if (mdata->tx_sgl && (mdata->tx_sgl_len == 0)) {
spi-mt65xx.c:451:		mdata->tx_sgl = sg_next(mdata->tx_sgl);
spi-mt65xx.c:452:		if (mdata->tx_sgl) {
spi-mt65xx.c:453:			trans->tx_dma = sg_dma_address(mdata->tx_sgl);
spi-mt65xx.c:454:			mdata->tx_sgl_len = sg_dma_len(mdata->tx_sgl);
spi-mt65xx.c:457:	if (mdata->rx_sgl && (mdata->rx_sgl_len == 0)) {
spi-mt65xx.c:458:		mdata->rx_sgl = sg_next(mdata->rx_sgl);
spi-mt65xx.c:459:		if (mdata->rx_sgl) {
spi-mt65xx.c:460:			trans->rx_dma = sg_dma_address(mdata->rx_sgl);
spi-mt65xx.c:461:			mdata->rx_sgl_len = sg_dma_len(mdata->rx_sgl);
spi-mt65xx.c:465:	if (!mdata->tx_sgl && !mdata->rx_sgl) {
spi-mt65xx.c:467:		cmd = readl(mdata->base + SPI_CMD_REG);
spi-mt65xx.c:470:		writel(cmd, mdata->base + SPI_CMD_REG);
spi-mt65xx.c:492:	master = spi_alloc_master(&pdev->dev, sizeof(*mdata));
spi-mt65xx.c:494:		dev_err(&pdev->dev, "failed to alloc spi master\n");
spi-mt65xx.c:495:		return -ENOMEM;
spi-mt65xx.c:498:	master->auto_runtime_pm = true;
spi-mt65xx.c:499:	master->dev.of_node = pdev->dev.of_node;
spi-mt65xx.c:500:	master->mode_bits = SPI_CPOL | SPI_CPHA;
spi-mt65xx.c:502:	master->set_cs = mtk_spi_set_cs;
spi-mt65xx.c:503:	master->prepare_message = mtk_spi_prepare_message;
spi-mt65xx.c:504:	master->transfer_one = mtk_spi_transfer_one;
spi-mt65xx.c:505:	master->can_dma = mtk_spi_can_dma;
spi-mt65xx.c:506:	master->setup = mtk_spi_setup;
spi-mt65xx.c:508:	of_id = of_match_node(mtk_spi_of_match, pdev->dev.of_node);
spi-mt65xx.c:510:		dev_err(&pdev->dev, "failed to probe of_node\n");
spi-mt65xx.c:511:		ret = -EINVAL;
spi-mt65xx.c:516:	mdata->dev_comp = of_id->data;
spi-mt65xx.c:517:	if (mdata->dev_comp->must_tx)
spi-mt65xx.c:518:		master->flags = SPI_MASTER_MUST_TX;
spi-mt65xx.c:520:	if (mdata->dev_comp->need_pad_sel) {
spi-mt65xx.c:521:		mdata->pad_num = of_property_count_u32_elems(
spi-mt65xx.c:522:			pdev->dev.of_node,
spi-mt65xx.c:523:			"mediatek,pad-select");
spi-mt65xx.c:524:		if (mdata->pad_num < 0) {
spi-mt65xx.c:525:			dev_err(&pdev->dev,
spi-mt65xx.c:526:				"No 'mediatek,pad-select' property\n");
spi-mt65xx.c:527:			ret = -EINVAL;
spi-mt65xx.c:531:		mdata->pad_sel = devm_kmalloc_array(&pdev->dev, mdata->pad_num,
spi-mt65xx.c:533:		if (!mdata->pad_sel) {
spi-mt65xx.c:534:			ret = -ENOMEM;
spi-mt65xx.c:538:		for (i = 0; i < mdata->pad_num; i++) {
spi-mt65xx.c:539:			of_property_read_u32_index(pdev->dev.of_node,
spi-mt65xx.c:540:						   "mediatek,pad-select",
spi-mt65xx.c:541:						   i, &mdata->pad_sel[i]);
spi-mt65xx.c:542:			if (mdata->pad_sel[i] > MT8173_SPI_MAX_PAD_SEL) {
spi-mt65xx.c:543:				dev_err(&pdev->dev, "wrong pad-sel[%d]: %u\n",
spi-mt65xx.c:544:					i, mdata->pad_sel[i]);
spi-mt65xx.c:545:				ret = -EINVAL;
spi-mt65xx.c:555:		ret = -ENODEV;
spi-mt65xx.c:556:		dev_err(&pdev->dev, "failed to determine base address\n");
spi-mt65xx.c:560:	mdata->base = devm_ioremap_resource(&pdev->dev, res);
spi-mt65xx.c:561:	if (IS_ERR(mdata->base)) {
spi-mt65xx.c:562:		ret = PTR_ERR(mdata->base);
spi-mt65xx.c:568:		dev_err(&pdev->dev, "failed to get irq (%d)\n", irq);
spi-mt65xx.c:573:	if (!pdev->dev.dma_mask)
spi-mt65xx.c:574:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
spi-mt65xx.c:576:	ret = devm_request_irq(&pdev->dev, irq, mtk_spi_interrupt,
spi-mt65xx.c:577:			       IRQF_TRIGGER_NONE, dev_name(&pdev->dev), master);
spi-mt65xx.c:579:		dev_err(&pdev->dev, "failed to register irq (%d)\n", ret);
spi-mt65xx.c:583:	mdata->parent_clk = devm_clk_get(&pdev->dev, "parent-clk");
spi-mt65xx.c:584:	if (IS_ERR(mdata->parent_clk)) {
spi-mt65xx.c:585:		ret = PTR_ERR(mdata->parent_clk);
spi-mt65xx.c:586:		dev_err(&pdev->dev, "failed to get parent-clk: %d\n", ret);
spi-mt65xx.c:590:	mdata->sel_clk = devm_clk_get(&pdev->dev, "sel-clk");
spi-mt65xx.c:591:	if (IS_ERR(mdata->sel_clk)) {
spi-mt65xx.c:592:		ret = PTR_ERR(mdata->sel_clk);
spi-mt65xx.c:593:		dev_err(&pdev->dev, "failed to get sel-clk: %d\n", ret);
spi-mt65xx.c:597:	mdata->spi_clk = devm_clk_get(&pdev->dev, "spi-clk");
spi-mt65xx.c:598:	if (IS_ERR(mdata->spi_clk)) {
spi-mt65xx.c:599:		ret = PTR_ERR(mdata->spi_clk);
spi-mt65xx.c:600:		dev_err(&pdev->dev, "failed to get spi-clk: %d\n", ret);
spi-mt65xx.c:604:	ret = clk_prepare_enable(mdata->spi_clk);
spi-mt65xx.c:606:		dev_err(&pdev->dev, "failed to enable spi_clk (%d)\n", ret);
spi-mt65xx.c:610:	ret = clk_set_parent(mdata->sel_clk, mdata->parent_clk);
spi-mt65xx.c:612:		dev_err(&pdev->dev, "failed to clk_set_parent (%d)\n", ret);
spi-mt65xx.c:616:	clk_disable_unprepare(mdata->spi_clk);
spi-mt65xx.c:618:	pm_runtime_enable(&pdev->dev);
spi-mt65xx.c:620:	ret = devm_spi_register_master(&pdev->dev, master);
spi-mt65xx.c:622:		dev_err(&pdev->dev, "failed to register master (%d)\n", ret);
spi-mt65xx.c:626:	if (mdata->dev_comp->need_pad_sel) {
spi-mt65xx.c:627:		if (mdata->pad_num != master->num_chipselect) {
spi-mt65xx.c:628:			dev_err(&pdev->dev,
spi-mt65xx.c:630:				mdata->pad_num, master->num_chipselect);
spi-mt65xx.c:631:			ret = -EINVAL;
spi-mt65xx.c:635:		if (!master->cs_gpios && master->num_chipselect > 1) {
spi-mt65xx.c:636:			dev_err(&pdev->dev,
spi-mt65xx.c:638:			ret = -EINVAL;
spi-mt65xx.c:642:		if (master->cs_gpios) {
spi-mt65xx.c:643:			for (i = 0; i < master->num_chipselect; i++) {
spi-mt65xx.c:644:				ret = devm_gpio_request(&pdev->dev,
spi-mt65xx.c:645:							master->cs_gpios[i],
spi-mt65xx.c:646:							dev_name(&pdev->dev));
spi-mt65xx.c:648:					dev_err(&pdev->dev,
spi-mt65xx.c:659:	clk_disable_unprepare(mdata->spi_clk);
spi-mt65xx.c:671:	pm_runtime_disable(&pdev->dev);
spi-mt65xx.c:691:		clk_disable_unprepare(mdata->spi_clk);
spi-mt65xx.c:703:		ret = clk_prepare_enable(mdata->spi_clk);
spi-mt65xx.c:712:		clk_disable_unprepare(mdata->spi_clk);
spi-mt65xx.c:724:	clk_disable_unprepare(mdata->spi_clk);
spi-mt65xx.c:735:	ret = clk_prepare_enable(mdata->spi_clk);
spi-mt65xx.c:753:		.name = "mtk-spi",
spi-mt65xx.c:766:MODULE_ALIAS("platform:mtk-spi");
.spi.o.cmd:1:cmd_drivers/spi/spi.o := arm-zlgmcu-linux-uclibcgnueabi-gcc -Wp,-MD,drivers/spi/.spi.o.d  -nostdinc -isystem /data/TKM07010C/arm-zlgmcu-linux-uclibcgnueabi/bin/../lib/gcc/arm-zlgmcu-linux-uclibcgnueabi/4.9.4/include -I./arch/arm/include -Iarch/arm/include/generated/uapi -Iarch/arm/include/generated  -Iinclude -I./arch/arm/include/uapi -Iarch/arm/include/generated/uapi -I./include/uapi -Iinclude/generated/uapi -include ./include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-zmp110x/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -fno-PIE -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp -marm -D__LINUX_ARM_ARCH__=5 -march=armv5te -mtune=arm9tdmi -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-maybe-uninitialized -O2 --param=allow-store-data-races=0 -DCC_HAVE_ASM_GOTO -Wframe-larger-than=4096 -fno-stack-protector -Wno-unused-but-set-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-merge-all-constants -fmerge-constants -fno-stack-check -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time    -D"KBUILD_STR(s)=$(pound)s" -D"KBUILD_BASENAME=KBUILD_STR(spi)"  -D"KBUILD_MODNAME=KBUILD_STR(spi)" -c -o drivers/spi/spi.o drivers/spi/spi.c
.spi.o.cmd:21:  /data/TKM07010C/arm-zlgmcu-linux-uclibcgnueabi/lib/gcc/arm-zlgmcu-linux-uclibcgnueabi/4.9.4/include/stdarg.h \
.spi.o.cmd:31:  include/linux/compiler-gcc.h \
.spi.o.cmd:38:  include/asm-generic/int-ll64.h \
.spi.o.cmd:39:  include/uapi/asm-generic/int-ll64.h \
.spi.o.cmd:41:  include/asm-generic/bitsperlong.h \
.spi.o.cmd:43:  include/uapi/asm-generic/bitsperlong.h \
.spi.o.cmd:48:  include/uapi/asm-generic/posix_types.h \
.spi.o.cmd:80:  include/asm-generic/irqflags.h \
.spi.o.cmd:88:  include/asm-generic/bitops/non-atomic.h \
.spi.o.cmd:89:  include/asm-generic/bitops/fls64.h \
.spi.o.cmd:90:  include/asm-generic/bitops/sched.h \
.spi.o.cmd:91:  include/asm-generic/bitops/hweight.h \
.spi.o.cmd:92:  include/asm-generic/bitops/arch_hweight.h \
.spi.o.cmd:93:  include/asm-generic/bitops/const_hweight.h \
.spi.o.cmd:94:  include/asm-generic/bitops/lock.h \
.spi.o.cmd:95:  include/asm-generic/bitops/le.h \
.spi.o.cmd:104:  include/asm-generic/bitops/ext2-atomic-setbit.h \
.spi.o.cmd:133:  include/asm-generic/bug.h \
.spi.o.cmd:163:  include/uapi/asm-generic/errno.h \
.spi.o.cmd:164:  include/uapi/asm-generic/errno-base.h \
.spi.o.cmd:169:  include/asm-generic/current.h \
.spi.o.cmd:190:  arch/arm/include/asm/pgtable-2level-types.h \
.spi.o.cmd:202:  include/asm-generic/memory_model.h \
.spi.o.cmd:208:  include/asm-generic/getorder.h \
.spi.o.cmd:230:  include/asm-generic/cmpxchg-local.h \
.spi.o.cmd:231:  include/asm-generic/cmpxchg.h \
.spi.o.cmd:232:  include/asm-generic/atomic64.h \
.spi.o.cmd:233:  include/asm-generic/atomic-long.h \
.spi.o.cmd:258:  include/asm-generic/preempt.h \
.spi.o.cmd:293:  include/asm-generic/param.h \
.spi.o.cmd:295:  include/uapi/asm-generic/param.h \
.spi.o.cmd:356:  include/linux/radix-tree.h \
.spi.o.cmd:362:  include/asm-generic/rwsem.h \
.spi.o.cmd:368:  include/linux/percpu-rwsem.h \
.spi.o.cmd:379:  include/asm-generic/percpu.h \
.spi.o.cmd:380:  include/linux/percpu-defs.h \
.spi.o.cmd:391:  include/asm-generic/ioctl.h \
.spi.o.cmd:392:  include/uapi/asm-generic/ioctl.h \
.spi.o.cmd:421:  include/linux/pageblock-flags.h \
.spi.o.cmd:424:  include/linux/page-flags-layout.h \
.spi.o.cmd:435:  include/asm-generic/topology.h \
.spi.o.cmd:446:  include/uapi/asm-generic/fcntl.h \
.spi.o.cmd:458:  include/linux/pinctrl/pinctrl-state.h \
.spi.o.cmd:470:  include/linux/dma-mapping.h \
.spi.o.cmd:474:  include/linux/dma-attrs.h \
.spi.o.cmd:475:  include/linux/dma-direction.h \
.spi.o.cmd:521:  include/asm-generic/resource.h \
.spi.o.cmd:522:  include/uapi/asm-generic/resource.h \
.spi.o.cmd:531:  arch/arm/include/asm/proc-fns.h \
.spi.o.cmd:532:  arch/arm/include/asm/glue-proc.h \
.spi.o.cmd:552:  include/asm-generic/pgtable-nopud.h \
.spi.o.cmd:553:  arch/arm/include/asm/pgtable-hwdef.h \
.spi.o.cmd:554:  arch/arm/include/asm/pgtable-2level-hwdef.h \
.spi.o.cmd:614:  include/asm-generic/cputime.h \
.spi.o.cmd:616:  include/asm-generic/cputime_jiffies.h \
.spi.o.cmd:622:  include/uapi/asm-generic/ipcbuf.h \
.spi.o.cmd:624:  include/uapi/asm-generic/sembuf.h \
.spi.o.cmd:628:  include/uapi/asm-generic/shmbuf.h \
.spi.o.cmd:635:  include/uapi/asm-generic/signal-defs.h \
.spi.o.cmd:638:  include/asm-generic/siginfo.h \
.spi.o.cmd:639:  include/uapi/asm-generic/siginfo.h \
.spi.o.cmd:658:  include/linux/cgroup-defs.h \
.spi.o.cmd:659:  include/linux/percpu-refcount.h \
.spi.o.cmd:660:  arch/arm/include/asm/pgtable-2level.h \
.spi.o.cmd:661:  include/asm-generic/pgtable.h \
.spi.o.cmd:664:  include/linux/page-flags.h \
.spi.o.cmd:683:  include/asm-generic/pci_iomap.h \
.spi.o.cmd:690:  include/asm-generic/io.h \
.spi.o.cmd:694:  arch/arm/include/asm/dma-mapping.h \
.spi.o.cmd:695:  include/linux/dma-debug.h \
.spi.o.cmd:698:  include/asm-generic/dma-mapping-common.h \
.spi.o.cmd:700:  include/asm-generic/dma-coherent.h \
.spi.o.cmd:752:  arch/arm/mach-zmp110x/include/mach/irqs.h \
.spi.o.cmd:754:  include/asm-generic/irq_regs.h \
.spi.o.cmd:761:  include/linux/clk/clk-conf.h \
.spi.o.cmd:782:  include/asm-generic/gpio.h \
.spi.o.cmd:801:  include/uapi/linux/elf-em.h \
.spi.o.cmd:812:  include/asm-generic/module.h \
.spi.o.cmd:866:  arch/arm/mach-zmp110x/include/mach/map.h \
Makefile:5:ccflags-$(CONFIG_SPI_DEBUG) := -DDEBUG
Makefile:7:# small core, mostly translating board-specific
Makefile:9:obj-$(CONFIG_SPI_MASTER)		+= spi.o
Makefile:10:obj-$(CONFIG_SPI_SPIDEV)		+= spidev.o
Makefile:13:obj-$(CONFIG_SPI_ALTERA)		+= spi-altera.o
Makefile:14:obj-$(CONFIG_SPI_ATMEL)			+= spi-atmel.o
Makefile:15:obj-$(CONFIG_SPI_ATH79)			+= spi-ath79.o
Makefile:16:obj-$(CONFIG_SPI_AU1550)		+= spi-au1550.o
Makefile:17:obj-$(CONFIG_SPI_BCM2835)		+= spi-bcm2835.o
Makefile:18:obj-$(CONFIG_SPI_BCM2835AUX)		+= spi-bcm2835aux.o
Makefile:19:obj-$(CONFIG_SPI_BCM53XX)		+= spi-bcm53xx.o
Makefile:20:obj-$(CONFIG_SPI_BCM63XX)		+= spi-bcm63xx.o
Makefile:21:obj-$(CONFIG_SPI_BCM63XX_HSSPI)		+= spi-bcm63xx-hsspi.o
Makefile:22:obj-$(CONFIG_SPI_BFIN5XX)		+= spi-bfin5xx.o
Makefile:23:obj-$(CONFIG_SPI_ADI_V3)                += spi-adi-v3.o
Makefile:24:obj-$(CONFIG_SPI_BFIN_SPORT)		+= spi-bfin-sport.o
Makefile:25:obj-$(CONFIG_SPI_BITBANG)		+= spi-bitbang.o
Makefile:26:obj-$(CONFIG_SPI_BUTTERFLY)		+= spi-butterfly.o
Makefile:27:obj-$(CONFIG_SPI_CADENCE)		+= spi-cadence.o
Makefile:28:obj-$(CONFIG_SPI_CLPS711X)		+= spi-clps711x.o
Makefile:29:obj-$(CONFIG_SPI_COLDFIRE_QSPI)		+= spi-coldfire-qspi.o
Makefile:30:obj-$(CONFIG_SPI_DAVINCI)		+= spi-davinci.o
Makefile:31:obj-$(CONFIG_SPI_DLN2)			+= spi-dln2.o
Makefile:32:obj-$(CONFIG_SPI_DESIGNWARE)		+= spi-dw.o
Makefile:33:obj-$(CONFIG_SPI_DW_MMIO)		+= spi-dw-mmio.o
Makefile:34:obj-$(CONFIG_SPI_DW_PCI)		+= spi-dw-midpci.o
Makefile:35:spi-dw-midpci-objs			:= spi-dw-pci.o spi-dw-mid.o
Makefile:36:obj-$(CONFIG_SPI_EFM32)			+= spi-efm32.o
Makefile:37:obj-$(CONFIG_SPI_EP93XX)		+= spi-ep93xx.o
Makefile:38:obj-$(CONFIG_SPI_FALCON)		+= spi-falcon.o
Makefile:39:obj-$(CONFIG_SPI_FSL_CPM)		+= spi-fsl-cpm.o
Makefile:40:obj-$(CONFIG_SPI_FSL_DSPI)		+= spi-fsl-dspi.o
Makefile:41:obj-$(CONFIG_SPI_FSL_LIB)		+= spi-fsl-lib.o
Makefile:42:obj-$(CONFIG_SPI_FSL_ESPI)		+= spi-fsl-espi.o
Makefile:43:obj-$(CONFIG_SPI_FSL_SPI)		+= spi-fsl-spi.o
Makefile:44:obj-$(CONFIG_SPI_GPIO)			+= spi-gpio.o
Makefile:45:obj-$(CONFIG_SPI_IMG_SPFI)		+= spi-img-spfi.o
Makefile:46:obj-$(CONFIG_SPI_IMX)			+= spi-imx.o
Makefile:47:obj-$(CONFIG_SPI_LM70_LLP)		+= spi-lm70llp.o
Makefile:48:obj-$(CONFIG_SPI_MESON_SPIFC)		+= spi-meson-spifc.o
Makefile:49:obj-$(CONFIG_SPI_MPC512x_PSC)		+= spi-mpc512x-psc.o
Makefile:50:obj-$(CONFIG_SPI_MPC52xx_PSC)		+= spi-mpc52xx-psc.o
Makefile:51:obj-$(CONFIG_SPI_MPC52xx)		+= spi-mpc52xx.o
Makefile:52:obj-$(CONFIG_SPI_MT65XX)                += spi-mt65xx.o
Makefile:53:obj-$(CONFIG_SPI_MXS)			+= spi-mxs.o
Makefile:54:obj-$(CONFIG_SPI_NUC900)		+= spi-nuc900.o
Makefile:55:obj-$(CONFIG_SPI_OC_TINY)		+= spi-oc-tiny.o
Makefile:56:obj-$(CONFIG_SPI_OCTEON)		+= spi-octeon.o
Makefile:57:obj-$(CONFIG_SPI_OMAP_UWIRE)		+= spi-omap-uwire.o
Makefile:58:obj-$(CONFIG_SPI_OMAP_100K)		+= spi-omap-100k.o
Makefile:59:obj-$(CONFIG_SPI_OMAP24XX)		+= spi-omap2-mcspi.o
Makefile:60:obj-$(CONFIG_SPI_TI_QSPI)		+= spi-ti-qspi.o
Makefile:61:obj-$(CONFIG_SPI_ORION)			+= spi-orion.o
Makefile:62:obj-$(CONFIG_SPI_PL022)			+= spi-pl022.o
Makefile:63:obj-$(CONFIG_SPI_PPC4xx)		+= spi-ppc4xx.o
Makefile:64:spi-pxa2xx-platform-objs		:= spi-pxa2xx.o
Makefile:65:spi-pxa2xx-platform-$(CONFIG_SPI_PXA2XX_DMA)	+= spi-pxa2xx-dma.o
Makefile:66:obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-platform.o
Makefile:67:obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
Makefile:68:obj-$(CONFIG_SPI_QUP)			+= spi-qup.o
Makefile:69:obj-$(CONFIG_SPI_ROCKCHIP)		+= spi-rockchip.o
Makefile:70:obj-$(CONFIG_SPI_RB4XX)			+= spi-rb4xx.o
Makefile:71:obj-$(CONFIG_SPI_RSPI)			+= spi-rspi.o
Makefile:72:obj-$(CONFIG_SPI_S3C24XX)		+= spi-s3c24xx-hw.o
Makefile:73:spi-s3c24xx-hw-y			:= spi-s3c24xx.o
Makefile:74:spi-s3c24xx-hw-$(CONFIG_SPI_S3C24XX_FIQ) += spi-s3c24xx-fiq.o
Makefile:75:obj-$(CONFIG_SPI_S3C64XX)		+= spi-s3c64xx.o
Makefile:76:obj-$(CONFIG_SPI_SC18IS602)		+= spi-sc18is602.o
Makefile:77:obj-$(CONFIG_SPI_SH)			+= spi-sh.o
Makefile:78:obj-$(CONFIG_SPI_SH_HSPI)		+= spi-sh-hspi.o
Makefile:79:obj-$(CONFIG_SPI_SH_MSIOF)		+= spi-sh-msiof.o
Makefile:80:obj-$(CONFIG_SPI_SH_SCI)		+= spi-sh-sci.o
Makefile:81:obj-$(CONFIG_SPI_SIRF)		+= spi-sirf.o
Makefile:82:obj-$(CONFIG_SPI_ST_SSC4)		+= spi-st-ssc4.o
Makefile:83:obj-$(CONFIG_SPI_SUN4I)			+= spi-sun4i.o
Makefile:84:obj-$(CONFIG_SPI_SUN6I)			+= spi-sun6i.o
Makefile:85:obj-$(CONFIG_SPI_TEGRA114)		+= spi-tegra114.o
Makefile:86:obj-$(CONFIG_SPI_TEGRA20_SFLASH)	+= spi-tegra20-sflash.o
Makefile:87:obj-$(CONFIG_SPI_TEGRA20_SLINK)		+= spi-tegra20-slink.o
Makefile:88:obj-$(CONFIG_SPI_TLE62X0)		+= spi-tle62x0.o
Makefile:89:obj-$(CONFIG_SPI_TOPCLIFF_PCH)		+= spi-topcliff-pch.o
Makefile:90:obj-$(CONFIG_SPI_TXX9)			+= spi-txx9.o
Makefile:91:obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
Makefile:92:obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
Makefile:93:obj-$(CONFIG_SPI_XLP)			+= spi-xlp.o
Makefile:94:obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
Makefile:95:obj-$(CONFIG_SPI_ZYNQMP_GQSPI)		+= spi-zynqmp-gqspi.o
Makefile:96:obj-$(CONFIG_SPI_ZMP) 			+= spi-zmp.o
spi-pxa2xx-pci.c:10:#include <linux/clk-provider.h>
spi-pxa2xx-pci.c:13:#include <linux/platform_data/dma-dw.h>
spi-pxa2xx-pci.c:49:	if (dws->dma_dev != chan->device->dev)
spi-pxa2xx-pci.c:52:	chan->private = dws;
spi-pxa2xx-pci.c:59:		.port_id =  -1,
spi-pxa2xx-pci.c:60:		.num_chipselect = -1,
spi-pxa2xx-pci.c:97:		.port_id = -1,
spi-pxa2xx-pci.c:123:	c = &spi_info_configs[ent->driver_data];
spi-pxa2xx-pci.c:126:	spi_pdata.num_chipselect = (c->num_chipselect > 0) ?
spi-pxa2xx-pci.c:127:					c->num_chipselect : dev->devfn;
spi-pxa2xx-pci.c:129:	dma_dev = pci_get_slot(dev->bus, PCI_DEVFN(PCI_SLOT(dev->devfn), 0));
spi-pxa2xx-pci.c:131:	if (c->tx_param) {
spi-pxa2xx-pci.c:132:		struct dw_dma_slave *slave = c->tx_param;
spi-pxa2xx-pci.c:134:		slave->dma_dev = &dma_dev->dev;
spi-pxa2xx-pci.c:135:		slave->src_master = 1;
spi-pxa2xx-pci.c:136:		slave->dst_master = 0;
spi-pxa2xx-pci.c:139:	if (c->rx_param) {
spi-pxa2xx-pci.c:140:		struct dw_dma_slave *slave = c->rx_param;
spi-pxa2xx-pci.c:142:		slave->dma_dev = &dma_dev->dev;
spi-pxa2xx-pci.c:143:		slave->src_master = 1;
spi-pxa2xx-pci.c:144:		slave->dst_master = 0;
spi-pxa2xx-pci.c:148:	spi_pdata.tx_param = c->tx_param;
spi-pxa2xx-pci.c:149:	spi_pdata.rx_param = c->rx_param;
spi-pxa2xx-pci.c:150:	spi_pdata.enable_dma = c->rx_param && c->tx_param;
spi-pxa2xx-pci.c:153:	ssp->phys_base = pci_resource_start(dev, 0);
spi-pxa2xx-pci.c:154:	ssp->mmio_base = pcim_iomap_table(dev)[0];
spi-pxa2xx-pci.c:155:	if (!ssp->mmio_base) {
spi-pxa2xx-pci.c:156:		dev_err(&dev->dev, "failed to ioremap() registers\n");
spi-pxa2xx-pci.c:157:		return -EIO;
spi-pxa2xx-pci.c:159:	ssp->irq = dev->irq;
spi-pxa2xx-pci.c:160:	ssp->port_id = (c->port_id >= 0) ? c->port_id : dev->devfn;
spi-pxa2xx-pci.c:161:	ssp->type = c->type;
spi-pxa2xx-pci.c:163:	snprintf(buf, sizeof(buf), "pxa2xx-spi.%d", ssp->port_id);
spi-pxa2xx-pci.c:164:	ssp->clk = clk_register_fixed_rate(&dev->dev, buf , NULL,
spi-pxa2xx-pci.c:165:					CLK_IS_ROOT, c->max_clk_rate);
spi-pxa2xx-pci.c:166:	 if (IS_ERR(ssp->clk))
spi-pxa2xx-pci.c:167:		return PTR_ERR(ssp->clk);
spi-pxa2xx-pci.c:170:	pi.parent = &dev->dev;
spi-pxa2xx-pci.c:171:	pi.name = "pxa2xx-spi";
spi-pxa2xx-pci.c:172:	pi.id = ssp->port_id;
spi-pxa2xx-pci.c:178:		clk_unregister(ssp->clk);
spi-pxa2xx-pci.c:192:	spi_pdata = dev_get_platdata(&pdev->dev);
spi-pxa2xx-pci.c:195:	clk_unregister(spi_pdata->ssp.clk);
spi-pxa2xx-pci.c:218:MODULE_DESCRIPTION("CE4100/LPSS PCI-SPI glue code for PXA's driver");
spi-qup.c:2: * Copyright (c) 2008-2014, The Linux foundation. All rights reserved.
spi-qup.c:26:#include <linux/dma-mapping.h>
spi-qup.c:121:#define SPI_MAX_DMA_XFER		(SZ_64K - 64)
spi-qup.c:160:	u32 opstate = readl_relaxed(controller->base + QUP_STATE);
spi-qup.c:176:			return -EIO;
spi-qup.c:180:		dev_dbg(controller->dev, "invalid state for %ld,us %d\n",
spi-qup.c:183:	cur_state = readl_relaxed(controller->base + QUP_STATE);
spi-qup.c:190:		writel_relaxed(QUP_STATE_CLEAR, controller->base + QUP_STATE);
spi-qup.c:191:		writel_relaxed(QUP_STATE_CLEAR, controller->base + QUP_STATE);
spi-qup.c:195:		writel_relaxed(cur_state, controller->base + QUP_STATE);
spi-qup.c:204:			return -EIO;
spi-qup.c:213:	u8 *rx_buf = xfer->rx_buf;
spi-qup.c:217:	w_size = controller->w_size;
spi-qup.c:219:	while (controller->rx_bytes < xfer->len) {
spi-qup.c:221:		state = readl_relaxed(controller->base + QUP_OPERATIONAL);
spi-qup.c:225:		word = readl_relaxed(controller->base + QUP_INPUT_FIFO);
spi-qup.c:228:			controller->rx_bytes += w_size;
spi-qup.c:232:		for (idx = 0; idx < w_size; idx++, controller->rx_bytes++) {
spi-qup.c:240:			shift *= (w_size - idx - 1);
spi-qup.c:241:			rx_buf[controller->rx_bytes] = word >> shift;
spi-qup.c:249:	const u8 *tx_buf = xfer->tx_buf;
spi-qup.c:253:	w_size = controller->w_size;
spi-qup.c:255:	while (controller->tx_bytes < xfer->len) {
spi-qup.c:257:		state = readl_relaxed(controller->base + QUP_OPERATIONAL);
spi-qup.c:262:		for (idx = 0; idx < w_size; idx++, controller->tx_bytes++) {
spi-qup.c:265:				controller->tx_bytes += w_size;
spi-qup.c:269:			data = tx_buf[controller->tx_bytes];
spi-qup.c:270:			word |= data << (BITS_PER_BYTE * (3 - idx));
spi-qup.c:273:		writel_relaxed(word, controller->base + QUP_OUTPUT_FIFO);
spi-qup.c:281:	complete(&qup->done);
spi-qup.c:297:		chan = master->dma_tx;
spi-qup.c:298:		nents = xfer->tx_sg.nents;
spi-qup.c:299:		sgl = xfer->tx_sg.sgl;
spi-qup.c:301:		chan = master->dma_rx;
spi-qup.c:302:		nents = xfer->rx_sg.nents;
spi-qup.c:303:		sgl = xfer->rx_sg.sgl;
spi-qup.c:308:		return -EINVAL;
spi-qup.c:310:	desc->callback = callback;
spi-qup.c:311:	desc->callback_param = qup;
spi-qup.c:321:	if (xfer->tx_buf)
spi-qup.c:322:		dmaengine_terminate_all(master->dma_tx);
spi-qup.c:323:	if (xfer->rx_buf)
spi-qup.c:324:		dmaengine_terminate_all(master->dma_rx);
spi-qup.c:332:	if (xfer->rx_buf)
spi-qup.c:334:	else if (xfer->tx_buf)
spi-qup.c:337:	if (xfer->rx_buf) {
spi-qup.c:342:		dma_async_issue_pending(master->dma_rx);
spi-qup.c:345:	if (xfer->tx_buf) {
spi-qup.c:350:		dma_async_issue_pending(master->dma_tx);
spi-qup.c:363:		dev_warn(qup->dev, "cannot set RUN state\n");
spi-qup.c:369:		dev_warn(qup->dev, "cannot set PAUSE state\n");
spi-qup.c:386:	spin_lock_irqsave(&controller->lock, flags);
spi-qup.c:387:	xfer = controller->xfer;
spi-qup.c:388:	controller->xfer = NULL;
spi-qup.c:389:	spin_unlock_irqrestore(&controller->lock, flags);
spi-qup.c:391:	qup_err = readl_relaxed(controller->base + QUP_ERROR_FLAGS);
spi-qup.c:392:	spi_err = readl_relaxed(controller->base + SPI_ERROR_FLAGS);
spi-qup.c:393:	opflags = readl_relaxed(controller->base + QUP_OPERATIONAL);
spi-qup.c:395:	writel_relaxed(qup_err, controller->base + QUP_ERROR_FLAGS);
spi-qup.c:396:	writel_relaxed(spi_err, controller->base + SPI_ERROR_FLAGS);
spi-qup.c:397:	writel_relaxed(opflags, controller->base + QUP_OPERATIONAL);
spi-qup.c:400:		dev_err_ratelimited(controller->dev, "unexpected irq %08x %08x %08x\n",
spi-qup.c:407:			dev_warn(controller->dev, "OUTPUT_OVER_RUN\n");
spi-qup.c:409:			dev_warn(controller->dev, "INPUT_UNDER_RUN\n");
spi-qup.c:411:			dev_warn(controller->dev, "OUTPUT_UNDER_RUN\n");
spi-qup.c:413:			dev_warn(controller->dev, "INPUT_OVER_RUN\n");
spi-qup.c:415:		error = -EIO;
spi-qup.c:420:			dev_warn(controller->dev, "CLK_OVER_RUN\n");
spi-qup.c:422:			dev_warn(controller->dev, "CLK_UNDER_RUN\n");
spi-qup.c:424:		error = -EIO;
spi-qup.c:427:	if (!controller->use_dma) {
spi-qup.c:435:	spin_lock_irqsave(&controller->lock, flags);
spi-qup.c:436:	controller->error = error;
spi-qup.c:437:	controller->xfer = xfer;
spi-qup.c:438:	spin_unlock_irqrestore(&controller->lock, flags);
spi-qup.c:440:	if (controller->rx_bytes == xfer->len || error)
spi-qup.c:441:		complete(&controller->done);
spi-qup.c:452:	qup->w_size = 4;
spi-qup.c:454:	if (xfer->bits_per_word <= 8)
spi-qup.c:455:		qup->w_size = 1;
spi-qup.c:456:	else if (xfer->bits_per_word <= 16)
spi-qup.c:457:		qup->w_size = 2;
spi-qup.c:459:	qup->n_words = xfer->len / qup->w_size;
spi-qup.c:461:	if (qup->n_words <= (qup->in_fifo_sz / sizeof(u32)))
spi-qup.c:472:	struct spi_qup *controller = spi_master_get_devdata(spi->master);
spi-qup.c:476:	if (spi->mode & SPI_LOOP && xfer->len > controller->in_fifo_sz) {
spi-qup.c:477:		dev_err(controller->dev, "too big size for loopback %d > %d\n",
spi-qup.c:478:			xfer->len, controller->in_fifo_sz);
spi-qup.c:479:		return -EIO;
spi-qup.c:482:	ret = clk_set_rate(controller->cclk, xfer->speed_hz);
spi-qup.c:484:		dev_err(controller->dev, "fail to set frequency %d",
spi-qup.c:485:			xfer->speed_hz);
spi-qup.c:486:		return -EIO;
spi-qup.c:490:		dev_err(controller->dev, "cannot set RESET state\n");
spi-qup.c:491:		return -EIO;
spi-qup.c:494:	mode = spi_qup_get_mode(spi->master, xfer);
spi-qup.c:495:	n_words = controller->n_words;
spi-qup.c:498:		writel_relaxed(n_words, controller->base + QUP_MX_READ_CNT);
spi-qup.c:499:		writel_relaxed(n_words, controller->base + QUP_MX_WRITE_CNT);
spi-qup.c:501:		writel_relaxed(0, controller->base + QUP_MX_INPUT_CNT);
spi-qup.c:502:		writel_relaxed(0, controller->base + QUP_MX_OUTPUT_CNT);
spi-qup.c:503:	} else if (!controller->use_dma) {
spi-qup.c:504:		writel_relaxed(n_words, controller->base + QUP_MX_INPUT_CNT);
spi-qup.c:505:		writel_relaxed(n_words, controller->base + QUP_MX_OUTPUT_CNT);
spi-qup.c:507:		writel_relaxed(0, controller->base + QUP_MX_READ_CNT);
spi-qup.c:508:		writel_relaxed(0, controller->base + QUP_MX_WRITE_CNT);
spi-qup.c:511:		writel_relaxed(0, controller->base + QUP_MX_READ_CNT);
spi-qup.c:512:		writel_relaxed(0, controller->base + QUP_MX_WRITE_CNT);
spi-qup.c:514:		if (!controller->qup_v1) {
spi-qup.c:517:			input_cnt = controller->base + QUP_MX_INPUT_CNT;
spi-qup.c:521:			 * That case is a non-balanced transfer when there is
spi-qup.c:524:			if (xfer->tx_buf)
spi-qup.c:529:			writel_relaxed(0, controller->base + QUP_MX_OUTPUT_CNT);
spi-qup.c:533:	iomode = readl_relaxed(controller->base + QUP_IO_M_MODES);
spi-qup.c:537:	if (!controller->use_dma)
spi-qup.c:545:	writel_relaxed(iomode, controller->base + QUP_IO_M_MODES);
spi-qup.c:547:	control = readl_relaxed(controller->base + SPI_IO_CONTROL);
spi-qup.c:549:	if (spi->mode & SPI_CPOL)
spi-qup.c:554:	writel_relaxed(control, controller->base + SPI_IO_CONTROL);
spi-qup.c:556:	config = readl_relaxed(controller->base + SPI_CONFIG);
spi-qup.c:558:	if (spi->mode & SPI_LOOP)
spi-qup.c:563:	if (spi->mode & SPI_CPHA)
spi-qup.c:569:	 * HS_MODE improves signal stability for spi-clk high rates,
spi-qup.c:572:	if ((xfer->speed_hz >= SPI_HS_MIN_RATE) && !(spi->mode & SPI_LOOP))
spi-qup.c:577:	writel_relaxed(config, controller->base + SPI_CONFIG);
spi-qup.c:579:	config = readl_relaxed(controller->base + QUP_CONFIG);
spi-qup.c:581:	config |= xfer->bits_per_word - 1;
spi-qup.c:584:	if (controller->use_dma) {
spi-qup.c:585:		if (!xfer->tx_buf)
spi-qup.c:587:		if (!xfer->rx_buf)
spi-qup.c:591:	writel_relaxed(config, controller->base + QUP_CONFIG);
spi-qup.c:594:	if (!controller->qup_v1) {
spi-qup.c:605:		writel_relaxed(mask, controller->base + QUP_OPERATIONAL_MASK);
spi-qup.c:617:	int ret = -EIO;
spi-qup.c:623:	timeout = DIV_ROUND_UP(xfer->speed_hz, MSEC_PER_SEC);
spi-qup.c:624:	timeout = DIV_ROUND_UP(xfer->len * 8, timeout);
spi-qup.c:627:	reinit_completion(&controller->done);
spi-qup.c:629:	spin_lock_irqsave(&controller->lock, flags);
spi-qup.c:630:	controller->xfer     = xfer;
spi-qup.c:631:	controller->error    = 0;
spi-qup.c:632:	controller->rx_bytes = 0;
spi-qup.c:633:	controller->tx_bytes = 0;
spi-qup.c:634:	spin_unlock_irqrestore(&controller->lock, flags);
spi-qup.c:636:	if (controller->use_dma)
spi-qup.c:645:		dev_warn(controller->dev, "cannot set EXECUTE state\n");
spi-qup.c:649:	if (!wait_for_completion_timeout(&controller->done, timeout))
spi-qup.c:650:		ret = -ETIMEDOUT;
spi-qup.c:654:	spin_lock_irqsave(&controller->lock, flags);
spi-qup.c:655:	controller->xfer = NULL;
spi-qup.c:657:		ret = controller->error;
spi-qup.c:658:	spin_unlock_irqrestore(&controller->lock, flags);
spi-qup.c:660:	if (ret && controller->use_dma)
spi-qup.c:673:	qup->use_dma = 0;
spi-qup.c:675:	if (xfer->rx_buf && (xfer->len % qup->in_blk_sz ||
spi-qup.c:676:	    IS_ERR_OR_NULL(master->dma_rx) ||
spi-qup.c:677:	    !IS_ALIGNED((size_t)xfer->rx_buf, dma_align)))
spi-qup.c:680:	if (xfer->tx_buf && (xfer->len % qup->out_blk_sz ||
spi-qup.c:681:	    IS_ERR_OR_NULL(master->dma_tx) ||
spi-qup.c:682:	    !IS_ALIGNED((size_t)xfer->tx_buf, dma_align)))
spi-qup.c:689:	qup->use_dma = 1;
spi-qup.c:696:	if (!IS_ERR_OR_NULL(master->dma_rx))
spi-qup.c:697:		dma_release_channel(master->dma_rx);
spi-qup.c:698:	if (!IS_ERR_OR_NULL(master->dma_tx))
spi-qup.c:699:		dma_release_channel(master->dma_tx);
spi-qup.c:705:	struct dma_slave_config *rx_conf = &spi->rx_conf,
spi-qup.c:706:				*tx_conf = &spi->tx_conf;
spi-qup.c:707:	struct device *dev = spi->dev;
spi-qup.c:711:	master->dma_rx = dma_request_slave_channel_reason(dev, "rx");
spi-qup.c:712:	if (IS_ERR(master->dma_rx))
spi-qup.c:713:		return PTR_ERR(master->dma_rx);
spi-qup.c:715:	master->dma_tx = dma_request_slave_channel_reason(dev, "tx");
spi-qup.c:716:	if (IS_ERR(master->dma_tx)) {
spi-qup.c:717:		ret = PTR_ERR(master->dma_tx);
spi-qup.c:722:	rx_conf->direction = DMA_DEV_TO_MEM;
spi-qup.c:723:	rx_conf->device_fc = 1;
spi-qup.c:724:	rx_conf->src_addr = base + QUP_INPUT_FIFO;
spi-qup.c:725:	rx_conf->src_maxburst = spi->in_blk_sz;
spi-qup.c:727:	tx_conf->direction = DMA_MEM_TO_DEV;
spi-qup.c:728:	tx_conf->device_fc = 1;
spi-qup.c:729:	tx_conf->dst_addr = base + QUP_OUTPUT_FIFO;
spi-qup.c:730:	tx_conf->dst_maxburst = spi->out_blk_sz;
spi-qup.c:732:	ret = dmaengine_slave_config(master->dma_rx, rx_conf);
spi-qup.c:738:	ret = dmaengine_slave_config(master->dma_tx, tx_conf);
spi-qup.c:747:	dma_release_channel(master->dma_tx);
spi-qup.c:749:	dma_release_channel(master->dma_rx);
spi-qup.c:764:	dev = &pdev->dev;
spi-qup.c:783:	if (of_property_read_u32(dev->of_node, "spi-max-frequency", &max_freq))
spi-qup.c:788:		return -ENXIO;
spi-qup.c:809:		return -ENOMEM;
spi-qup.c:812:	/* use num-cs unless not present or out of range */
spi-qup.c:813:	if (of_property_read_u32(dev->of_node, "num-cs", &num_cs) ||
spi-qup.c:815:		master->num_chipselect = SPI_NUM_CHIPSELECTS;
spi-qup.c:817:		master->num_chipselect = num_cs;
spi-qup.c:819:	master->bus_num = pdev->id;
spi-qup.c:820:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;
spi-qup.c:821:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);
spi-qup.c:822:	master->max_speed_hz = max_freq;
spi-qup.c:823:	master->transfer_one = spi_qup_transfer_one;
spi-qup.c:824:	master->dev.of_node = pdev->dev.of_node;
spi-qup.c:825:	master->auto_runtime_pm = true;
spi-qup.c:826:	master->dma_alignment = dma_get_cache_alignment();
spi-qup.c:827:	master->max_dma_len = SPI_MAX_DMA_XFER;
spi-qup.c:833:	controller->dev = dev;
spi-qup.c:834:	controller->base = base;
spi-qup.c:835:	controller->iclk = iclk;
spi-qup.c:836:	controller->cclk = cclk;
spi-qup.c:837:	controller->irq = irq;
spi-qup.c:839:	ret = spi_qup_init_dma(master, res->start);
spi-qup.c:840:	if (ret == -EPROBE_DEFER)
spi-qup.c:843:		master->can_dma = spi_qup_can_dma;
spi-qup.c:846:	if (of_device_is_compatible(dev->of_node, "qcom,spi-qup-v1.1.1"))
spi-qup.c:847:		controller->qup_v1 = 1;
spi-qup.c:849:	spin_lock_init(&controller->lock);
spi-qup.c:850:	init_completion(&controller->done);
spi-qup.c:856:		controller->out_blk_sz = size * 16;
spi-qup.c:858:		controller->out_blk_sz = 4;
spi-qup.c:862:		controller->in_blk_sz = size * 16;
spi-qup.c:864:		controller->in_blk_sz = 4;
spi-qup.c:867:	controller->out_fifo_sz = controller->out_blk_sz * (2 << size);
spi-qup.c:870:	controller->in_fifo_sz = controller->in_blk_sz * (2 << size);
spi-qup.c:873:		 controller->in_blk_sz, controller->in_fifo_sz,
spi-qup.c:874:		 controller->out_blk_sz, controller->out_fifo_sz);
spi-qup.c:887:	if (!controller->qup_v1)
spi-qup.c:894:	if (controller->qup_v1)
spi-qup.c:903:			       IRQF_TRIGGER_HIGH, pdev->name, controller);
spi-qup.c:919:	pm_runtime_disable(&pdev->dev);
spi-qup.c:937:	config = readl(controller->base + QUP_CONFIG);
spi-qup.c:939:	writel_relaxed(config, controller->base + QUP_CONFIG);
spi-qup.c:950:	config = readl_relaxed(controller->base + QUP_CONFIG);
spi-qup.c:952:	writel_relaxed(config, controller->base + QUP_CONFIG);
spi-qup.c:972:	clk_disable_unprepare(controller->cclk);
spi-qup.c:973:	clk_disable_unprepare(controller->iclk);
spi-qup.c:983:	ret = clk_prepare_enable(controller->iclk);
spi-qup.c:987:	ret = clk_prepare_enable(controller->cclk);
spi-qup.c:1001:	struct spi_master *master = dev_get_drvdata(&pdev->dev);
spi-qup.c:1005:	ret = pm_runtime_get_sync(&pdev->dev);
spi-qup.c:1015:	clk_disable_unprepare(controller->cclk);
spi-qup.c:1016:	clk_disable_unprepare(controller->iclk);
spi-qup.c:1018:	pm_runtime_put_noidle(&pdev->dev);
spi-qup.c:1019:	pm_runtime_disable(&pdev->dev);
spi-qup.c:1024:	{ .compatible = "qcom,spi-qup-v1.1.1", },
spi-qup.c:1025:	{ .compatible = "qcom,spi-qup-v2.1.1", },
spi-qup.c:1026:	{ .compatible = "qcom,spi-qup-v2.2.1", },
spi-img-spfi.c:58:#define SPFI_PORT_STATE_CK_POL(x)		BIT(19 - (x))
spi-img-spfi.c:59:#define SPFI_PORT_STATE_CK_PHASE(x)		BIT(14 - (x))
spi-img-spfi.c:114:	return readl(spfi->regs + reg);
spi-img-spfi.c:119:	writel(val, spfi->regs + reg);
spi-img-spfi.c:152:	dev_err(spfi->dev, "Timed out waiting for transaction to complete\n");
spi-img-spfi.c:155:	return -ETIMEDOUT;
spi-img-spfi.c:236:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
spi-img-spfi.c:238:	const void *tx_buf = xfer->tx_buf;
spi-img-spfi.c:239:	void *rx_buf = xfer->rx_buf;
spi-img-spfi.c:244:		tx_bytes = xfer->len;
spi-img-spfi.c:246:		rx_bytes = xfer->len;
spi-img-spfi.c:251:		msecs_to_jiffies(xfer->len * 8 * 1000 / xfer->speed_hz + 100);
spi-img-spfi.c:268:		tx_bytes -= tx_count;
spi-img-spfi.c:269:		rx_bytes -= rx_count;
spi-img-spfi.c:275:		dev_err(spfi->dev, "PIO transfer timed out\n");
spi-img-spfi.c:276:		return -ETIMEDOUT;
spi-img-spfi.c:293:	spin_lock_irqsave(&spfi->lock, flags);
spi-img-spfi.c:294:	spfi->rx_dma_busy = false;
spi-img-spfi.c:295:	if (!spfi->tx_dma_busy)
spi-img-spfi.c:296:		spi_finalize_current_transfer(spfi->master);
spi-img-spfi.c:297:	spin_unlock_irqrestore(&spfi->lock, flags);
spi-img-spfi.c:307:	spin_lock_irqsave(&spfi->lock, flags);
spi-img-spfi.c:308:	spfi->tx_dma_busy = false;
spi-img-spfi.c:309:	if (!spfi->rx_dma_busy)
spi-img-spfi.c:310:		spi_finalize_current_transfer(spfi->master);
spi-img-spfi.c:311:	spin_unlock_irqrestore(&spfi->lock, flags);
spi-img-spfi.c:318:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
spi-img-spfi.c:322:	spfi->rx_dma_busy = false;
spi-img-spfi.c:323:	spfi->tx_dma_busy = false;
spi-img-spfi.c:325:	if (xfer->rx_buf) {
spi-img-spfi.c:327:		if (xfer->len % 4 == 0) {
spi-img-spfi.c:328:			rxconf.src_addr = spfi->phys + SPFI_RX_32BIT_VALID_DATA;
spi-img-spfi.c:332:			rxconf.src_addr = spfi->phys + SPFI_RX_8BIT_VALID_DATA;
spi-img-spfi.c:336:		dmaengine_slave_config(spfi->rx_ch, &rxconf);
spi-img-spfi.c:338:		rxdesc = dmaengine_prep_slave_sg(spfi->rx_ch, xfer->rx_sg.sgl,
spi-img-spfi.c:339:						 xfer->rx_sg.nents,
spi-img-spfi.c:345:		rxdesc->callback = img_spfi_dma_rx_cb;
spi-img-spfi.c:346:		rxdesc->callback_param = spfi;
spi-img-spfi.c:349:	if (xfer->tx_buf) {
spi-img-spfi.c:351:		if (xfer->len % 4 == 0) {
spi-img-spfi.c:352:			txconf.dst_addr = spfi->phys + SPFI_TX_32BIT_VALID_DATA;
spi-img-spfi.c:356:			txconf.dst_addr = spfi->phys + SPFI_TX_8BIT_VALID_DATA;
spi-img-spfi.c:360:		dmaengine_slave_config(spfi->tx_ch, &txconf);
spi-img-spfi.c:362:		txdesc = dmaengine_prep_slave_sg(spfi->tx_ch, xfer->tx_sg.sgl,
spi-img-spfi.c:363:						 xfer->tx_sg.nents,
spi-img-spfi.c:369:		txdesc->callback = img_spfi_dma_tx_cb;
spi-img-spfi.c:370:		txdesc->callback_param = spfi;
spi-img-spfi.c:373:	if (xfer->rx_buf) {
spi-img-spfi.c:374:		spfi->rx_dma_busy = true;
spi-img-spfi.c:376:		dma_async_issue_pending(spfi->rx_ch);
spi-img-spfi.c:381:	if (xfer->tx_buf) {
spi-img-spfi.c:382:		spfi->tx_dma_busy = true;
spi-img-spfi.c:384:		dma_async_issue_pending(spfi->tx_ch);
spi-img-spfi.c:390:	dmaengine_terminate_all(spfi->rx_ch);
spi-img-spfi.c:391:	dmaengine_terminate_all(spfi->tx_ch);
spi-img-spfi.c:392:	return -EIO;
spi-img-spfi.c:403:	 * timed-out and never completed it's DMA.
spi-img-spfi.c:405:	spin_lock_irqsave(&spfi->lock, flags);
spi-img-spfi.c:406:	if (spfi->tx_dma_busy || spfi->rx_dma_busy) {
spi-img-spfi.c:407:		spfi->tx_dma_busy = false;
spi-img-spfi.c:408:		spfi->rx_dma_busy = false;
spi-img-spfi.c:410:		dmaengine_terminate_all(spfi->tx_ch);
spi-img-spfi.c:411:		dmaengine_terminate_all(spfi->rx_ch);
spi-img-spfi.c:413:	spin_unlock_irqrestore(&spfi->lock, flags);
spi-img-spfi.c:422:	if (msg->spi->mode & SPI_CPHA)
spi-img-spfi.c:423:		val |= SPFI_PORT_STATE_CK_PHASE(msg->spi->chip_select);
spi-img-spfi.c:425:		val &= ~SPFI_PORT_STATE_CK_PHASE(msg->spi->chip_select);
spi-img-spfi.c:426:	if (msg->spi->mode & SPI_CPOL)
spi-img-spfi.c:427:		val |= SPFI_PORT_STATE_CK_POL(msg->spi->chip_select);
spi-img-spfi.c:429:		val &= ~SPFI_PORT_STATE_CK_POL(msg->spi->chip_select);
spi-img-spfi.c:447:	int ret = -EINVAL;
spi-img-spfi.c:453:			return -ENOMEM;
spi-img-spfi.c:454:		spfi_data->gpio_requested = false;
spi-img-spfi.c:457:	if (!spfi_data->gpio_requested) {
spi-img-spfi.c:458:		ret = gpio_request_one(spi->cs_gpio,
spi-img-spfi.c:459:				       (spi->mode & SPI_CS_HIGH) ?
spi-img-spfi.c:461:				       dev_name(&spi->dev));
spi-img-spfi.c:463:			dev_err(&spi->dev, "can't request chipselect gpio %d\n",
spi-img-spfi.c:464:				spi->cs_gpio);
spi-img-spfi.c:466:			spfi_data->gpio_requested = true;
spi-img-spfi.c:468:		if (gpio_is_valid(spi->cs_gpio)) {
spi-img-spfi.c:469:			int mode = ((spi->mode & SPI_CS_HIGH) ?
spi-img-spfi.c:472:			ret = gpio_direction_output(spi->cs_gpio, mode);
spi-img-spfi.c:474:				dev_err(&spi->dev, "chipselect gpio %d setup failed (%d)\n",
spi-img-spfi.c:475:					spi->cs_gpio, ret);
spi-img-spfi.c:486:		if (spfi_data->gpio_requested)
spi-img-spfi.c:487:			gpio_free(spi->cs_gpio);
spi-img-spfi.c:496:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
spi-img-spfi.c:503:	div = DIV_ROUND_UP(clk_get_rate(spfi->spfi_clk), xfer->speed_hz);
spi-img-spfi.c:506:	val = spfi_readl(spfi, SPFI_DEVICE_PARAMETER(spi->chip_select));
spi-img-spfi.c:510:	spfi_writel(spfi, val, SPFI_DEVICE_PARAMETER(spi->chip_select));
spi-img-spfi.c:512:	spfi_writel(spfi, xfer->len << SPFI_TRANSACTION_TSIZE_SHIFT,
spi-img-spfi.c:517:	if (xfer->tx_buf)
spi-img-spfi.c:519:	if (xfer->rx_buf)
spi-img-spfi.c:522:	if (xfer->tx_nbits == SPI_NBITS_DUAL &&
spi-img-spfi.c:523:	    xfer->rx_nbits == SPI_NBITS_DUAL)
spi-img-spfi.c:525:	else if (xfer->tx_nbits == SPI_NBITS_QUAD &&
spi-img-spfi.c:526:		 xfer->rx_nbits == SPI_NBITS_QUAD)
spi-img-spfi.c:536:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
spi-img-spfi.c:539:	if (xfer->len > SPFI_TRANSACTION_TSIZE_MASK) {
spi-img-spfi.c:540:		dev_err(spfi->dev,
spi-img-spfi.c:542:			xfer->len, SPFI_TRANSACTION_TSIZE_MASK);
spi-img-spfi.c:543:		return -EINVAL;
spi-img-spfi.c:547:	if (master->can_dma && master->can_dma(master, spi, xfer))
spi-img-spfi.c:558:	if (xfer->len > SPFI_32BIT_FIFO_SIZE)
spi-img-spfi.c:571:		dev_err(spfi->dev, "Illegal access interrupt");
spi-img-spfi.c:586:	master = spi_alloc_master(&pdev->dev, sizeof(*spfi));
spi-img-spfi.c:588:		return -ENOMEM;
spi-img-spfi.c:592:	spfi->dev = &pdev->dev;
spi-img-spfi.c:593:	spfi->master = master;
spi-img-spfi.c:594:	spin_lock_init(&spfi->lock);
spi-img-spfi.c:597:	spfi->regs = devm_ioremap_resource(spfi->dev, res);
spi-img-spfi.c:598:	if (IS_ERR(spfi->regs)) {
spi-img-spfi.c:599:		ret = PTR_ERR(spfi->regs);
spi-img-spfi.c:602:	spfi->phys = res->start;
spi-img-spfi.c:604:	spfi->irq = platform_get_irq(pdev, 0);
spi-img-spfi.c:605:	if (spfi->irq < 0) {
spi-img-spfi.c:606:		ret = spfi->irq;
spi-img-spfi.c:609:	ret = devm_request_irq(spfi->dev, spfi->irq, img_spfi_irq,
spi-img-spfi.c:610:			       IRQ_TYPE_LEVEL_HIGH, dev_name(spfi->dev), spfi);
spi-img-spfi.c:614:	spfi->sys_clk = devm_clk_get(spfi->dev, "sys");
spi-img-spfi.c:615:	if (IS_ERR(spfi->sys_clk)) {
spi-img-spfi.c:616:		ret = PTR_ERR(spfi->sys_clk);
spi-img-spfi.c:619:	spfi->spfi_clk = devm_clk_get(spfi->dev, "spfi");
spi-img-spfi.c:620:	if (IS_ERR(spfi->spfi_clk)) {
spi-img-spfi.c:621:		ret = PTR_ERR(spfi->spfi_clk);
spi-img-spfi.c:625:	ret = clk_prepare_enable(spfi->sys_clk);
spi-img-spfi.c:628:	ret = clk_prepare_enable(spfi->spfi_clk);
spi-img-spfi.c:639:	master->auto_runtime_pm = true;
spi-img-spfi.c:640:	master->bus_num = pdev->id;
spi-img-spfi.c:641:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_TX_DUAL | SPI_RX_DUAL;
spi-img-spfi.c:642:	if (of_property_read_bool(spfi->dev->of_node, "img,supports-quad-mode"))
spi-img-spfi.c:643:		master->mode_bits |= SPI_TX_QUAD | SPI_RX_QUAD;
spi-img-spfi.c:644:	master->dev.of_node = pdev->dev.of_node;
spi-img-spfi.c:645:	master->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(8);
spi-img-spfi.c:646:	master->max_speed_hz = clk_get_rate(spfi->spfi_clk) / 4;
spi-img-spfi.c:647:	master->min_speed_hz = clk_get_rate(spfi->spfi_clk) / 512;
spi-img-spfi.c:651:	 * between 1/4 of the SPFI clock or to "spfi-max-frequency"
spi-img-spfi.c:656:	if (!of_property_read_u32(spfi->dev->of_node, "spfi-max-frequency",
spi-img-spfi.c:658:		if (master->max_speed_hz > max_speed_hz)
spi-img-spfi.c:659:			master->max_speed_hz = max_speed_hz;
spi-img-spfi.c:662:	master->setup = img_spfi_setup;
spi-img-spfi.c:663:	master->cleanup = img_spfi_cleanup;
spi-img-spfi.c:664:	master->transfer_one = img_spfi_transfer_one;
spi-img-spfi.c:665:	master->prepare_message = img_spfi_prepare;
spi-img-spfi.c:666:	master->unprepare_message = img_spfi_unprepare;
spi-img-spfi.c:667:	master->handle_err = img_spfi_handle_err;
spi-img-spfi.c:669:	spfi->tx_ch = dma_request_slave_channel(spfi->dev, "tx");
spi-img-spfi.c:670:	spfi->rx_ch = dma_request_slave_channel(spfi->dev, "rx");
spi-img-spfi.c:671:	if (!spfi->tx_ch || !spfi->rx_ch) {
spi-img-spfi.c:672:		if (spfi->tx_ch)
spi-img-spfi.c:673:			dma_release_channel(spfi->tx_ch);
spi-img-spfi.c:674:		if (spfi->rx_ch)
spi-img-spfi.c:675:			dma_release_channel(spfi->rx_ch);
spi-img-spfi.c:676:		dev_warn(spfi->dev, "Failed to get DMA channels, falling back to PIO mode\n");
spi-img-spfi.c:678:		master->dma_tx = spfi->tx_ch;
spi-img-spfi.c:679:		master->dma_rx = spfi->rx_ch;
spi-img-spfi.c:680:		master->can_dma = img_spfi_can_dma;
spi-img-spfi.c:683:	pm_runtime_set_active(spfi->dev);
spi-img-spfi.c:684:	pm_runtime_enable(spfi->dev);
spi-img-spfi.c:686:	ret = devm_spi_register_master(spfi->dev, master);
spi-img-spfi.c:693:	pm_runtime_disable(spfi->dev);
spi-img-spfi.c:694:	if (spfi->rx_ch)
spi-img-spfi.c:695:		dma_release_channel(spfi->rx_ch);
spi-img-spfi.c:696:	if (spfi->tx_ch)
spi-img-spfi.c:697:		dma_release_channel(spfi->tx_ch);
spi-img-spfi.c:698:	clk_disable_unprepare(spfi->spfi_clk);
spi-img-spfi.c:700:	clk_disable_unprepare(spfi->sys_clk);
spi-img-spfi.c:712:	if (spfi->tx_ch)
spi-img-spfi.c:713:		dma_release_channel(spfi->tx_ch);
spi-img-spfi.c:714:	if (spfi->rx_ch)
spi-img-spfi.c:715:		dma_release_channel(spfi->rx_ch);
spi-img-spfi.c:717:	pm_runtime_disable(spfi->dev);
spi-img-spfi.c:718:	if (!pm_runtime_status_suspended(spfi->dev)) {
spi-img-spfi.c:719:		clk_disable_unprepare(spfi->spfi_clk);
spi-img-spfi.c:720:		clk_disable_unprepare(spfi->sys_clk);
spi-img-spfi.c:734:	clk_disable_unprepare(spfi->spfi_clk);
spi-img-spfi.c:735:	clk_disable_unprepare(spfi->sys_clk);
spi-img-spfi.c:746:	ret = clk_prepare_enable(spfi->sys_clk);
spi-img-spfi.c:749:	ret = clk_prepare_enable(spfi->spfi_clk);
spi-img-spfi.c:751:		clk_disable_unprepare(spfi->sys_clk);
spi-img-spfi.c:797:		.name = "img-spfi",
spi-sc18is602.c:4: * Copyright (C) Guenter Roeck <linux@roeck-us.net>
spi-sc18is602.c:58:	int usecs = 1000000 * len / hw->speed + 1;
spi-sc18is602.c:62:		err = i2c_master_recv(hw->client, dummy, 1);
spi-sc18is602.c:67:	return -ETIMEDOUT;
spi-sc18is602.c:73:	unsigned int len = t->len;
spi-sc18is602.c:76:	if (hw->tlen == 0) {
spi-sc18is602.c:78:		hw->buffer[0] = 1 << msg->spi->chip_select;
spi-sc18is602.c:79:		hw->tlen = 1;
spi-sc18is602.c:80:		hw->rindex = 0;
spi-sc18is602.c:87:	if (t->tx_buf) {
spi-sc18is602.c:88:		memcpy(&hw->buffer[hw->tlen], t->tx_buf, len);
spi-sc18is602.c:89:		hw->tlen += len;
spi-sc18is602.c:90:		if (t->rx_buf)
spi-sc18is602.c:93:			hw->rindex = hw->tlen - 1;
spi-sc18is602.c:94:	} else if (t->rx_buf) {
spi-sc18is602.c:96:		 * For receive-only transfers we still need to perform a dummy
spi-sc18is602.c:101:		hw->rindex = hw->tlen - 1;
spi-sc18is602.c:102:		memset(&hw->buffer[hw->tlen], 0, len);
spi-sc18is602.c:103:		hw->tlen += len;
spi-sc18is602.c:107:	if (do_transfer && hw->tlen > 1) {
spi-sc18is602.c:111:		ret = i2c_master_send(hw->client, hw->buffer, hw->tlen);
spi-sc18is602.c:114:		if (ret != hw->tlen)
spi-sc18is602.c:115:			return -EIO;
spi-sc18is602.c:117:		if (t->rx_buf) {
spi-sc18is602.c:118:			int rlen = hw->rindex + len;
spi-sc18is602.c:120:			ret = sc18is602_wait_ready(hw, hw->tlen);
spi-sc18is602.c:123:			ret = i2c_master_recv(hw->client, hw->buffer, rlen);
spi-sc18is602.c:127:				return -EIO;
spi-sc18is602.c:128:			memcpy(t->rx_buf, &hw->buffer[hw->rindex], len);
spi-sc18is602.c:130:		hw->tlen = 0;
spi-sc18is602.c:148:	if (hz >= hw->freq / 4) {
spi-sc18is602.c:150:		hw->speed = hw->freq / 4;
spi-sc18is602.c:151:	} else if (hz >= hw->freq / 16) {
spi-sc18is602.c:153:		hw->speed = hw->freq / 16;
spi-sc18is602.c:154:	} else if (hz >= hw->freq / 64) {
spi-sc18is602.c:156:		hw->speed = hw->freq / 64;
spi-sc18is602.c:159:		hw->speed = hw->freq / 128;
spi-sc18is602.c:164:	 * value of 0xff for hw->ctrl ensures that the correct mode will be set
spi-sc18is602.c:167:	if (ctrl == hw->ctrl)
spi-sc18is602.c:170:	ret = i2c_smbus_write_byte_data(hw->client, 0xf0, ctrl);
spi-sc18is602.c:174:	hw->ctrl = ctrl;
spi-sc18is602.c:182:	if (t && t->len + tlen > SC18IS602_BUFSIZ)
spi-sc18is602.c:183:		return -EINVAL;
spi-sc18is602.c:192:	struct spi_device *spi = m->spi;
spi-sc18is602.c:196:	hw->tlen = 0;
spi-sc18is602.c:197:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-sc18is602.c:200:		status = sc18is602_check_transfer(spi, t, hw->tlen);
spi-sc18is602.c:204:		status = sc18is602_setup_transfer(hw, t->speed_hz, spi->mode);
spi-sc18is602.c:208:		do_transfer = t->cs_change || list_is_last(&t->transfer_list,
spi-sc18is602.c:209:							   &m->transfers);
spi-sc18is602.c:211:		if (t->len) {
spi-sc18is602.c:215:			m->actual_length += status;
spi-sc18is602.c:219:		if (t->delay_usecs)
spi-sc18is602.c:220:			udelay(t->delay_usecs);
spi-sc18is602.c:222:	m->status = status;
spi-sc18is602.c:230:	struct sc18is602 *hw = spi_master_get_devdata(spi->master);
spi-sc18is602.c:233:	if (hw->id == sc18is602 && spi->chip_select == 2)
spi-sc18is602.c:234:		return -ENXIO;
spi-sc18is602.c:242:	struct device *dev = &client->dev;
spi-sc18is602.c:243:	struct device_node *np = dev->of_node;
spi-sc18is602.c:249:	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |
spi-sc18is602.c:251:		return -EINVAL;
spi-sc18is602.c:255:		return -ENOMEM;
spi-sc18is602.c:260:	hw->master = master;
spi-sc18is602.c:261:	hw->client = client;
spi-sc18is602.c:262:	hw->dev = dev;
spi-sc18is602.c:263:	hw->ctrl = 0xff;
spi-sc18is602.c:265:	hw->id = id->driver_data;
spi-sc18is602.c:267:	switch (hw->id) {
spi-sc18is602.c:270:		master->num_chipselect = 4;
spi-sc18is602.c:271:		hw->freq = SC18IS602_CLOCK;
spi-sc18is602.c:274:		master->num_chipselect = 2;
spi-sc18is602.c:276:			hw->freq = pdata->clock_frequency;
spi-sc18is602.c:281:			val = of_get_property(np, "clock-frequency", &len);
spi-sc18is602.c:283:				hw->freq = be32_to_cpup(val);
spi-sc18is602.c:285:		if (!hw->freq)
spi-sc18is602.c:286:			hw->freq = SC18IS602_CLOCK;
spi-sc18is602.c:289:	master->bus_num = np ? -1 : client->adapter->nr;
spi-sc18is602.c:290:	master->mode_bits = SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST;
spi-sc18is602.c:291:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-sc18is602.c:292:	master->setup = sc18is602_setup;
spi-sc18is602.c:293:	master->transfer_one_message = sc18is602_transfer_one;
spi-sc18is602.c:294:	master->dev.of_node = np;
spi-sc18is602.c:295:	master->min_speed_hz = hw->freq / 128;
spi-sc18is602.c:296:	master->max_speed_hz = hw->freq / 4;
spi-rb4xx.c:22:#include <asm/mach-ath79/ar71xx_regs.h>
spi-rb4xx.c:31:	return __raw_readl(rbspi->base + reg);
spi-rb4xx.c:36:	__raw_writel(value, rbspi->base + reg);
spi-rb4xx.c:55:	for (i = 7; i >= 0; i--)
spi-rb4xx.c:86:	struct rb4xx_spi *rbspi = spi_master_get_devdata(spi->master);
spi-rb4xx.c:113:	if (spi->chip_select == 2)
spi-rb4xx.c:120:	tx_buf = t->tx_buf;
spi-rb4xx.c:121:	rx_buf = t->rx_buf;
spi-rb4xx.c:122:	for (i = 0; i < t->len; ++i) {
spi-rb4xx.c:123:		if (t->tx_nbits == SPI_NBITS_DUAL)
spi-rb4xx.c:124:			/* CPLD can use two-wire transfers */
spi-rb4xx.c:147:	spi_base = devm_ioremap_resource(&pdev->dev, r);
spi-rb4xx.c:151:	master = spi_alloc_master(&pdev->dev, sizeof(*rbspi));
spi-rb4xx.c:153:		return -ENOMEM;
spi-rb4xx.c:155:	ahb_clk = devm_clk_get(&pdev->dev, "ahb");
spi-rb4xx.c:159:	master->bus_num = 0;
spi-rb4xx.c:160:	master->num_chipselect = 3;
spi-rb4xx.c:161:	master->mode_bits = SPI_TX_DUAL;
spi-rb4xx.c:162:	master->bits_per_word_mask = BIT(7);
spi-rb4xx.c:163:	master->flags = SPI_MASTER_MUST_TX;
spi-rb4xx.c:164:	master->transfer_one = rb4xx_transfer_one;
spi-rb4xx.c:165:	master->set_cs = rb4xx_set_cs;
spi-rb4xx.c:167:	err = devm_spi_register_master(&pdev->dev, master);
spi-rb4xx.c:169:		dev_err(&pdev->dev, "failed to register SPI master\n");
spi-rb4xx.c:178:	rbspi->base = spi_base;
spi-rb4xx.c:179:	rbspi->clk = ahb_clk;
spi-rb4xx.c:192:	clk_disable_unprepare(rbspi->clk);
spi-rb4xx.c:201:		.name = "rb4xx-spi",
spi-sh-sci.c:37:#define SCSPTR(sp)	(sp->membase + 0x1c)
spi-sh-sci.c:49:	 * This makes regular read-modify-write difficult so we
spi-sh-sci.c:50:	 * use sp->val to keep track of the latest register value.
spi-sh-sci.c:54:		sp->val |= bits;
spi-sh-sci.c:56:		sp->val &= ~bits;
spi-sh-sci.c:58:	iowrite8(sp->val, SCSPTR(sp));
spi-sh-sci.c:63:	setbits(spi_master_get_devdata(dev->master), PIN_SCK, on);
spi-sh-sci.c:68:	setbits(spi_master_get_devdata(dev->master), PIN_TXD, on);
spi-sh-sci.c:73:	struct sh_sci_spi *sp = spi_master_get_devdata(dev->master);
spi-sh-sci.c:80:#include "spi-bitbang-txrx.h"
spi-sh-sci.c:108:	struct sh_sci_spi *sp = spi_master_get_devdata(dev->master);
spi-sh-sci.c:110:	if (sp->info->chip_select)
spi-sh-sci.c:111:		(sp->info->chip_select)(sp->info, dev->chip_select, value);
spi-sh-sci.c:121:	master = spi_alloc_master(&dev->dev, sizeof(struct sh_sci_spi));
spi-sh-sci.c:123:		dev_err(&dev->dev, "failed to allocate spi master\n");
spi-sh-sci.c:124:		ret = -ENOMEM;
spi-sh-sci.c:131:	sp->info = dev_get_platdata(&dev->dev);
spi-sh-sci.c:132:	if (!sp->info) {
spi-sh-sci.c:133:		dev_err(&dev->dev, "platform data is missing\n");
spi-sh-sci.c:134:		ret = -ENOENT;
spi-sh-sci.c:139:	sp->bitbang.master = master;
spi-sh-sci.c:140:	sp->bitbang.master->bus_num = sp->info->bus_num;
spi-sh-sci.c:141:	sp->bitbang.master->num_chipselect = sp->info->num_chipselect;
spi-sh-sci.c:142:	sp->bitbang.chipselect = sh_sci_spi_chipselect;
spi-sh-sci.c:144:	sp->bitbang.txrx_word[SPI_MODE_0] = sh_sci_spi_txrx_mode0;
spi-sh-sci.c:145:	sp->bitbang.txrx_word[SPI_MODE_1] = sh_sci_spi_txrx_mode1;
spi-sh-sci.c:146:	sp->bitbang.txrx_word[SPI_MODE_2] = sh_sci_spi_txrx_mode2;
spi-sh-sci.c:147:	sp->bitbang.txrx_word[SPI_MODE_3] = sh_sci_spi_txrx_mode3;
spi-sh-sci.c:151:		ret = -ENOENT;
spi-sh-sci.c:154:	sp->membase = ioremap(r->start, resource_size(r));
spi-sh-sci.c:155:	if (!sp->membase) {
spi-sh-sci.c:156:		ret = -ENXIO;
spi-sh-sci.c:159:	sp->val = ioread8(SCSPTR(sp));
spi-sh-sci.c:162:	ret = spi_bitbang_start(&sp->bitbang);
spi-sh-sci.c:167:	iounmap(sp->membase);
spi-sh-sci.c:169:	spi_master_put(sp->bitbang.master);
spi-sh-sci.c:178:	spi_bitbang_stop(&sp->bitbang);
spi-sh-sci.c:180:	iounmap(sp->membase);
spi-sh-sci.c:181:	spi_master_put(sp->bitbang.master);
spi-lm70llp.c:2: * Driver for LM70EVAL-LLP board for the LM70 sensor
spi-lm70llp.c:32: * The LM70 communicates with a host processor using a 3-wire variant of
spi-lm70llp.c:35: * port to bitbang an SPI-parport bridge.  Accordingly, this is an SPI
spi-lm70llp.c:42: * The schematic for this particular board (the LM70EVAL-LLP) is
spi-lm70llp.c:46: * Also see Documentation/spi/spi-lm70llp.  The SPI<->parport code here is
spi-lm70llp.c:47: * (heavily) based on spi-butterfly by David Brownell.
spi-lm70llp.c:53: *  -----------  ---------  ------------
spi-lm70llp.c:54: *      D0    2      -         -
spi-lm70llp.c:55: *      D1    3     -->      V+   5
spi-lm70llp.c:56: *      D2    4     -->      V+   5
spi-lm70llp.c:57: *      D3    5     -->      V+   5
spi-lm70llp.c:58: *      D4    6     -->      V+   5
spi-lm70llp.c:59: *      D5    7     -->      nCS  8
spi-lm70llp.c:60: *      D6    8     -->      SCLK 3
spi-lm70llp.c:61: *      D7    9     -->      SI/O 5
spi-lm70llp.c:62: *     GND   25      -       GND  7
spi-lm70llp.c:63: *    Select 13     <--      SI/O 1
spi-lm70llp.c:70:#define DRVNAME		"spi-lm70llp"
spi-lm70llp.c:77:/*-------------------------------------------------------------------------*/
spi-lm70llp.c:92:/*-------------------------------------------------------------------*/
spi-lm70llp.c:96:	return spi->controller_data;
spi-lm70llp.c:99:/*---------------------- LM70 LLP eval board-specific inlines follow */
spi-lm70llp.c:108:	u8 data = parport_read_data(pp->port);
spi-lm70llp.c:110:	data &= ~0x80;		/* pull D7/SI-out low while de-asserted */
spi-lm70llp.c:111:	parport_write_data(pp->port, data | nCS);
spi-lm70llp.c:116:	u8 data = parport_read_data(pp->port);
spi-lm70llp.c:118:	data |= 0x80;		/* pull D7/SI-out high so lm70 drives SO-in */
spi-lm70llp.c:119:	parport_write_data(pp->port, data & ~nCS);
spi-lm70llp.c:124:	u8 data = parport_read_data(pp->port);
spi-lm70llp.c:125:	parport_write_data(pp->port, data | SCLK);
spi-lm70llp.c:130:	u8 data = parport_read_data(pp->port);
spi-lm70llp.c:131:	parport_write_data(pp->port, data & ~SCLK);
spi-lm70llp.c:134:/*------------------------- SPI-LM70-specific inlines ----------------------*/
spi-lm70llp.c:161: * Why do we return 0 when the SIO line is high and vice-versa?
spi-lm70llp.c:164: * switches it to low reflecting this on the parport (pin 13), and vice-versa.
spi-lm70llp.c:169:	return ((SIO == (parport_read_status(pp->port) & SIO)) ? 0 : 1 );
spi-lm70llp.c:171:/*--------------------------------------------------------------------*/
spi-lm70llp.c:173:#include "spi-bitbang-txrx.h"
spi-lm70llp.c:211:	master = spi_alloc_master(p->physport->dev, sizeof *pp);
spi-lm70llp.c:213:		status = -ENOMEM;
spi-lm70llp.c:221:	pp->bitbang.master = master;
spi-lm70llp.c:222:	pp->bitbang.chipselect = lm70_chipselect;
spi-lm70llp.c:223:	pp->bitbang.txrx_word[SPI_MODE_0] = lm70_txrx;
spi-lm70llp.c:224:	pp->bitbang.flags = SPI_3WIRE;
spi-lm70llp.c:229:	pp->port = p;
spi-lm70llp.c:234:		status = -ENOMEM;
spi-lm70llp.c:237:	pp->pd = pd;
spi-lm70llp.c:246:	status = spi_bitbang_start(&pp->bitbang);
spi-lm70llp.c:260:	strcpy(pp->info.modalias, "lm70");
spi-lm70llp.c:261:	pp->info.max_speed_hz = 6 * 1000 * 1000;
spi-lm70llp.c:262:	pp->info.chip_select = 0;
spi-lm70llp.c:263:	pp->info.mode = SPI_3WIRE | SPI_MODE_0;
spi-lm70llp.c:266:	parport_write_data(pp->port, lm70_INIT);
spi-lm70llp.c:271:	pp->info.controller_data = pp;
spi-lm70llp.c:272:	pp->spidev_lm70 = spi_new_device(pp->bitbang.master, &pp->info);
spi-lm70llp.c:273:	if (pp->spidev_lm70)
spi-lm70llp.c:274:		dev_dbg(&pp->spidev_lm70->dev, "spidev_lm70 at %s\n",
spi-lm70llp.c:275:				dev_name(&pp->spidev_lm70->dev));
spi-lm70llp.c:278:		status = -ENODEV;
spi-lm70llp.c:281:	pp->spidev_lm70->bits_per_word = 8;
spi-lm70llp.c:287:	spi_bitbang_stop(&pp->bitbang);
spi-lm70llp.c:290:	parport_write_data(pp->port, 0);
spi-lm70llp.c:292:	parport_release(pp->pd);
spi-lm70llp.c:305:	if (!lm70llp || lm70llp->port != p)
spi-lm70llp.c:309:	spi_bitbang_stop(&pp->bitbang);
spi-lm70llp.c:312:	parport_write_data(pp->port, 0);
spi-lm70llp.c:314:	parport_release(pp->pd);
spi-lm70llp.c:315:	parport_unregister_device(pp->pd);
spi-lm70llp.c:317:	(void) spi_master_put(pp->bitbang.master);
spi-s3c64xx.c:21:#include <linux/dma-mapping.h>
spi-s3c64xx.c:30:#include <linux/platform_data/spi-s3c64xx.h>
spi-s3c64xx.c:37:/* Registers and bit-fields */
spi-s3c64xx.c:115:#define FIFO_LVL_MASK(i) ((i)->port_conf->fifo_lvl_mask[i->port_id])
spi-s3c64xx.c:117:				(1 << (i)->port_conf->tx_st_done)) ? 1 : 0)
spi-s3c64xx.c:119:#define RX_FIFO_LVL(v, i) (((v) >> (i)->port_conf->rx_lvl_offset) & \
spi-s3c64xx.c:128:#define is_polling(x)	(x->port_conf->quirks & S3C64XX_SPI_QUIRK_POLL)
spi-s3c64xx.c:140: * struct s3c64xx_spi_info - SPI Controller hardware info
spi-s3c64xx.c:141: * @fifo_lvl_mask: Bit-mask for {TX|RX}_FIFO_LVL bits in SPI_STATUS register.
spi-s3c64xx.c:163: * struct s3c64xx_spi_driver_data - Runtime info holder for SPI driver.
spi-s3c64xx.c:203:	void __iomem *regs = sdd->regs;
spi-s3c64xx.c:222:	} while (TX_FIFO_LVL(val, sdd) && loops--);
spi-s3c64xx.c:225:		dev_warn(&sdd->pdev->dev, "Timed out flushing TX FIFO\n");
spi-s3c64xx.c:235:	} while (loops--);
spi-s3c64xx.c:238:		dev_warn(&sdd->pdev->dev, "Timed out flushing RX FIFO\n");
spi-s3c64xx.c:255:	if (dma->direction == DMA_DEV_TO_MEM)
spi-s3c64xx.c:262:	spin_lock_irqsave(&sdd->lock, flags);
spi-s3c64xx.c:264:	if (dma->direction == DMA_DEV_TO_MEM) {
spi-s3c64xx.c:265:		sdd->state &= ~RXBUSY;
spi-s3c64xx.c:266:		if (!(sdd->state & TXBUSY))
spi-s3c64xx.c:267:			complete(&sdd->xfer_completion);
spi-s3c64xx.c:269:		sdd->state &= ~TXBUSY;
spi-s3c64xx.c:270:		if (!(sdd->state & RXBUSY))
spi-s3c64xx.c:271:			complete(&sdd->xfer_completion);
spi-s3c64xx.c:274:	spin_unlock_irqrestore(&sdd->lock, flags);
spi-s3c64xx.c:286:	if (dma->direction == DMA_DEV_TO_MEM) {
spi-s3c64xx.c:289:		config.direction = dma->direction;
spi-s3c64xx.c:290:		config.src_addr = sdd->sfr_start + S3C64XX_SPI_RX_DATA;
spi-s3c64xx.c:291:		config.src_addr_width = sdd->cur_bpw / 8;
spi-s3c64xx.c:293:		dmaengine_slave_config(dma->ch, &config);
spi-s3c64xx.c:297:		config.direction = dma->direction;
spi-s3c64xx.c:298:		config.dst_addr = sdd->sfr_start + S3C64XX_SPI_TX_DATA;
spi-s3c64xx.c:299:		config.dst_addr_width = sdd->cur_bpw / 8;
spi-s3c64xx.c:301:		dmaengine_slave_config(dma->ch, &config);
spi-s3c64xx.c:304:	desc = dmaengine_prep_slave_sg(dma->ch, sgt->sgl, sgt->nents,
spi-s3c64xx.c:305:				       dma->direction, DMA_PREP_INTERRUPT);
spi-s3c64xx.c:307:	desc->callback = s3c64xx_spi_dmacb;
spi-s3c64xx.c:308:	desc->callback_param = dma;
spi-s3c64xx.c:311:	dma_async_issue_pending(dma->ch);
spi-s3c64xx.c:317:	dma_filter_fn filter = sdd->cntrlr_info->filter;
spi-s3c64xx.c:318:	struct device *dev = &sdd->pdev->dev;
spi-s3c64xx.c:327:		sdd->rx_dma.ch = dma_request_slave_channel_compat(mask, filter,
spi-s3c64xx.c:328:				   (void *)(long)sdd->rx_dma.dmach, dev, "rx");
spi-s3c64xx.c:329:		if (!sdd->rx_dma.ch) {
spi-s3c64xx.c:331:			ret = -EBUSY;
spi-s3c64xx.c:334:		spi->dma_rx = sdd->rx_dma.ch;
spi-s3c64xx.c:336:		sdd->tx_dma.ch = dma_request_slave_channel_compat(mask, filter,
spi-s3c64xx.c:337:				   (void *)(long)sdd->tx_dma.dmach, dev, "tx");
spi-s3c64xx.c:338:		if (!sdd->tx_dma.ch) {
spi-s3c64xx.c:340:			ret = -EBUSY;
spi-s3c64xx.c:343:		spi->dma_tx = sdd->tx_dma.ch;
spi-s3c64xx.c:349:	dma_release_channel(sdd->rx_dma.ch);
spi-s3c64xx.c:360:		dma_release_channel(sdd->rx_dma.ch);
spi-s3c64xx.c:361:		dma_release_channel(sdd->tx_dma.ch);
spi-s3c64xx.c:373:	return xfer->len > (FIFO_LVL_MASK(sdd) >> 1) + 1;
spi-s3c64xx.c:380:	void __iomem *regs = sdd->regs;
spi-s3c64xx.c:397:		writel(((xfer->len * 8 / sdd->cur_bpw) & 0xffff)
spi-s3c64xx.c:402:	if (xfer->tx_buf != NULL) {
spi-s3c64xx.c:403:		sdd->state |= TXBUSY;
spi-s3c64xx.c:407:			prepare_dma(&sdd->tx_dma, &xfer->tx_sg);
spi-s3c64xx.c:409:			switch (sdd->cur_bpw) {
spi-s3c64xx.c:412:					xfer->tx_buf, xfer->len / 4);
spi-s3c64xx.c:416:					xfer->tx_buf, xfer->len / 2);
spi-s3c64xx.c:420:					xfer->tx_buf, xfer->len);
spi-s3c64xx.c:426:	if (xfer->rx_buf != NULL) {
spi-s3c64xx.c:427:		sdd->state |= RXBUSY;
spi-s3c64xx.c:429:		if (sdd->port_conf->high_speed && sdd->cur_speed >= 30000000UL
spi-s3c64xx.c:430:					&& !(sdd->cur_mode & SPI_CPHA))
spi-s3c64xx.c:436:			writel(((xfer->len * 8 / sdd->cur_bpw) & 0xffff)
spi-s3c64xx.c:439:			prepare_dma(&sdd->rx_dma, &xfer->rx_sg);
spi-s3c64xx.c:450:	void __iomem *regs = sdd->regs;
spi-s3c64xx.c:462:	} while (RX_FIFO_LVL(status, sdd) < max_fifo && --val);
spi-s3c64xx.c:471:	void __iomem *regs = sdd->regs;
spi-s3c64xx.c:477:	ms = xfer->len * 8 * 1000 / sdd->cur_speed;
spi-s3c64xx.c:481:	val = wait_for_completion_timeout(&sdd->xfer_completion, val);
spi-s3c64xx.c:485:	 * proceed further else return -EIO.
spi-s3c64xx.c:492:	if (val && !xfer->rx_buf) {
spi-s3c64xx.c:497:		       && --val) {
spi-s3c64xx.c:506:		return -EIO;
spi-s3c64xx.c:514:	void __iomem *regs = sdd->regs;
spi-s3c64xx.c:523:	ms = xfer->len * 8 * 1000 / sdd->cur_speed;
spi-s3c64xx.c:529:	} while (RX_FIFO_LVL(status, sdd) < xfer->len && --val);
spi-s3c64xx.c:533:	if (!xfer->rx_buf) {
spi-s3c64xx.c:534:		sdd->state &= ~TXBUSY;
spi-s3c64xx.c:546:	loops = xfer->len / ((FIFO_LVL_MASK(sdd) >> 1) + 1);
spi-s3c64xx.c:547:	buf = xfer->rx_buf;
spi-s3c64xx.c:553:		switch (sdd->cur_bpw) {
spi-s3c64xx.c:569:	} while (loops--);
spi-s3c64xx.c:570:	sdd->state &= ~RXBUSY;
spi-s3c64xx.c:577:	void __iomem *regs = sdd->regs;
spi-s3c64xx.c:581:	if (sdd->port_conf->clk_from_cmu) {
spi-s3c64xx.c:582:		clk_disable_unprepare(sdd->src_clk);
spi-s3c64xx.c:595:	if (sdd->cur_mode & SPI_CPOL)
spi-s3c64xx.c:598:	if (sdd->cur_mode & SPI_CPHA)
spi-s3c64xx.c:608:	switch (sdd->cur_bpw) {
spi-s3c64xx.c:625:	if (sdd->port_conf->clk_from_cmu) {
spi-s3c64xx.c:627:		/* There is half-multiplier before the SPI */
spi-s3c64xx.c:628:		clk_set_rate(sdd->src_clk, sdd->cur_speed * 2);
spi-s3c64xx.c:630:		clk_prepare_enable(sdd->src_clk);
spi-s3c64xx.c:635:		val |= ((clk_get_rate(sdd->src_clk) / sdd->cur_speed / 2 - 1)
spi-s3c64xx.c:652:	struct spi_device *spi = msg->spi;
spi-s3c64xx.c:653:	struct s3c64xx_spi_csinfo *cs = spi->controller_data;
spi-s3c64xx.c:656:	if (sdd->cur_speed != spi->max_speed_hz
spi-s3c64xx.c:657:			|| sdd->cur_mode != spi->mode
spi-s3c64xx.c:658:			|| sdd->cur_bpw != spi->bits_per_word) {
spi-s3c64xx.c:659:		sdd->cur_bpw = spi->bits_per_word;
spi-s3c64xx.c:660:		sdd->cur_speed = spi->max_speed_hz;
spi-s3c64xx.c:661:		sdd->cur_mode = spi->mode;
spi-s3c64xx.c:666:	writel(cs->fb_delay & 0x3, sdd->regs + S3C64XX_SPI_FB_CLK);
spi-s3c64xx.c:682:	reinit_completion(&sdd->xfer_completion);
spi-s3c64xx.c:685:	bpw = xfer->bits_per_word;
spi-s3c64xx.c:686:	speed = xfer->speed_hz;
spi-s3c64xx.c:688:	if (bpw != sdd->cur_bpw || speed != sdd->cur_speed) {
spi-s3c64xx.c:689:		sdd->cur_bpw = bpw;
spi-s3c64xx.c:690:		sdd->cur_speed = speed;
spi-s3c64xx.c:697:	    (sdd->rx_dma.ch && sdd->tx_dma.ch &&
spi-s3c64xx.c:698:	     (xfer->len > ((FIFO_LVL_MASK(sdd) >> 1) + 1))))
spi-s3c64xx.c:701:	spin_lock_irqsave(&sdd->lock, flags);
spi-s3c64xx.c:704:	sdd->state &= ~RXBUSY;
spi-s3c64xx.c:705:	sdd->state &= ~TXBUSY;
spi-s3c64xx.c:710:	if (!(sdd->port_conf->quirks & S3C64XX_SPI_QUIRK_CS_AUTO))
spi-s3c64xx.c:711:		writel(0, sdd->regs + S3C64XX_SPI_SLAVE_SEL);
spi-s3c64xx.c:713:		writel(readl(sdd->regs + S3C64XX_SPI_SLAVE_SEL)
spi-s3c64xx.c:715:			sdd->regs + S3C64XX_SPI_SLAVE_SEL);
spi-s3c64xx.c:717:	spin_unlock_irqrestore(&sdd->lock, flags);
spi-s3c64xx.c:725:		dev_err(&spi->dev, "I/O Error: rx-%d tx-%d res:rx-%c tx-%c len-%d\n",
spi-s3c64xx.c:726:			xfer->rx_buf ? 1 : 0, xfer->tx_buf ? 1 : 0,
spi-s3c64xx.c:727:			(sdd->state & RXBUSY) ? 'f' : 'p',
spi-s3c64xx.c:728:			(sdd->state & TXBUSY) ? 'f' : 'p',
spi-s3c64xx.c:729:			xfer->len);
spi-s3c64xx.c:732:			if (xfer->tx_buf != NULL
spi-s3c64xx.c:733:			    && (sdd->state & TXBUSY))
spi-s3c64xx.c:734:				dmaengine_terminate_all(sdd->tx_dma.ch);
spi-s3c64xx.c:735:			if (xfer->rx_buf != NULL
spi-s3c64xx.c:736:			    && (sdd->state & RXBUSY))
spi-s3c64xx.c:737:				dmaengine_terminate_all(sdd->rx_dma.ch);
spi-s3c64xx.c:753:	slave_np = spi->dev.of_node;
spi-s3c64xx.c:755:		dev_err(&spi->dev, "device node not found\n");
spi-s3c64xx.c:756:		return ERR_PTR(-EINVAL);
spi-s3c64xx.c:759:	data_np = of_get_child_by_name(slave_np, "controller-data");
spi-s3c64xx.c:761:		dev_err(&spi->dev, "child node 'controller-data' not found\n");
spi-s3c64xx.c:762:		return ERR_PTR(-EINVAL);
spi-s3c64xx.c:768:		return ERR_PTR(-ENOMEM);
spi-s3c64xx.c:771:	of_property_read_u32(data_np, "samsung,spi-feedback-delay", &fb_delay);
spi-s3c64xx.c:772:	cs->fb_delay = fb_delay;
spi-s3c64xx.c:779: * and save the configuration in a local data-structure.
spi-s3c64xx.c:785:	struct s3c64xx_spi_csinfo *cs = spi->controller_data;
spi-s3c64xx.c:790:	sdd = spi_master_get_devdata(spi->master);
spi-s3c64xx.c:791:	if (spi->dev.of_node) {
spi-s3c64xx.c:793:		spi->controller_data = cs;
spi-s3c64xx.c:795:		/* On non-DT platforms the SPI core will set spi->cs_gpio
spi-s3c64xx.c:796:		 * to -ENOENT. The GPIO pin used to drive the chip select
spi-s3c64xx.c:797:		 * is defined by using platform data so spi->cs_gpio value
spi-s3c64xx.c:800:		spi->cs_gpio = cs->line;
spi-s3c64xx.c:804:		dev_err(&spi->dev, "No CS for SPI(%d)\n", spi->chip_select);
spi-s3c64xx.c:805:		return -ENODEV;
spi-s3c64xx.c:809:		if (gpio_is_valid(spi->cs_gpio)) {
spi-s3c64xx.c:810:			err = gpio_request_one(spi->cs_gpio, GPIOF_OUT_INIT_HIGH,
spi-s3c64xx.c:811:					       dev_name(&spi->dev));
spi-s3c64xx.c:813:				dev_err(&spi->dev,
spi-s3c64xx.c:815:					spi->cs_gpio, err);
spi-s3c64xx.c:823:	sci = sdd->cntrlr_info;
spi-s3c64xx.c:825:	pm_runtime_get_sync(&sdd->pdev->dev);
spi-s3c64xx.c:828:	if (!sdd->port_conf->clk_from_cmu) {
spi-s3c64xx.c:832:		speed = clk_get_rate(sdd->src_clk) / 2 / (0 + 1);
spi-s3c64xx.c:834:		if (spi->max_speed_hz > speed)
spi-s3c64xx.c:835:			spi->max_speed_hz = speed;
spi-s3c64xx.c:837:		psr = clk_get_rate(sdd->src_clk) / 2 / spi->max_speed_hz - 1;
spi-s3c64xx.c:840:			psr--;
spi-s3c64xx.c:842:		speed = clk_get_rate(sdd->src_clk) / 2 / (psr + 1);
spi-s3c64xx.c:843:		if (spi->max_speed_hz < speed) {
spi-s3c64xx.c:847:				err = -EINVAL;
spi-s3c64xx.c:852:		speed = clk_get_rate(sdd->src_clk) / 2 / (psr + 1);
spi-s3c64xx.c:853:		if (spi->max_speed_hz >= speed) {
spi-s3c64xx.c:854:			spi->max_speed_hz = speed;
spi-s3c64xx.c:856:			dev_err(&spi->dev, "Can't set %dHz transfer speed\n",
spi-s3c64xx.c:857:				spi->max_speed_hz);
spi-s3c64xx.c:858:			err = -EINVAL;
spi-s3c64xx.c:863:	pm_runtime_mark_last_busy(&sdd->pdev->dev);
spi-s3c64xx.c:864:	pm_runtime_put_autosuspend(&sdd->pdev->dev);
spi-s3c64xx.c:865:	if (!(sdd->port_conf->quirks & S3C64XX_SPI_QUIRK_CS_AUTO))
spi-s3c64xx.c:866:		writel(S3C64XX_SPI_SLAVE_SIG_INACT, sdd->regs + S3C64XX_SPI_SLAVE_SEL);
spi-s3c64xx.c:870:	pm_runtime_mark_last_busy(&sdd->pdev->dev);
spi-s3c64xx.c:871:	pm_runtime_put_autosuspend(&sdd->pdev->dev);
spi-s3c64xx.c:872:	/* setup() returns with device de-selected */
spi-s3c64xx.c:873:	if (!(sdd->port_conf->quirks & S3C64XX_SPI_QUIRK_CS_AUTO))
spi-s3c64xx.c:874:		writel(S3C64XX_SPI_SLAVE_SIG_INACT, sdd->regs + S3C64XX_SPI_SLAVE_SEL);
spi-s3c64xx.c:876:	if (gpio_is_valid(spi->cs_gpio))
spi-s3c64xx.c:877:		gpio_free(spi->cs_gpio);
spi-s3c64xx.c:881:	if (spi->dev.of_node)
spi-s3c64xx.c:891:	if (gpio_is_valid(spi->cs_gpio)) {
spi-s3c64xx.c:892:		gpio_free(spi->cs_gpio);
spi-s3c64xx.c:893:		if (spi->dev.of_node)
spi-s3c64xx.c:896:			/* On non-DT platforms, the SPI core sets
spi-s3c64xx.c:897:			 * spi->cs_gpio to -ENOENT and .setup()
spi-s3c64xx.c:901:			spi->cs_gpio = -ENOENT;
spi-s3c64xx.c:911:	struct spi_master *spi = sdd->master;
spi-s3c64xx.c:914:	val = readl(sdd->regs + S3C64XX_SPI_STATUS);
spi-s3c64xx.c:918:		dev_err(&spi->dev, "RX overrun\n");
spi-s3c64xx.c:922:		dev_err(&spi->dev, "RX underrun\n");
spi-s3c64xx.c:926:		dev_err(&spi->dev, "TX overrun\n");
spi-s3c64xx.c:930:		dev_err(&spi->dev, "TX underrun\n");
spi-s3c64xx.c:934:	writel(clr, sdd->regs + S3C64XX_SPI_PENDING_CLR);
spi-s3c64xx.c:935:	writel(0, sdd->regs + S3C64XX_SPI_PENDING_CLR);
spi-s3c64xx.c:942:	struct s3c64xx_spi_info *sci = sdd->cntrlr_info;
spi-s3c64xx.c:943:	void __iomem *regs = sdd->regs;
spi-s3c64xx.c:946:	sdd->cur_speed = 0;
spi-s3c64xx.c:948:	if (!(sdd->port_conf->quirks & S3C64XX_SPI_QUIRK_CS_AUTO))
spi-s3c64xx.c:949:		writel(S3C64XX_SPI_SLAVE_SIG_INACT, sdd->regs + S3C64XX_SPI_SLAVE_SEL);
spi-s3c64xx.c:951:	/* Disable Interrupts - we use Polling if not DMA mode */
spi-s3c64xx.c:954:	if (!sdd->port_conf->clk_from_cmu)
spi-s3c64xx.c:955:		writel(sci->src_clk_nr << S3C64XX_SPI_CLKSEL_SRCSHFT,
spi-s3c64xx.c:987:		return ERR_PTR(-ENOMEM);
spi-s3c64xx.c:989:	if (of_property_read_u32(dev->of_node, "samsung,spi-src-clk", &temp)) {
spi-s3c64xx.c:991:		sci->src_clk_nr = 0;
spi-s3c64xx.c:993:		sci->src_clk_nr = temp;
spi-s3c64xx.c:996:	if (of_property_read_u32(dev->of_node, "num-cs", &temp)) {
spi-s3c64xx.c:998:		sci->num_cs = 1;
spi-s3c64xx.c:1000:		sci->num_cs = temp;
spi-s3c64xx.c:1018:	if (pdev->dev.of_node) {
spi-s3c64xx.c:1020:		match = of_match_node(s3c64xx_spi_dt_match, pdev->dev.of_node);
spi-s3c64xx.c:1021:		return (struct s3c64xx_spi_port_config *)match->data;
spi-s3c64xx.c:1025:			 platform_get_device_id(pdev)->driver_data;
spi-s3c64xx.c:1033:	struct s3c64xx_spi_info *sci = dev_get_platdata(&pdev->dev);
spi-s3c64xx.c:1038:	if (!sci && pdev->dev.of_node) {
spi-s3c64xx.c:1039:		sci = s3c64xx_spi_parse_dt(&pdev->dev);
spi-s3c64xx.c:1045:		dev_err(&pdev->dev, "platform_data missing!\n");
spi-s3c64xx.c:1046:		return -ENODEV;
spi-s3c64xx.c:1051:		dev_err(&pdev->dev, "Unable to get SPI MEM resource\n");
spi-s3c64xx.c:1052:		return -ENXIO;
spi-s3c64xx.c:1057:		dev_warn(&pdev->dev, "Failed to get IRQ: %d\n", irq);
spi-s3c64xx.c:1061:	master = spi_alloc_master(&pdev->dev,
spi-s3c64xx.c:1064:		dev_err(&pdev->dev, "Unable to allocate SPI Master\n");
spi-s3c64xx.c:1065:		return -ENOMEM;
spi-s3c64xx.c:1071:	sdd->port_conf = s3c64xx_spi_get_port_config(pdev);
spi-s3c64xx.c:1072:	sdd->master = master;
spi-s3c64xx.c:1073:	sdd->cntrlr_info = sci;
spi-s3c64xx.c:1074:	sdd->pdev = pdev;
spi-s3c64xx.c:1075:	sdd->sfr_start = mem_res->start;
spi-s3c64xx.c:1076:	if (pdev->dev.of_node) {
spi-s3c64xx.c:1077:		ret = of_alias_get_id(pdev->dev.of_node, "spi");
spi-s3c64xx.c:1079:			dev_err(&pdev->dev, "failed to get alias id, errno %d\n",
spi-s3c64xx.c:1083:		sdd->port_id = ret;
spi-s3c64xx.c:1085:		sdd->port_id = pdev->id;
spi-s3c64xx.c:1088:	sdd->cur_bpw = 8;
spi-s3c64xx.c:1090:	if (!sdd->pdev->dev.of_node) {
spi-s3c64xx.c:1093:			dev_warn(&pdev->dev, "Unable to get SPI tx dma resource. Switching to poll mode\n");
spi-s3c64xx.c:1094:			sdd->port_conf->quirks = S3C64XX_SPI_QUIRK_POLL;
spi-s3c64xx.c:1096:			sdd->tx_dma.dmach = res->start;
spi-s3c64xx.c:1100:			dev_warn(&pdev->dev, "Unable to get SPI rx dma resource. Switching to poll mode\n");
spi-s3c64xx.c:1101:			sdd->port_conf->quirks = S3C64XX_SPI_QUIRK_POLL;
spi-s3c64xx.c:1103:			sdd->rx_dma.dmach = res->start;
spi-s3c64xx.c:1106:	sdd->tx_dma.direction = DMA_MEM_TO_DEV;
spi-s3c64xx.c:1107:	sdd->rx_dma.direction = DMA_DEV_TO_MEM;
spi-s3c64xx.c:1109:	master->dev.of_node = pdev->dev.of_node;
spi-s3c64xx.c:1110:	master->bus_num = sdd->port_id;
spi-s3c64xx.c:1111:	master->setup = s3c64xx_spi_setup;
spi-s3c64xx.c:1112:	master->cleanup = s3c64xx_spi_cleanup;
spi-s3c64xx.c:1113:	master->prepare_transfer_hardware = s3c64xx_spi_prepare_transfer;
spi-s3c64xx.c:1114:	master->prepare_message = s3c64xx_spi_prepare_message;
spi-s3c64xx.c:1115:	master->transfer_one = s3c64xx_spi_transfer_one;
spi-s3c64xx.c:1116:	master->unprepare_transfer_hardware = s3c64xx_spi_unprepare_transfer;
spi-s3c64xx.c:1117:	master->num_chipselect = sci->num_cs;
spi-s3c64xx.c:1118:	master->dma_alignment = 8;
spi-s3c64xx.c:1119:	master->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(16) |
spi-s3c64xx.c:1121:	/* the spi->mode bits understood by this driver: */
spi-s3c64xx.c:1122:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-s3c64xx.c:1123:	master->auto_runtime_pm = true;
spi-s3c64xx.c:1125:		master->can_dma = s3c64xx_spi_can_dma;
spi-s3c64xx.c:1127:	sdd->regs = devm_ioremap_resource(&pdev->dev, mem_res);
spi-s3c64xx.c:1128:	if (IS_ERR(sdd->regs)) {
spi-s3c64xx.c:1129:		ret = PTR_ERR(sdd->regs);
spi-s3c64xx.c:1133:	if (sci->cfg_gpio && sci->cfg_gpio()) {
spi-s3c64xx.c:1134:		dev_err(&pdev->dev, "Unable to config gpio\n");
spi-s3c64xx.c:1135:		ret = -EBUSY;
spi-s3c64xx.c:1140:	sdd->clk = devm_clk_get(&pdev->dev, "spi");
spi-s3c64xx.c:1141:	if (IS_ERR(sdd->clk)) {
spi-s3c64xx.c:1142:		dev_err(&pdev->dev, "Unable to acquire clock 'spi'\n");
spi-s3c64xx.c:1143:		ret = PTR_ERR(sdd->clk);
spi-s3c64xx.c:1147:	if (clk_prepare_enable(sdd->clk)) {
spi-s3c64xx.c:1148:		dev_err(&pdev->dev, "Couldn't enable clock 'spi'\n");
spi-s3c64xx.c:1149:		ret = -EBUSY;
spi-s3c64xx.c:1153:	sprintf(clk_name, "spi_busclk%d", sci->src_clk_nr);
spi-s3c64xx.c:1154:	sdd->src_clk = devm_clk_get(&pdev->dev, clk_name);
spi-s3c64xx.c:1155:	if (IS_ERR(sdd->src_clk)) {
spi-s3c64xx.c:1156:		dev_err(&pdev->dev,
spi-s3c64xx.c:1158:		ret = PTR_ERR(sdd->src_clk);
spi-s3c64xx.c:1162:	if (clk_prepare_enable(sdd->src_clk)) {
spi-s3c64xx.c:1163:		dev_err(&pdev->dev, "Couldn't enable clock '%s'\n", clk_name);
spi-s3c64xx.c:1164:		ret = -EBUSY;
spi-s3c64xx.c:1168:	pm_runtime_set_autosuspend_delay(&pdev->dev, AUTOSUSPEND_TIMEOUT);
spi-s3c64xx.c:1169:	pm_runtime_use_autosuspend(&pdev->dev);
spi-s3c64xx.c:1170:	pm_runtime_set_active(&pdev->dev);
spi-s3c64xx.c:1171:	pm_runtime_enable(&pdev->dev);
spi-s3c64xx.c:1172:	pm_runtime_get_sync(&pdev->dev);
spi-s3c64xx.c:1175:	s3c64xx_spi_hwinit(sdd, sdd->port_id);
spi-s3c64xx.c:1177:	spin_lock_init(&sdd->lock);
spi-s3c64xx.c:1178:	init_completion(&sdd->xfer_completion);
spi-s3c64xx.c:1180:	ret = devm_request_irq(&pdev->dev, irq, s3c64xx_spi_irq, 0,
spi-s3c64xx.c:1181:				"spi-s3c64xx", sdd);
spi-s3c64xx.c:1183:		dev_err(&pdev->dev, "Failed to request IRQ %d: %d\n",
spi-s3c64xx.c:1190:	       sdd->regs + S3C64XX_SPI_INT_EN);
spi-s3c64xx.c:1192:	ret = devm_spi_register_master(&pdev->dev, master);
spi-s3c64xx.c:1194:		dev_err(&pdev->dev, "cannot register SPI master: %d\n", ret);
spi-s3c64xx.c:1198:	dev_dbg(&pdev->dev, "Samsung SoC SPI Driver loaded for Bus SPI-%d with %d Slaves attached\n",
spi-s3c64xx.c:1199:					sdd->port_id, master->num_chipselect);
spi-s3c64xx.c:1200:	dev_dbg(&pdev->dev, "\tIOmem=[%pR]\tFIFO %dbytes\tDMA=[Rx-%d, Tx-%d]\n",
spi-s3c64xx.c:1202:					sdd->rx_dma.dmach, sdd->tx_dma.dmach);
spi-s3c64xx.c:1204:	pm_runtime_mark_last_busy(&pdev->dev);
spi-s3c64xx.c:1205:	pm_runtime_put_autosuspend(&pdev->dev);
spi-s3c64xx.c:1210:	pm_runtime_put_noidle(&pdev->dev);
spi-s3c64xx.c:1211:	pm_runtime_disable(&pdev->dev);
spi-s3c64xx.c:1212:	pm_runtime_set_suspended(&pdev->dev);
spi-s3c64xx.c:1214:	clk_disable_unprepare(sdd->src_clk);
spi-s3c64xx.c:1216:	clk_disable_unprepare(sdd->clk);
spi-s3c64xx.c:1228:	pm_runtime_get_sync(&pdev->dev);
spi-s3c64xx.c:1230:	writel(0, sdd->regs + S3C64XX_SPI_INT_EN);
spi-s3c64xx.c:1232:	clk_disable_unprepare(sdd->src_clk);
spi-s3c64xx.c:1234:	clk_disable_unprepare(sdd->clk);
spi-s3c64xx.c:1236:	pm_runtime_put_noidle(&pdev->dev);
spi-s3c64xx.c:1237:	pm_runtime_disable(&pdev->dev);
spi-s3c64xx.c:1238:	pm_runtime_set_suspended(&pdev->dev);
spi-s3c64xx.c:1257:	sdd->cur_speed = 0; /* Output Clock is stopped */
spi-s3c64xx.c:1266:	struct s3c64xx_spi_info *sci = sdd->cntrlr_info;
spi-s3c64xx.c:1269:	if (sci->cfg_gpio)
spi-s3c64xx.c:1270:		sci->cfg_gpio();
spi-s3c64xx.c:1276:	s3c64xx_spi_hwinit(sdd, sdd->port_id);
spi-s3c64xx.c:1288:	clk_disable_unprepare(sdd->clk);
spi-s3c64xx.c:1289:	clk_disable_unprepare(sdd->src_clk);
spi-s3c64xx.c:1300:	ret = clk_prepare_enable(sdd->src_clk);
spi-s3c64xx.c:1304:	ret = clk_prepare_enable(sdd->clk);
spi-s3c64xx.c:1306:		clk_disable_unprepare(sdd->src_clk);
spi-s3c64xx.c:1368:		.name		= "s3c2443-spi",
spi-s3c64xx.c:1371:		.name		= "s3c6410-spi",
spi-s3c64xx.c:1374:		.name		= "s5pv210-spi",
spi-s3c64xx.c:1377:		.name		= "exynos4210-spi",
spi-s3c64xx.c:1384:	{ .compatible = "samsung,s3c2443-spi",
spi-s3c64xx.c:1387:	{ .compatible = "samsung,s3c6410-spi",
spi-s3c64xx.c:1390:	{ .compatible = "samsung,s5pv210-spi",
spi-s3c64xx.c:1393:	{ .compatible = "samsung,exynos4210-spi",
spi-s3c64xx.c:1396:	{ .compatible = "samsung,exynos5440-spi",
spi-s3c64xx.c:1399:	{ .compatible = "samsung,exynos7-spi",
spi-s3c64xx.c:1408:		.name	= "s3c64xx-spi",
spi-s3c64xx.c:1416:MODULE_ALIAS("platform:s3c64xx-spi");
spi-bitbang-txrx.h:3: * simple SPI master driver.  Two do polled word-at-a-time I/O:
spi-bitbang-txrx.h:5: *   -	GPIO/parport bitbangers.  Provide chipselect() and txrx_word[](),
spi-bitbang-txrx.h:6: *	expanding the per-word routines from the inline templates below.
spi-bitbang-txrx.h:8: *   -	Drivers for controllers resembling bare shift registers.  Provide
spi-bitbang-txrx.h:14: *   -	Drivers leveraging smarter hardware, with fifos or DMA; or for half
spi-bitbang-txrx.h:35: * A non-inlined routine would call bitbang_txrx_*() routines.  The
spi-bitbang-txrx.h:52:	u32 oldbit = (!(word & (1<<(bits-1)))) << 31;
spi-bitbang-txrx.h:54:	for (word <<= (32 - bits); likely(bits); bits--) {
spi-bitbang-txrx.h:84:	u32 oldbit = (!(word & (1<<(bits-1)))) << 31;
spi-bitbang-txrx.h:86:	for (word <<= (32 - bits); likely(bits); bits--) {
spi-pl022.c:4: * Copyright (C) 2008-2012 ST-Ericsson AB
spi-pl022.c:10: *	linux-2.6.17-rc3-mm1/drivers/spi/pxa2xx_spi.c
spi-pl022.c:40:#include <linux/dma-mapping.h>
spi-pl022.c:102: * SSP Control Register 0  - SSP_CR0
spi-pl022.c:120: * SSP Control Register 0  - SSP_CR1
spi-pl022.c:140: * SSP Status Register - SSP_SR
spi-pl022.c:149: * SSP Clock Prescale Register  - SSP_CPSR
spi-pl022.c:154: * SSP Interrupt Mask Set/Clear Register - SSP_IMSC
spi-pl022.c:162: * SSP Raw Interrupt Status Register - SSP_RIS
spi-pl022.c:174: * SSP Masked Interrupt Status Register - SSP_MIS
spi-pl022.c:186: * SSP Interrupt Clear Register - SSP_ICR
spi-pl022.c:194: * SSP DMA Control Register - SSP_DMACR
spi-pl022.c:202: * SSP Chip Select Control Register - SSP_CSR
spi-pl022.c:208: * SSP Integration Test control Register - SSP_ITCR
spi-pl022.c:214: * SSP Integration Test Input Register - SSP_ITIP
spi-pl022.c:224: * SSP Integration Test output Register - SSP_ITOP
spi-pl022.c:242: * SSP Test Data Register - SSP_TDR
spi-pl022.c:255:#define STATE_ERROR			((void *) -1)
spi-pl022.c:258: * SSP State - Whether Enabled or Disabled
spi-pl022.c:264: * SSP DMA State - Whether DMA Enabled or Disabled
spi-pl022.c:320: * struct vendor_data - vendor-specific config parameters
spi-pl022.c:341: * struct pl022 - This is the private SSP driver data structure
spi-pl022.c:348: * @master_info: controller-specific data from machine setup
spi-pl022.c:387:	/* Message per-transfer pump */
spi-pl022.c:416: * struct chip_data - To maintain runtime state of SSP for each client chip
spi-pl022.c:417: * @cr0: Value of control register CR0 of SSP - on later ST variants this
spi-pl022.c:446: * null_cs_control - Dummy chip select function
spi-pl022.c:458: * internal_cs_control - Control chip select signals via SSP_CSR.
spi-pl022.c:470:	tmp = readw(SSP_CSR(pl022->virtbase));
spi-pl022.c:472:		tmp &= ~BIT(pl022->cur_cs);
spi-pl022.c:474:		tmp |= BIT(pl022->cur_cs);
spi-pl022.c:475:	writew(tmp, SSP_CSR(pl022->virtbase));
spi-pl022.c:480:	if (pl022->vendor->internal_cs_ctrl)
spi-pl022.c:482:	else if (gpio_is_valid(pl022->cur_cs))
spi-pl022.c:483:		gpio_set_value(pl022->cur_cs, command);
spi-pl022.c:485:		pl022->cur_chip->cs_control(command);
spi-pl022.c:489: * giveback - current spi_message is over, schedule next message and call
spi-pl022.c:491: * set message->status; dma and pio irqs are blocked
spi-pl022.c:497:	pl022->next_msg_cs_active = false;
spi-pl022.c:499:	last_transfer = list_last_entry(&pl022->cur_msg->transfers,
spi-pl022.c:503:	if (last_transfer->delay_usecs)
spi-pl022.c:508:		udelay(last_transfer->delay_usecs);
spi-pl022.c:510:	if (!last_transfer->cs_change) {
spi-pl022.c:519:		 * after calling msg->complete (below) the driver that
spi-pl022.c:524:		next_msg = spi_get_next_queued_message(pl022->master);
spi-pl022.c:530:		if (next_msg && next_msg->spi != pl022->cur_msg->spi)
spi-pl022.c:532:		if (!next_msg || pl022->cur_msg->state == STATE_ERROR)
spi-pl022.c:535:			pl022->next_msg_cs_active = true;
spi-pl022.c:539:	pl022->cur_msg = NULL;
spi-pl022.c:540:	pl022->cur_transfer = NULL;
spi-pl022.c:541:	pl022->cur_chip = NULL;
spi-pl022.c:544:	writew((readw(SSP_CR1(pl022->virtbase)) &
spi-pl022.c:545:		(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));
spi-pl022.c:547:	spi_finalize_current_message(pl022->master);
spi-pl022.c:551: * flush - flush the FIFO to reach a clean state
spi-pl022.c:558:	dev_dbg(&pl022->adev->dev, "flush\n");
spi-pl022.c:560:		while (readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
spi-pl022.c:561:			readw(SSP_DR(pl022->virtbase));
spi-pl022.c:562:	} while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_BSY) && limit--);
spi-pl022.c:564:	pl022->exp_fifo_level = 0;
spi-pl022.c:570: * restore_state - Load configuration of current chip
spi-pl022.c:575:	struct chip_data *chip = pl022->cur_chip;
spi-pl022.c:577:	if (pl022->vendor->extended_cr)
spi-pl022.c:578:		writel(chip->cr0, SSP_CR0(pl022->virtbase));
spi-pl022.c:580:		writew(chip->cr0, SSP_CR0(pl022->virtbase));
spi-pl022.c:581:	writew(chip->cr1, SSP_CR1(pl022->virtbase));
spi-pl022.c:582:	writew(chip->dmacr, SSP_DMACR(pl022->virtbase));
spi-pl022.c:583:	writew(chip->cpsr, SSP_CPSR(pl022->virtbase));
spi-pl022.c:584:	writew(DISABLE_ALL_INTERRUPTS, SSP_IMSC(pl022->virtbase));
spi-pl022.c:585:	writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));
spi-pl022.c:660: * load_ssp_default_config - Load default configuration for SSP
spi-pl022.c:665:	if (pl022->vendor->pl023) {
spi-pl022.c:666:		writel(DEFAULT_SSP_REG_CR0_ST_PL023, SSP_CR0(pl022->virtbase));
spi-pl022.c:667:		writew(DEFAULT_SSP_REG_CR1_ST_PL023, SSP_CR1(pl022->virtbase));
spi-pl022.c:668:	} else if (pl022->vendor->extended_cr) {
spi-pl022.c:669:		writel(DEFAULT_SSP_REG_CR0_ST, SSP_CR0(pl022->virtbase));
spi-pl022.c:670:		writew(DEFAULT_SSP_REG_CR1_ST, SSP_CR1(pl022->virtbase));
spi-pl022.c:672:		writew(DEFAULT_SSP_REG_CR0, SSP_CR0(pl022->virtbase));
spi-pl022.c:673:		writew(DEFAULT_SSP_REG_CR1, SSP_CR1(pl022->virtbase));
spi-pl022.c:675:	writew(DEFAULT_SSP_REG_DMACR, SSP_DMACR(pl022->virtbase));
spi-pl022.c:676:	writew(DEFAULT_SSP_REG_CPSR, SSP_CPSR(pl022->virtbase));
spi-pl022.c:677:	writew(DISABLE_ALL_INTERRUPTS, SSP_IMSC(pl022->virtbase));
spi-pl022.c:678:	writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));
spi-pl022.c:698:	dev_dbg(&pl022->adev->dev,
spi-pl022.c:700:		__func__, pl022->rx, pl022->rx_end, pl022->tx, pl022->tx_end);
spi-pl022.c:703:	while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
spi-pl022.c:704:	       && (pl022->rx < pl022->rx_end)) {
spi-pl022.c:705:		switch (pl022->read) {
spi-pl022.c:707:			readw(SSP_DR(pl022->virtbase));
spi-pl022.c:710:			*(u8 *) (pl022->rx) =
spi-pl022.c:711:				readw(SSP_DR(pl022->virtbase)) & 0xFFU;
spi-pl022.c:714:			*(u16 *) (pl022->rx) =
spi-pl022.c:715:				(u16) readw(SSP_DR(pl022->virtbase));
spi-pl022.c:718:			*(u32 *) (pl022->rx) =
spi-pl022.c:719:				readl(SSP_DR(pl022->virtbase));
spi-pl022.c:722:		pl022->rx += (pl022->cur_chip->n_bytes);
spi-pl022.c:723:		pl022->exp_fifo_level--;
spi-pl022.c:728:	while ((pl022->exp_fifo_level < pl022->vendor->fifodepth)
spi-pl022.c:729:	       && (pl022->tx < pl022->tx_end)) {
spi-pl022.c:730:		switch (pl022->write) {
spi-pl022.c:732:			writew(0x0, SSP_DR(pl022->virtbase));
spi-pl022.c:735:			writew(*(u8 *) (pl022->tx), SSP_DR(pl022->virtbase));
spi-pl022.c:738:			writew((*(u16 *) (pl022->tx)), SSP_DR(pl022->virtbase));
spi-pl022.c:741:			writel(*(u32 *) (pl022->tx), SSP_DR(pl022->virtbase));
spi-pl022.c:744:		pl022->tx += (pl022->cur_chip->n_bytes);
spi-pl022.c:745:		pl022->exp_fifo_level++;
spi-pl022.c:752:		while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
spi-pl022.c:753:		       && (pl022->rx < pl022->rx_end)) {
spi-pl022.c:754:			switch (pl022->read) {
spi-pl022.c:756:				readw(SSP_DR(pl022->virtbase));
spi-pl022.c:759:				*(u8 *) (pl022->rx) =
spi-pl022.c:760:					readw(SSP_DR(pl022->virtbase)) & 0xFFU;
spi-pl022.c:763:				*(u16 *) (pl022->rx) =
spi-pl022.c:764:					(u16) readw(SSP_DR(pl022->virtbase));
spi-pl022.c:767:				*(u32 *) (pl022->rx) =
spi-pl022.c:768:					readl(SSP_DR(pl022->virtbase));
spi-pl022.c:771:			pl022->rx += (pl022->cur_chip->n_bytes);
spi-pl022.c:772:			pl022->exp_fifo_level--;
spi-pl022.c:782: * next_transfer - Move to the Next transfer in the current spi message
spi-pl022.c:792:	struct spi_message *msg = pl022->cur_msg;
spi-pl022.c:793:	struct spi_transfer *trans = pl022->cur_transfer;
spi-pl022.c:796:	if (trans->transfer_list.next != &msg->transfers) {
spi-pl022.c:797:		pl022->cur_transfer =
spi-pl022.c:798:		    list_entry(trans->transfer_list.next,
spi-pl022.c:813:	dma_unmap_sg(pl022->dma_tx_channel->device->dev, pl022->sgt_tx.sgl,
spi-pl022.c:814:		     pl022->sgt_tx.nents, DMA_TO_DEVICE);
spi-pl022.c:815:	dma_unmap_sg(pl022->dma_rx_channel->device->dev, pl022->sgt_rx.sgl,
spi-pl022.c:816:		     pl022->sgt_rx.nents, DMA_FROM_DEVICE);
spi-pl022.c:817:	sg_free_table(&pl022->sgt_rx);
spi-pl022.c:818:	sg_free_table(&pl022->sgt_tx);
spi-pl022.c:824:	struct spi_message *msg = pl022->cur_msg;
spi-pl022.c:826:	BUG_ON(!pl022->sgt_rx.sgl);
spi-pl022.c:839:		dma_sync_sg_for_cpu(&pl022->adev->dev,
spi-pl022.c:840:				    pl022->sgt_rx.sgl,
spi-pl022.c:841:				    pl022->sgt_rx.nents,
spi-pl022.c:844:		for_each_sg(pl022->sgt_rx.sgl, sg, pl022->sgt_rx.nents, i) {
spi-pl022.c:845:			dev_dbg(&pl022->adev->dev, "SPI RX SG ENTRY: %d", i);
spi-pl022.c:854:		for_each_sg(pl022->sgt_tx.sgl, sg, pl022->sgt_tx.nents, i) {
spi-pl022.c:855:			dev_dbg(&pl022->adev->dev, "SPI TX SG ENTRY: %d", i);
spi-pl022.c:870:	msg->actual_length += pl022->cur_transfer->len;
spi-pl022.c:871:	if (pl022->cur_transfer->cs_change)
spi-pl022.c:875:	msg->state = next_transfer(pl022);
spi-pl022.c:876:	tasklet_schedule(&pl022->pump_transfers);
spi-pl022.c:891:		for_each_sg(sgtab->sgl, sg, sgtab->nents, i) {
spi-pl022.c:898:			if (bytesleft < (PAGE_SIZE - offset_in_page(bufp)))
spi-pl022.c:901:				mapbytes = PAGE_SIZE - offset_in_page(bufp);
spi-pl022.c:905:			bytesleft -= mapbytes;
spi-pl022.c:906:			dev_dbg(&pl022->adev->dev,
spi-pl022.c:912:		for_each_sg(sgtab->sgl, sg, sgtab->nents, i) {
spi-pl022.c:917:			sg_set_page(sg, virt_to_page(pl022->dummypage),
spi-pl022.c:919:			bytesleft -= mapbytes;
spi-pl022.c:920:			dev_dbg(&pl022->adev->dev,
spi-pl022.c:930: * configure_dma - configures the channels for the next transfer
spi-pl022.c:936:		.src_addr = SSP_DR(pl022->phybase),
spi-pl022.c:941:		.dst_addr = SSP_DR(pl022->phybase),
spi-pl022.c:948:	struct dma_chan *rxchan = pl022->dma_rx_channel;
spi-pl022.c:949:	struct dma_chan *txchan = pl022->dma_tx_channel;
spi-pl022.c:955:		return -ENODEV;
spi-pl022.c:959:	 * Notice that the DMA engine uses one-to-one mapping. Since we can
spi-pl022.c:963:	switch (pl022->rx_lev_trig) {
spi-pl022.c:980:		rx_conf.src_maxburst = pl022->vendor->fifodepth >> 1;
spi-pl022.c:984:	switch (pl022->tx_lev_trig) {
spi-pl022.c:1001:		tx_conf.dst_maxburst = pl022->vendor->fifodepth >> 1;
spi-pl022.c:1005:	switch (pl022->read) {
spi-pl022.c:1021:	switch (pl022->write) {
spi-pl022.c:1048:	pages = DIV_ROUND_UP(pl022->cur_transfer->len, PAGE_SIZE);
spi-pl022.c:1049:	dev_dbg(&pl022->adev->dev, "using %d pages for transfer\n", pages);
spi-pl022.c:1051:	ret = sg_alloc_table(&pl022->sgt_rx, pages, GFP_ATOMIC);
spi-pl022.c:1055:	ret = sg_alloc_table(&pl022->sgt_tx, pages, GFP_ATOMIC);
spi-pl022.c:1060:	setup_dma_scatter(pl022, pl022->rx,
spi-pl022.c:1061:			  pl022->cur_transfer->len, &pl022->sgt_rx);
spi-pl022.c:1062:	setup_dma_scatter(pl022, pl022->tx,
spi-pl022.c:1063:			  pl022->cur_transfer->len, &pl022->sgt_tx);
spi-pl022.c:1066:	rx_sglen = dma_map_sg(rxchan->device->dev, pl022->sgt_rx.sgl,
spi-pl022.c:1067:			   pl022->sgt_rx.nents, DMA_FROM_DEVICE);
spi-pl022.c:1071:	tx_sglen = dma_map_sg(txchan->device->dev, pl022->sgt_tx.sgl,
spi-pl022.c:1072:			   pl022->sgt_tx.nents, DMA_TO_DEVICE);
spi-pl022.c:1078:				      pl022->sgt_rx.sgl,
spi-pl022.c:1086:				      pl022->sgt_tx.sgl,
spi-pl022.c:1094:	rxdesc->callback = dma_callback;
spi-pl022.c:1095:	rxdesc->callback_param = pl022;
spi-pl022.c:1102:	pl022->dma_running = true;
spi-pl022.c:1110:	dma_unmap_sg(txchan->device->dev, pl022->sgt_tx.sgl,
spi-pl022.c:1111:		     pl022->sgt_tx.nents, DMA_TO_DEVICE);
spi-pl022.c:1113:	dma_unmap_sg(rxchan->device->dev, pl022->sgt_rx.sgl,
spi-pl022.c:1114:		     pl022->sgt_rx.nents, DMA_FROM_DEVICE);
spi-pl022.c:1116:	sg_free_table(&pl022->sgt_tx);
spi-pl022.c:1118:	sg_free_table(&pl022->sgt_rx);
spi-pl022.c:1120:	return -ENOMEM;
spi-pl022.c:1134:	pl022->dma_rx_channel = dma_request_channel(mask,
spi-pl022.c:1135:					    pl022->master_info->dma_filter,
spi-pl022.c:1136:					    pl022->master_info->dma_rx_param);
spi-pl022.c:1137:	if (!pl022->dma_rx_channel) {
spi-pl022.c:1138:		dev_dbg(&pl022->adev->dev, "no RX DMA channel!\n");
spi-pl022.c:1142:	pl022->dma_tx_channel = dma_request_channel(mask,
spi-pl022.c:1143:					    pl022->master_info->dma_filter,
spi-pl022.c:1144:					    pl022->master_info->dma_tx_param);
spi-pl022.c:1145:	if (!pl022->dma_tx_channel) {
spi-pl022.c:1146:		dev_dbg(&pl022->adev->dev, "no TX DMA channel!\n");
spi-pl022.c:1150:	pl022->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);
spi-pl022.c:1151:	if (!pl022->dummypage)
spi-pl022.c:1154:	dev_info(&pl022->adev->dev, "setup for DMA on RX %s, TX %s\n",
spi-pl022.c:1155:		 dma_chan_name(pl022->dma_rx_channel),
spi-pl022.c:1156:		 dma_chan_name(pl022->dma_tx_channel));
spi-pl022.c:1161:	dma_release_channel(pl022->dma_tx_channel);
spi-pl022.c:1163:	dma_release_channel(pl022->dma_rx_channel);
spi-pl022.c:1164:	pl022->dma_rx_channel = NULL;
spi-pl022.c:1166:	dev_err(&pl022->adev->dev,
spi-pl022.c:1168:	return -ENODEV;
spi-pl022.c:1173:	struct device *dev = &pl022->adev->dev;
spi-pl022.c:1184:	pl022->dma_rx_channel = chan;
spi-pl022.c:1192:	pl022->dma_tx_channel = chan;
spi-pl022.c:1194:	pl022->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);
spi-pl022.c:1195:	if (!pl022->dummypage) {
spi-pl022.c:1196:		err = -ENOMEM;
spi-pl022.c:1203:	dma_release_channel(pl022->dma_tx_channel);
spi-pl022.c:1204:	pl022->dma_tx_channel = NULL;
spi-pl022.c:1206:	dma_release_channel(pl022->dma_rx_channel);
spi-pl022.c:1207:	pl022->dma_rx_channel = NULL;
spi-pl022.c:1214:	struct dma_chan *rxchan = pl022->dma_rx_channel;
spi-pl022.c:1215:	struct dma_chan *txchan = pl022->dma_tx_channel;
spi-pl022.c:1220:	pl022->dma_running = false;
spi-pl022.c:1225:	if (pl022->dma_running)
spi-pl022.c:1227:	if (pl022->dma_tx_channel)
spi-pl022.c:1228:		dma_release_channel(pl022->dma_tx_channel);
spi-pl022.c:1229:	if (pl022->dma_rx_channel)
spi-pl022.c:1230:		dma_release_channel(pl022->dma_rx_channel);
spi-pl022.c:1231:	kfree(pl022->dummypage);
spi-pl022.c:1237:	return -ENODEV;
spi-pl022.c:1256: * pl022_interrupt_handler - Interrupt handler for SSP controller
spi-pl022.c:1269:	struct spi_message *msg = pl022->cur_msg;
spi-pl022.c:1273:		dev_err(&pl022->adev->dev,
spi-pl022.c:1280:	irq_status = readw(SSP_MIS(pl022->virtbase));
spi-pl022.c:1292:		 * Overrun interrupt - bail out since our Data has been
spi-pl022.c:1295:		dev_err(&pl022->adev->dev, "FIFO overrun\n");
spi-pl022.c:1296:		if (readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RFF)
spi-pl022.c:1297:			dev_err(&pl022->adev->dev,
spi-pl022.c:1306:		       SSP_IMSC(pl022->virtbase));
spi-pl022.c:1307:		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));
spi-pl022.c:1308:		writew((readw(SSP_CR1(pl022->virtbase)) &
spi-pl022.c:1309:			(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));
spi-pl022.c:1310:		msg->state = STATE_ERROR;
spi-pl022.c:1313:		tasklet_schedule(&pl022->pump_transfers);
spi-pl022.c:1319:	if (pl022->tx == pl022->tx_end) {
spi-pl022.c:1321:		writew((readw(SSP_IMSC(pl022->virtbase)) &
spi-pl022.c:1323:		       SSP_IMSC(pl022->virtbase));
spi-pl022.c:1331:	if (pl022->rx >= pl022->rx_end) {
spi-pl022.c:1333:		       SSP_IMSC(pl022->virtbase));
spi-pl022.c:1334:		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));
spi-pl022.c:1335:		if (unlikely(pl022->rx > pl022->rx_end)) {
spi-pl022.c:1336:			dev_warn(&pl022->adev->dev, "read %u surplus "
spi-pl022.c:1339:				 (u32) (pl022->rx - pl022->rx_end));
spi-pl022.c:1342:		msg->actual_length += pl022->cur_transfer->len;
spi-pl022.c:1343:		if (pl022->cur_transfer->cs_change)
spi-pl022.c:1346:		msg->state = next_transfer(pl022);
spi-pl022.c:1347:		tasklet_schedule(&pl022->pump_transfers);
spi-pl022.c:1364:	residue = pl022->cur_transfer->len % pl022->cur_chip->n_bytes;
spi-pl022.c:1366:		dev_err(&pl022->adev->dev,
spi-pl022.c:1369:			pl022->cur_transfer->len,
spi-pl022.c:1370:			pl022->cur_chip->n_bytes);
spi-pl022.c:1371:		dev_err(&pl022->adev->dev, "skipping this message\n");
spi-pl022.c:1372:		return -EIO;
spi-pl022.c:1374:	pl022->tx = (void *)transfer->tx_buf;
spi-pl022.c:1375:	pl022->tx_end = pl022->tx + pl022->cur_transfer->len;
spi-pl022.c:1376:	pl022->rx = (void *)transfer->rx_buf;
spi-pl022.c:1377:	pl022->rx_end = pl022->rx + pl022->cur_transfer->len;
spi-pl022.c:1378:	pl022->write =
spi-pl022.c:1379:	    pl022->tx ? pl022->cur_chip->write : WRITING_NULL;
spi-pl022.c:1380:	pl022->read = pl022->rx ? pl022->cur_chip->read : READING_NULL;
spi-pl022.c:1385: * pump_transfers - Tasklet function which schedules next transfer
spi-pl022.c:1398:	message = pl022->cur_msg;
spi-pl022.c:1399:	transfer = pl022->cur_transfer;
spi-pl022.c:1402:	if (message->state == STATE_ERROR) {
spi-pl022.c:1403:		message->status = -EIO;
spi-pl022.c:1409:	if (message->state == STATE_DONE) {
spi-pl022.c:1410:		message->status = 0;
spi-pl022.c:1416:	if (message->state == STATE_RUNNING) {
spi-pl022.c:1417:		previous = list_entry(transfer->transfer_list.prev,
spi-pl022.c:1420:		if (previous->delay_usecs)
spi-pl022.c:1425:			udelay(previous->delay_usecs);
spi-pl022.c:1428:		if (previous->cs_change)
spi-pl022.c:1432:		message->state = STATE_RUNNING;
spi-pl022.c:1436:		message->state = STATE_ERROR;
spi-pl022.c:1437:		message->status = -EIO;
spi-pl022.c:1444:	if (pl022->cur_chip->enable_dma) {
spi-pl022.c:1446:			dev_dbg(&pl022->adev->dev,
spi-pl022.c:1455:	writew(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM, SSP_IMSC(pl022->virtbase));
spi-pl022.c:1461:	 * Default is to enable all interrupts except RX -
spi-pl022.c:1467:	if (!pl022->next_msg_cs_active)
spi-pl022.c:1470:	if (set_up_next_transfer(pl022, pl022->cur_transfer)) {
spi-pl022.c:1472:		pl022->cur_msg->state = STATE_ERROR;
spi-pl022.c:1473:		pl022->cur_msg->status = -EIO;
spi-pl022.c:1478:	if (pl022->cur_chip->enable_dma) {
spi-pl022.c:1481:			dev_dbg(&pl022->adev->dev,
spi-pl022.c:1490:	writew((readw(SSP_CR1(pl022->virtbase)) | SSP_CR1_MASK_SSE),
spi-pl022.c:1491:	       SSP_CR1(pl022->virtbase));
spi-pl022.c:1492:	writew(irqflags, SSP_IMSC(pl022->virtbase));
spi-pl022.c:1503:	chip = pl022->cur_chip;
spi-pl022.c:1504:	message = pl022->cur_msg;
spi-pl022.c:1506:	while (message->state != STATE_DONE) {
spi-pl022.c:1508:		if (message->state == STATE_ERROR)
spi-pl022.c:1510:		transfer = pl022->cur_transfer;
spi-pl022.c:1513:		if (message->state == STATE_RUNNING) {
spi-pl022.c:1515:			    list_entry(transfer->transfer_list.prev,
spi-pl022.c:1517:			if (previous->delay_usecs)
spi-pl022.c:1518:				udelay(previous->delay_usecs);
spi-pl022.c:1519:			if (previous->cs_change)
spi-pl022.c:1523:			message->state = STATE_RUNNING;
spi-pl022.c:1524:			if (!pl022->next_msg_cs_active)
spi-pl022.c:1531:			message->state = STATE_ERROR;
spi-pl022.c:1536:		writew((readw(SSP_CR1(pl022->virtbase)) | SSP_CR1_MASK_SSE),
spi-pl022.c:1537:		       SSP_CR1(pl022->virtbase));
spi-pl022.c:1539:		dev_dbg(&pl022->adev->dev, "polling transfer ongoing ...\n");
spi-pl022.c:1542:		while (pl022->tx < pl022->tx_end || pl022->rx < pl022->rx_end) {
spi-pl022.c:1546:				dev_warn(&pl022->adev->dev,
spi-pl022.c:1548:				message->state = STATE_ERROR;
spi-pl022.c:1555:		message->actual_length += pl022->cur_transfer->len;
spi-pl022.c:1556:		if (pl022->cur_transfer->cs_change)
spi-pl022.c:1559:		message->state = next_transfer(pl022);
spi-pl022.c:1563:	if (message->state == STATE_DONE)
spi-pl022.c:1564:		message->status = 0;
spi-pl022.c:1566:		message->status = -EIO;
spi-pl022.c:1578:	pl022->cur_msg = msg;
spi-pl022.c:1579:	msg->state = STATE_START;
spi-pl022.c:1581:	pl022->cur_transfer = list_entry(msg->transfers.next,
spi-pl022.c:1585:	pl022->cur_chip = spi_get_ctldata(msg->spi);
spi-pl022.c:1586:	pl022->cur_cs = pl022->chipselects[msg->spi->chip_select];
spi-pl022.c:1591:	if (pl022->cur_chip->xfer_type == POLLING_TRANSFER)
spi-pl022.c:1603:	/* nothing more to do - disable spi/ssp and power off */
spi-pl022.c:1604:	writew((readw(SSP_CR1(pl022->virtbase)) &
spi-pl022.c:1605:		(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));
spi-pl022.c:1613:	if ((chip_info->iface < SSP_INTERFACE_MOTOROLA_SPI)
spi-pl022.c:1614:	    || (chip_info->iface > SSP_INTERFACE_UNIDIRECTIONAL)) {
spi-pl022.c:1615:		dev_err(&pl022->adev->dev,
spi-pl022.c:1617:		return -EINVAL;
spi-pl022.c:1619:	if ((chip_info->iface == SSP_INTERFACE_UNIDIRECTIONAL) &&
spi-pl022.c:1620:	    (!pl022->vendor->unidir)) {
spi-pl022.c:1621:		dev_err(&pl022->adev->dev,
spi-pl022.c:1624:		return -EINVAL;
spi-pl022.c:1626:	if ((chip_info->hierarchy != SSP_MASTER)
spi-pl022.c:1627:	    && (chip_info->hierarchy != SSP_SLAVE)) {
spi-pl022.c:1628:		dev_err(&pl022->adev->dev,
spi-pl022.c:1630:		return -EINVAL;
spi-pl022.c:1632:	if ((chip_info->com_mode != INTERRUPT_TRANSFER)
spi-pl022.c:1633:	    && (chip_info->com_mode != DMA_TRANSFER)
spi-pl022.c:1634:	    && (chip_info->com_mode != POLLING_TRANSFER)) {
spi-pl022.c:1635:		dev_err(&pl022->adev->dev,
spi-pl022.c:1637:		return -EINVAL;
spi-pl022.c:1639:	switch (chip_info->rx_lev_trig) {
spi-pl022.c:1646:		if (pl022->vendor->fifodepth < 16) {
spi-pl022.c:1647:			dev_err(&pl022->adev->dev,
spi-pl022.c:1649:			return -EINVAL;
spi-pl022.c:1653:		if (pl022->vendor->fifodepth < 32) {
spi-pl022.c:1654:			dev_err(&pl022->adev->dev,
spi-pl022.c:1656:			return -EINVAL;
spi-pl022.c:1660:		dev_err(&pl022->adev->dev,
spi-pl022.c:1662:		return -EINVAL;
spi-pl022.c:1664:	switch (chip_info->tx_lev_trig) {
spi-pl022.c:1671:		if (pl022->vendor->fifodepth < 16) {
spi-pl022.c:1672:			dev_err(&pl022->adev->dev,
spi-pl022.c:1674:			return -EINVAL;
spi-pl022.c:1678:		if (pl022->vendor->fifodepth < 32) {
spi-pl022.c:1679:			dev_err(&pl022->adev->dev,
spi-pl022.c:1681:			return -EINVAL;
spi-pl022.c:1685:		dev_err(&pl022->adev->dev,
spi-pl022.c:1687:		return -EINVAL;
spi-pl022.c:1689:	if (chip_info->iface == SSP_INTERFACE_NATIONAL_MICROWIRE) {
spi-pl022.c:1690:		if ((chip_info->ctrl_len < SSP_BITS_4)
spi-pl022.c:1691:		    || (chip_info->ctrl_len > SSP_BITS_32)) {
spi-pl022.c:1692:			dev_err(&pl022->adev->dev,
spi-pl022.c:1694:			return -EINVAL;
spi-pl022.c:1696:		if ((chip_info->wait_state != SSP_MWIRE_WAIT_ZERO)
spi-pl022.c:1697:		    && (chip_info->wait_state != SSP_MWIRE_WAIT_ONE)) {
spi-pl022.c:1698:			dev_err(&pl022->adev->dev,
spi-pl022.c:1700:			return -EINVAL;
spi-pl022.c:1703:		if (pl022->vendor->extended_cr) {
spi-pl022.c:1704:			if ((chip_info->duplex !=
spi-pl022.c:1706:			    && (chip_info->duplex !=
spi-pl022.c:1708:				dev_err(&pl022->adev->dev,
spi-pl022.c:1710:				return -EINVAL;
spi-pl022.c:1713:			if (chip_info->duplex != SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)
spi-pl022.c:1714:				dev_err(&pl022->adev->dev,
spi-pl022.c:1718:			return -EINVAL;
spi-pl022.c:1737:	rate = clk_get_rate(pl022->clk);
spi-pl022.c:1744:		dev_warn(&pl022->adev->dev,
spi-pl022.c:1749:		dev_err(&pl022->adev->dev,
spi-pl022.c:1752:		return -EINVAL;
spi-pl022.c:1794:	clk_freq->cpsdvsr = (u8) (best_cpsdvsr & 0xFF);
spi-pl022.c:1795:	clk_freq->scr = (u8) (best_scr & 0xFF);
spi-pl022.c:1796:	dev_dbg(&pl022->adev->dev,
spi-pl022.c:1799:	dev_dbg(&pl022->adev->dev, "SSP cpsdvsr = %d, scr = %d\n",
spi-pl022.c:1800:		clk_freq->cpsdvsr, clk_freq->scr);
spi-pl022.c:1823: * pl022_setup - setup function registered to SPI master framework
spi-pl022.c:1841:	struct pl022 *pl022 = spi_master_get_devdata(spi->master);
spi-pl022.c:1842:	unsigned int bits = spi->bits_per_word;
spi-pl022.c:1844:	struct device_node *np = spi->dev.of_node;
spi-pl022.c:1846:	if (!spi->max_speed_hz)
spi-pl022.c:1847:		return -EINVAL;
spi-pl022.c:1855:			return -ENOMEM;
spi-pl022.c:1856:		dev_dbg(&spi->dev,
spi-pl022.c:1861:	chip_info = spi->controller_data;
spi-pl022.c:1870:			of_property_read_u32(np, "pl022,com-mode",
spi-pl022.c:1872:			of_property_read_u32(np, "pl022,rx-level-trig",
spi-pl022.c:1874:			of_property_read_u32(np, "pl022,tx-level-trig",
spi-pl022.c:1876:			of_property_read_u32(np, "pl022,ctrl-len",
spi-pl022.c:1878:			of_property_read_u32(np, "pl022,wait-state",
spi-pl022.c:1887:			dev_dbg(&spi->dev,
spi-pl022.c:1891:		dev_dbg(&spi->dev,
spi-pl022.c:1898:	if ((0 == chip_info->clk_freq.cpsdvsr)
spi-pl022.c:1899:	    && (0 == chip_info->clk_freq.scr)) {
spi-pl022.c:1901:						  spi->max_speed_hz,
spi-pl022.c:1906:		memcpy(&clk_freq, &chip_info->clk_freq, sizeof(clk_freq));
spi-pl022.c:1909:				clk_freq.cpsdvsr - 1;
spi-pl022.c:1913:		status = -EINVAL;
spi-pl022.c:1914:		dev_err(&spi->dev,
spi-pl022.c:1921:		dev_err(&spi->dev, "controller data is incorrect");
spi-pl022.c:1925:	pl022->rx_lev_trig = chip_info->rx_lev_trig;
spi-pl022.c:1926:	pl022->tx_lev_trig = chip_info->tx_lev_trig;
spi-pl022.c:1929:	chip->xfer_type = chip_info->com_mode;
spi-pl022.c:1930:	if (!chip_info->cs_control) {
spi-pl022.c:1931:		chip->cs_control = null_cs_control;
spi-pl022.c:1932:		if (!gpio_is_valid(pl022->chipselects[spi->chip_select]))
spi-pl022.c:1933:			dev_warn(&spi->dev,
spi-pl022.c:1936:		chip->cs_control = chip_info->cs_control;
spi-pl022.c:1939:	if ((bits <= 3) || (bits > pl022->vendor->max_bpw)) {
spi-pl022.c:1940:		status = -ENOTSUPP;
spi-pl022.c:1941:		dev_err(&spi->dev, "illegal data size for this controller!\n");
spi-pl022.c:1942:		dev_err(&spi->dev, "This controller can only handle 4 <= n <= %d bit words\n",
spi-pl022.c:1943:				pl022->vendor->max_bpw);
spi-pl022.c:1946:		dev_dbg(&spi->dev, "4 <= n <=8 bits per word\n");
spi-pl022.c:1947:		chip->n_bytes = 1;
spi-pl022.c:1948:		chip->read = READING_U8;
spi-pl022.c:1949:		chip->write = WRITING_U8;
spi-pl022.c:1951:		dev_dbg(&spi->dev, "9 <= n <= 16 bits per word\n");
spi-pl022.c:1952:		chip->n_bytes = 2;
spi-pl022.c:1953:		chip->read = READING_U16;
spi-pl022.c:1954:		chip->write = WRITING_U16;
spi-pl022.c:1956:		dev_dbg(&spi->dev, "17 <= n <= 32 bits per word\n");
spi-pl022.c:1957:		chip->n_bytes = 4;
spi-pl022.c:1958:		chip->read = READING_U32;
spi-pl022.c:1959:		chip->write = WRITING_U32;
spi-pl022.c:1963:	chip->cr0 = 0;
spi-pl022.c:1964:	chip->cr1 = 0;
spi-pl022.c:1965:	chip->dmacr = 0;
spi-pl022.c:1966:	chip->cpsr = 0;
spi-pl022.c:1967:	if ((chip_info->com_mode == DMA_TRANSFER)
spi-pl022.c:1968:	    && ((pl022->master_info)->enable_dma)) {
spi-pl022.c:1969:		chip->enable_dma = true;
spi-pl022.c:1970:		dev_dbg(&spi->dev, "DMA mode set in controller state\n");
spi-pl022.c:1971:		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_ENABLED,
spi-pl022.c:1973:		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_ENABLED,
spi-pl022.c:1976:		chip->enable_dma = false;
spi-pl022.c:1977:		dev_dbg(&spi->dev, "DMA mode NOT set in controller state\n");
spi-pl022.c:1978:		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_DISABLED,
spi-pl022.c:1980:		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_DISABLED,
spi-pl022.c:1984:	chip->cpsr = clk_freq.cpsdvsr;
spi-pl022.c:1987:	if (pl022->vendor->extended_cr) {
spi-pl022.c:1990:		if (pl022->vendor->pl023) {
spi-pl022.c:1992:			SSP_WRITE_BITS(chip->cr1, chip_info->clkdelay,
spi-pl022.c:1996:			SSP_WRITE_BITS(chip->cr0, chip_info->duplex,
spi-pl022.c:1998:			SSP_WRITE_BITS(chip->cr0, chip_info->ctrl_len,
spi-pl022.c:2000:			SSP_WRITE_BITS(chip->cr0, chip_info->iface,
spi-pl022.c:2002:			SSP_WRITE_BITS(chip->cr1, chip_info->wait_state,
spi-pl022.c:2005:		SSP_WRITE_BITS(chip->cr0, bits - 1,
spi-pl022.c:2008:		if (spi->mode & SPI_LSB_FIRST) {
spi-pl022.c:2015:		SSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_RENDN_ST, 4);
spi-pl022.c:2016:		SSP_WRITE_BITS(chip->cr1, etx, SSP_CR1_MASK_TENDN_ST, 5);
spi-pl022.c:2017:		SSP_WRITE_BITS(chip->cr1, chip_info->rx_lev_trig,
spi-pl022.c:2019:		SSP_WRITE_BITS(chip->cr1, chip_info->tx_lev_trig,
spi-pl022.c:2022:		SSP_WRITE_BITS(chip->cr0, bits - 1,
spi-pl022.c:2024:		SSP_WRITE_BITS(chip->cr0, chip_info->iface,
spi-pl022.c:2029:	if (spi->mode & SPI_CPOL)
spi-pl022.c:2033:	SSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPO, 6);
spi-pl022.c:2035:	if (spi->mode & SPI_CPHA)
spi-pl022.c:2039:	SSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPH, 7);
spi-pl022.c:2041:	SSP_WRITE_BITS(chip->cr0, clk_freq.scr, SSP_CR0_MASK_SCR, 8);
spi-pl022.c:2043:	if (pl022->vendor->loopback) {
spi-pl022.c:2044:		if (spi->mode & SPI_LOOP)
spi-pl022.c:2048:		SSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_LBM, 0);
spi-pl022.c:2050:	SSP_WRITE_BITS(chip->cr1, SSP_DISABLED, SSP_CR1_MASK_SSE, 1);
spi-pl022.c:2051:	SSP_WRITE_BITS(chip->cr1, chip_info->hierarchy, SSP_CR1_MASK_MS, 2);
spi-pl022.c:2052:	SSP_WRITE_BITS(chip->cr1, chip_info->slave_tx_disable, SSP_CR1_MASK_SOD,
spi-pl022.c:2065: * pl022_cleanup - cleanup function registered to SPI master framework
spi-pl022.c:2082:	struct device_node *np = dev->of_node;
spi-pl022.c:2095:	pd->bus_id = -1;
spi-pl022.c:2096:	pd->enable_dma = 1;
spi-pl022.c:2097:	of_property_read_u32(np, "num-cs", &tmp);
spi-pl022.c:2098:	pd->num_chipselect = tmp;
spi-pl022.c:2099:	of_property_read_u32(np, "pl022,autosuspend-delay",
spi-pl022.c:2100:			     &pd->autosuspend_delay);
spi-pl022.c:2101:	pd->rt = of_property_read_bool(np, "pl022,rt");
spi-pl022.c:2108:	struct device *dev = &adev->dev;
spi-pl022.c:2110:			dev_get_platdata(&adev->dev);
spi-pl022.c:2113:	struct device_node *np = adev->dev.of_node;
spi-pl022.c:2116:	dev_info(&adev->dev,
spi-pl022.c:2117:		 "ARM PL022 driver, device ID: 0x%08x\n", adev->periphid);
spi-pl022.c:2123:		return -ENODEV;
spi-pl022.c:2126:	if (platform_info->num_chipselect) {
spi-pl022.c:2127:		num_cs = platform_info->num_chipselect;
spi-pl022.c:2130:		return -ENODEV;
spi-pl022.c:2136:		dev_err(&adev->dev, "probe - cannot alloc SPI master\n");
spi-pl022.c:2137:		return -ENOMEM;
spi-pl022.c:2141:	pl022->master = master;
spi-pl022.c:2142:	pl022->master_info = platform_info;
spi-pl022.c:2143:	pl022->adev = adev;
spi-pl022.c:2144:	pl022->vendor = id->data;
spi-pl022.c:2145:	pl022->chipselects = devm_kzalloc(dev, num_cs * sizeof(int),
spi-pl022.c:2147:	if (!pl022->chipselects) {
spi-pl022.c:2148:		status = -ENOMEM;
spi-pl022.c:2156:	master->bus_num = platform_info->bus_id;
spi-pl022.c:2157:	master->num_chipselect = num_cs;
spi-pl022.c:2158:	master->cleanup = pl022_cleanup;
spi-pl022.c:2159:	master->setup = pl022_setup;
spi-pl022.c:2160:	master->auto_runtime_pm = true;
spi-pl022.c:2161:	master->transfer_one_message = pl022_transfer_one_message;
spi-pl022.c:2162:	master->unprepare_transfer_hardware = pl022_unprepare_transfer_hardware;
spi-pl022.c:2163:	master->rt = platform_info->rt;
spi-pl022.c:2164:	master->dev.of_node = dev->of_node;
spi-pl022.c:2166:	if (platform_info->num_chipselect && platform_info->chipselects) {
spi-pl022.c:2168:			pl022->chipselects[i] = platform_info->chipselects[i];
spi-pl022.c:2169:	} else if (pl022->vendor->internal_cs_ctrl) {
spi-pl022.c:2171:			pl022->chipselects[i] = i;
spi-pl022.c:2174:			int cs_gpio = of_get_named_gpio(np, "cs-gpios", i);
spi-pl022.c:2176:			if (cs_gpio == -EPROBE_DEFER) {
spi-pl022.c:2177:				status = -EPROBE_DEFER;
spi-pl022.c:2181:			pl022->chipselects[i] = cs_gpio;
spi-pl022.c:2184:				if (devm_gpio_request(dev, cs_gpio, "ssp-pl022"))
spi-pl022.c:2185:					dev_err(&adev->dev,
spi-pl022.c:2189:					dev_err(&adev->dev,
spi-pl022.c:2197:	 * Supports mode 0-3, loopback, and active low CS. Transfers are
spi-pl022.c:2200:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;
spi-pl022.c:2201:	if (pl022->vendor->extended_cr)
spi-pl022.c:2202:		master->mode_bits |= SPI_LSB_FIRST;
spi-pl022.c:2204:	dev_dbg(&adev->dev, "BUSNO: %d\n", master->bus_num);
spi-pl022.c:2210:	pl022->phybase = adev->res.start;
spi-pl022.c:2211:	pl022->virtbase = devm_ioremap(dev, adev->res.start,
spi-pl022.c:2212:				       resource_size(&adev->res));
spi-pl022.c:2213:	if (pl022->virtbase == NULL) {
spi-pl022.c:2214:		status = -ENOMEM;
spi-pl022.c:2217:	dev_info(&adev->dev, "mapped registers from %pa to %p\n",
spi-pl022.c:2218:		&adev->res.start, pl022->virtbase);
spi-pl022.c:2220:	pl022->clk = devm_clk_get(&adev->dev, NULL);
spi-pl022.c:2221:	if (IS_ERR(pl022->clk)) {
spi-pl022.c:2222:		status = PTR_ERR(pl022->clk);
spi-pl022.c:2223:		dev_err(&adev->dev, "could not retrieve SSP/SPI bus clock\n");
spi-pl022.c:2227:	status = clk_prepare_enable(pl022->clk);
spi-pl022.c:2229:		dev_err(&adev->dev, "could not enable SSP/SPI bus clock\n");
spi-pl022.c:2234:	tasklet_init(&pl022->pump_transfers, pump_transfers,
spi-pl022.c:2238:	writew((readw(SSP_CR1(pl022->virtbase)) & (~SSP_CR1_MASK_SSE)),
spi-pl022.c:2239:	       SSP_CR1(pl022->virtbase));
spi-pl022.c:2242:	status = devm_request_irq(dev, adev->irq[0], pl022_interrupt_handler,
spi-pl022.c:2245:		dev_err(&adev->dev, "probe - cannot get IRQ (%d)\n", status);
spi-pl022.c:2251:	if (status == -EPROBE_DEFER) {
spi-pl022.c:2258:		platform_info->enable_dma = 1;
spi-pl022.c:2259:	else if (platform_info->enable_dma) {
spi-pl022.c:2262:			platform_info->enable_dma = 0;
spi-pl022.c:2267:	status = devm_spi_register_master(&adev->dev, master);
spi-pl022.c:2269:		dev_err(&adev->dev,
spi-pl022.c:2270:			"probe - problem registering spi master\n");
spi-pl022.c:2276:	if (platform_info->autosuspend_delay > 0) {
spi-pl022.c:2277:		dev_info(&adev->dev,
spi-pl022.c:2279:			platform_info->autosuspend_delay);
spi-pl022.c:2281:			platform_info->autosuspend_delay);
spi-pl022.c:2289:	if (platform_info->enable_dma)
spi-pl022.c:2292:	clk_disable_unprepare(pl022->clk);
spi-pl022.c:2316:	pm_runtime_get_noresume(&adev->dev);
spi-pl022.c:2319:	if (pl022->master_info->enable_dma)
spi-pl022.c:2322:	clk_disable_unprepare(pl022->clk);
spi-pl022.c:2324:	tasklet_disable(&pl022->pump_transfers);
spi-pl022.c:2334:	ret = spi_master_suspend(pl022->master);
spi-pl022.c:2342:		spi_master_resume(pl022->master);
spi-pl022.c:2362:	ret = spi_master_resume(pl022->master);
spi-pl022.c:2377:	clk_disable_unprepare(pl022->clk);
spi-pl022.c:2388:	clk_prepare_enable(pl022->clk);
spi-pl022.c:2460:		 * ST-Ericsson derivative "PL023" (this is not
spi-pl022.c:2486:		.name	= "ssp-pl022",
spi-sh-hspi.c:6: * Based on spi-sh.c:
spi-sh-hspi.c:56:	iowrite32(val, hspi->addr + reg);
spi-sh-hspi.c:61:	return ioread32(hspi->addr + reg);
spi-sh-hspi.c:81:	while (t--) {
spi-sh-hspi.c:88:	dev_err(hspi->dev, "timeout\n");
spi-sh-hspi.c:89:	return -ETIMEDOUT;
spi-sh-hspi.c:107:	struct spi_device *spi = msg->spi;
spi-sh-hspi.c:108:	struct device *dev = hspi->dev;
spi-sh-hspi.c:119:		rate = clk_get_rate(hspi->clk);
spi-sh-hspi.c:131:		tmp = abs(t->speed_hz - rate);
spi-sh-hspi.c:139:	if (spi->mode & SPI_CPHA)
spi-sh-hspi.c:141:	if (spi->mode & SPI_CPOL)
spi-sh-hspi.c:144:	dev_dbg(dev, "speed %d/%d\n", t->speed_hz, best_rate);
spi-sh-hspi.c:162:	dev_dbg(hspi->dev, "%s\n", __func__);
spi-sh-hspi.c:166:	list_for_each_entry(t, &msg->transfers, transfer_list) {
spi-sh-hspi.c:173:		cs_change = t->cs_change;
spi-sh-hspi.c:175:		for (i = 0; i < t->len; i++) {
spi-sh-hspi.c:183:			if (t->tx_buf)
spi-sh-hspi.c:184:				tx = (u32)((u8 *)t->tx_buf)[i];
spi-sh-hspi.c:194:			if (t->rx_buf)
spi-sh-hspi.c:195:				((u8 *)t->rx_buf)[i] = (u8)rx;
spi-sh-hspi.c:199:		msg->actual_length += t->len;
spi-sh-hspi.c:201:		if (t->delay_usecs)
spi-sh-hspi.c:202:			udelay(t->delay_usecs);
spi-sh-hspi.c:211:	msg->status = ret;
spi-sh-hspi.c:232:		dev_err(&pdev->dev, "invalid resource\n");
spi-sh-hspi.c:233:		return -EINVAL;
spi-sh-hspi.c:236:	master = spi_alloc_master(&pdev->dev, sizeof(*hspi));
spi-sh-hspi.c:238:		dev_err(&pdev->dev, "spi_alloc_master error.\n");
spi-sh-hspi.c:239:		return -ENOMEM;
spi-sh-hspi.c:242:	clk = clk_get(&pdev->dev, NULL);
spi-sh-hspi.c:244:		dev_err(&pdev->dev, "couldn't get clock\n");
spi-sh-hspi.c:245:		ret = -EINVAL;
spi-sh-hspi.c:253:	hspi->master	= master;
spi-sh-hspi.c:254:	hspi->dev	= &pdev->dev;
spi-sh-hspi.c:255:	hspi->clk	= clk;
spi-sh-hspi.c:256:	hspi->addr	= devm_ioremap(hspi->dev,
spi-sh-hspi.c:257:				       res->start, resource_size(res));
spi-sh-hspi.c:258:	if (!hspi->addr) {
spi-sh-hspi.c:259:		dev_err(&pdev->dev, "ioremap error.\n");
spi-sh-hspi.c:260:		ret = -ENOMEM;
spi-sh-hspi.c:264:	pm_runtime_enable(&pdev->dev);
spi-sh-hspi.c:266:	master->bus_num		= pdev->id;
spi-sh-hspi.c:267:	master->mode_bits	= SPI_CPOL | SPI_CPHA;
spi-sh-hspi.c:268:	master->dev.of_node	= pdev->dev.of_node;
spi-sh-hspi.c:269:	master->auto_runtime_pm = true;
spi-sh-hspi.c:270:	master->transfer_one_message		= hspi_transfer_one_message;
spi-sh-hspi.c:271:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-sh-hspi.c:273:	ret = devm_spi_register_master(&pdev->dev, master);
spi-sh-hspi.c:275:		dev_err(&pdev->dev, "spi_register_master error.\n");
spi-sh-hspi.c:282:	pm_runtime_disable(&pdev->dev);
spi-sh-hspi.c:295:	pm_runtime_disable(&pdev->dev);
spi-sh-hspi.c:297:	clk_put(hspi->clk);
spi-sh-hspi.c:312:		.name = "sh-hspi",
spi-sh-hspi.c:321:MODULE_ALIAS("platform:sh-hspi");
 spi-zmp.o
spi-fsl-lib.c:19:#include <linux/dma-mapping.h>
spi-fsl-lib.c:31:#include "spi-fsl-lib.h"
spi-fsl-lib.c:36:	type *rx = mpc8xxx_spi->rx;					  \
spi-fsl-lib.c:37:	*rx++ = (type)(data >> mpc8xxx_spi->rx_shift);			  \
spi-fsl-lib.c:38:	mpc8xxx_spi->rx = rx;						  \
spi-fsl-lib.c:46:	const type *tx = mpc8xxx_spi->tx;			\
spi-fsl-lib.c:49:	data = *tx++ << mpc8xxx_spi->tx_shift;			\
spi-fsl-lib.c:50:	mpc8xxx_spi->tx = tx;					\
spi-fsl-lib.c:93:	/* the spi->mode bits understood by this driver: */
spi-fsl-lib.c:94:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH
spi-fsl-lib.c:97:	master->dev.of_node = dev->of_node;
spi-fsl-lib.c:100:	mpc8xxx_spi->dev = dev;
spi-fsl-lib.c:101:	mpc8xxx_spi->get_rx = mpc8xxx_spi_rx_buf_u8;
spi-fsl-lib.c:102:	mpc8xxx_spi->get_tx = mpc8xxx_spi_tx_buf_u8;
spi-fsl-lib.c:103:	mpc8xxx_spi->flags = pdata->flags;
spi-fsl-lib.c:104:	mpc8xxx_spi->spibrg = pdata->sysclk;
spi-fsl-lib.c:105:	mpc8xxx_spi->irq = irq;
spi-fsl-lib.c:107:	mpc8xxx_spi->rx_shift = 0;
spi-fsl-lib.c:108:	mpc8xxx_spi->tx_shift = 0;
spi-fsl-lib.c:110:	master->bus_num = pdata->bus_num;
spi-fsl-lib.c:111:	master->num_chipselect = pdata->max_chipselect;
spi-fsl-lib.c:113:	init_completion(&mpc8xxx_spi->done);
spi-fsl-lib.c:119:	struct device *dev = &ofdev->dev;
spi-fsl-lib.c:120:	struct device_node *np = ofdev->dev.of_node;
spi-fsl-lib.c:124:	int ret = -ENOMEM;
spi-fsl-lib.c:126:	pinfo = devm_kzalloc(&ofdev->dev, sizeof(*pinfo), GFP_KERNEL);
spi-fsl-lib.c:130:	pdata = &pinfo->pdata;
spi-fsl-lib.c:131:	dev->platform_data = pdata;
spi-fsl-lib.c:134:	pdata->bus_num = -1;
spi-fsl-lib.c:138:	pdata->sysclk = get_brgfreq();
spi-fsl-lib.c:139:	if (pdata->sysclk == -1) {
spi-fsl-lib.c:140:		pdata->sysclk = fsl_get_sys_freq();
spi-fsl-lib.c:141:		if (pdata->sysclk == -1)
spi-fsl-lib.c:142:			return -ENODEV;
spi-fsl-lib.c:145:	ret = of_property_read_u32(np, "clock-frequency", &pdata->sysclk);
spi-fsl-lib.c:151:	if (prop && !strcmp(prop, "cpu-qe"))
spi-fsl-lib.c:152:		pdata->flags = SPI_QE_CPU_MODE;
spi-fsl-lib.c:154:		pdata->flags = SPI_CPM_MODE | SPI_QE;
spi-fsl-lib.c:155:	else if (of_device_is_compatible(np, "fsl,cpm2-spi"))
spi-fsl-lib.c:156:		pdata->flags = SPI_CPM_MODE | SPI_CPM2;
spi-fsl-lib.c:157:	else if (of_device_is_compatible(np, "fsl,cpm1-spi"))
spi-fsl-lib.c:158:		pdata->flags = SPI_CPM_MODE | SPI_CPM1;
spi-meson-spifc.c:62:#define USER_UC_MASK		((BIT(5) - 1) << 27)
spi-meson-spifc.c:78: * @clk:	input clock of the built-in baud rate generator
spi-meson-spifc.c:96: * meson_spifc_wait_ready() - wait for the current operation to terminate
spi-meson-spifc.c:106:		regmap_read(spifc->regmap, REG_SLAVE, &data);
spi-meson-spifc.c:112:	return -ETIMEDOUT;
spi-meson-spifc.c:116: * meson_spifc_drain_buffer() - copy data from device buffer to memory
spi-meson-spifc.c:128:		regmap_read(spifc->regmap, REG_C0 + i, &data);
spi-meson-spifc.c:130:		if (len - i >= 4) {
spi-meson-spifc.c:134:			memcpy(buf, &data, len - i);
spi-meson-spifc.c:142: * meson_spifc_fill_buffer() - copy data from memory to device buffer
spi-meson-spifc.c:154:		if (len - i >= 4)
spi-meson-spifc.c:157:			memcpy(&data, buf, len - i);
spi-meson-spifc.c:159:		regmap_write(spifc->regmap, REG_C0 + i, data);
spi-meson-spifc.c:167: * meson_spifc_setup_speed() - program the clock divider
spi-meson-spifc.c:176:	parent = clk_get_rate(spifc->clk);
spi-meson-spifc.c:177:	n = max_t(int, parent / speed - 1, 1);
spi-meson-spifc.c:179:	dev_dbg(spifc->dev, "parent %lu, speed %u, n %d\n", parent,
spi-meson-spifc.c:184:	value |= (((n + 1) / 2 - 1) << CLOCK_CNT_HIGH_SHIFT) &
spi-meson-spifc.c:187:	regmap_write(spifc->regmap, REG_CLOCK, value);
spi-meson-spifc.c:191: * meson_spifc_txrx() - transfer a chunk of data
spi-meson-spifc.c:208:	if (xfer->tx_buf)
spi-meson-spifc.c:209:		meson_spifc_fill_buffer(spifc, xfer->tx_buf + offset, len);
spi-meson-spifc.c:212:	regmap_update_bits(spifc->regmap, REG_USER, USER_UC_MASK,
spi-meson-spifc.c:214:	regmap_write(spifc->regmap, REG_USER1,
spi-meson-spifc.c:215:		     (8 * len - 1) << USER1_BN_UC_DOUT_SHIFT);
spi-meson-spifc.c:218:	regmap_update_bits(spifc->regmap, REG_USER, USER_DIN_EN_MS,
spi-meson-spifc.c:223:			keep_cs = xfer->cs_change;
spi-meson-spifc.c:225:			keep_cs = !xfer->cs_change;
spi-meson-spifc.c:228:	regmap_update_bits(spifc->regmap, REG_USER4, USER4_CS_ACT,
spi-meson-spifc.c:232:	regmap_update_bits(spifc->regmap, REG_SLAVE, SLAVE_TRST_DONE, 0);
spi-meson-spifc.c:234:	regmap_update_bits(spifc->regmap, REG_CMD, CMD_USER, CMD_USER);
spi-meson-spifc.c:238:	if (!ret && xfer->rx_buf)
spi-meson-spifc.c:239:		meson_spifc_drain_buffer(spifc, xfer->rx_buf + offset, len);
spi-meson-spifc.c:245: * meson_spifc_transfer_one() - perform a single transfer
spi-meson-spifc.c:258:	meson_spifc_setup_speed(spifc, xfer->speed_hz);
spi-meson-spifc.c:260:	regmap_update_bits(spifc->regmap, REG_CTRL, CTRL_ENABLE_AHB, 0);
spi-meson-spifc.c:262:	while (done < xfer->len && !ret) {
spi-meson-spifc.c:263:		len = min_t(int, xfer->len - done, SPIFC_BUFFER_SIZE);
spi-meson-spifc.c:266:				       done + len >= xfer->len);
spi-meson-spifc.c:270:	regmap_update_bits(spifc->regmap, REG_CTRL, CTRL_ENABLE_AHB,
spi-meson-spifc.c:277: * meson_spifc_hw_init() - reset and initialize the SPI controller
spi-meson-spifc.c:283:	regmap_update_bits(spifc->regmap, REG_SLAVE, SLAVE_SW_RST,
spi-meson-spifc.c:286:	regmap_update_bits(spifc->regmap, REG_USER, USER_CMP_MODE, 0);
spi-meson-spifc.c:288:	regmap_update_bits(spifc->regmap, REG_SLAVE, SLAVE_OP_MODE, 0);
spi-meson-spifc.c:300:	master = spi_alloc_master(&pdev->dev, sizeof(struct meson_spifc));
spi-meson-spifc.c:302:		return -ENOMEM;
spi-meson-spifc.c:307:	spifc->dev = &pdev->dev;
spi-meson-spifc.c:310:	base = devm_ioremap_resource(spifc->dev, res);
spi-meson-spifc.c:316:	spifc->regmap = devm_regmap_init_mmio(spifc->dev, base,
spi-meson-spifc.c:318:	if (IS_ERR(spifc->regmap)) {
spi-meson-spifc.c:319:		ret = PTR_ERR(spifc->regmap);
spi-meson-spifc.c:323:	spifc->clk = devm_clk_get(spifc->dev, NULL);
spi-meson-spifc.c:324:	if (IS_ERR(spifc->clk)) {
spi-meson-spifc.c:325:		dev_err(spifc->dev, "missing clock\n");
spi-meson-spifc.c:326:		ret = PTR_ERR(spifc->clk);
spi-meson-spifc.c:330:	ret = clk_prepare_enable(spifc->clk);
spi-meson-spifc.c:332:		dev_err(spifc->dev, "can't prepare clock\n");
spi-meson-spifc.c:336:	rate = clk_get_rate(spifc->clk);
spi-meson-spifc.c:338:	master->num_chipselect = 1;
spi-meson-spifc.c:339:	master->dev.of_node = pdev->dev.of_node;
spi-meson-spifc.c:340:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-meson-spifc.c:341:	master->auto_runtime_pm = true;
spi-meson-spifc.c:342:	master->transfer_one = meson_spifc_transfer_one;
spi-meson-spifc.c:343:	master->min_speed_hz = rate >> 6;
spi-meson-spifc.c:344:	master->max_speed_hz = rate >> 1;
spi-meson-spifc.c:348:	pm_runtime_set_active(spifc->dev);
spi-meson-spifc.c:349:	pm_runtime_enable(spifc->dev);
spi-meson-spifc.c:351:	ret = devm_spi_register_master(spifc->dev, master);
spi-meson-spifc.c:353:		dev_err(spifc->dev, "failed to register spi master\n");
spi-meson-spifc.c:359:	clk_disable_unprepare(spifc->clk);
spi-meson-spifc.c:370:	pm_runtime_get_sync(&pdev->dev);
spi-meson-spifc.c:371:	clk_disable_unprepare(spifc->clk);
spi-meson-spifc.c:372:	pm_runtime_disable(&pdev->dev);
spi-meson-spifc.c:389:		clk_disable_unprepare(spifc->clk);
spi-meson-spifc.c:401:		ret = clk_prepare_enable(spifc->clk);
spi-meson-spifc.c:410:		clk_disable_unprepare(spifc->clk);
spi-meson-spifc.c:422:	clk_disable_unprepare(spifc->clk);
spi-meson-spifc.c:432:	return clk_prepare_enable(spifc->clk);
spi-meson-spifc.c:444:	{ .compatible = "amlogic,meson6-spifc", },
spi-meson-spifc.c:453:		.name		= "meson-spifc",
spi-sh-msiof.c:17:#include <linux/dma-mapping.h>
spi-sh-msiof.c:83:#define MDR1_SYNCAC_SHIFT	 25 /* Sync Polarity (1 = Active-low) */
spi-sh-msiof.c:87:#define MDR1_FLD_MASK	 0x0000000c /* Frame Sync Signal Interval (0-3) */
spi-sh-msiof.c:94:#define MDR2_BITLEN1(i)	(((i) - 1) << 24) /* Data Size (8-32 bits) */
spi-sh-msiof.c:95:#define MDR2_WDLEN1(i)	(((i) - 1) << 16) /* Word Count (1-64/256 (SH, A1))) */
spi-sh-msiof.c:99:#define SCR_BRPS_MASK	    0x1f00 /* Prescaler Setting (1-32) */
spi-sh-msiof.c:100:#define SCR_BRPS(i)	(((i) - 1) << 8)
spi-sh-msiof.c:121:#define CTR_TXDIZ_HIZ	0x00800000 /*   High-impedance */
spi-sh-msiof.c:189:		return ioread16(p->mapbase + reg_offs);
spi-sh-msiof.c:191:		return ioread32(p->mapbase + reg_offs);
spi-sh-msiof.c:201:		iowrite16(value, p->mapbase + reg_offs);
spi-sh-msiof.c:204:		iowrite32(value, p->mapbase + reg_offs);
spi-sh-msiof.c:221:	for (k = 100; k > 0; k--) {
spi-sh-msiof.c:228:	return k > 0 ? 0 : -ETIMEDOUT;
spi-sh-msiof.c:237:	complete(&p->done);
spi-sh-msiof.c:273:	k = min_t(int, k, ARRAY_SIZE(sh_msiof_spi_div_table) - 1);
spi-sh-msiof.c:277:	if (!(p->chipdata->master_flags & SPI_MASTER_MUST_TX))
spi-sh-msiof.c:284:	 * DTDL/SYNCDL bit	: p->info->dtdl or p->info->syncdl
spi-sh-msiof.c:302:	if (!p->info)
spi-sh-msiof.c:306:	if (p->info->dtdl > 200 || p->info->syncdl > 300) {
spi-sh-msiof.c:307:		dev_warn(&p->pdev->dev, "DTDL or SYNCDL is too large\n");
spi-sh-msiof.c:312:	if ((p->info->dtdl + p->info->syncdl) % 100) {
spi-sh-msiof.c:313:		dev_warn(&p->pdev->dev, "the sum of DTDL/SYNCDL is not good\n");
spi-sh-msiof.c:317:	val = sh_msiof_get_delay_bit(p->info->dtdl) << MDR1_DTDL_SHIFT;
spi-sh-msiof.c:318:	val |= sh_msiof_get_delay_bit(p->info->syncdl) << MDR1_SYNCDL_SHIFT;
spi-sh-msiof.c:342:	if (p->chipdata->master_flags & SPI_MASTER_MUST_TX) {
spi-sh-msiof.c:366:	if (tx_buf || (p->chipdata->master_flags & SPI_MASTER_MUST_TX))
spi-sh-msiof.c:523:	struct device_node	*np = spi->master->dev.of_node;
spi-sh-msiof.c:524:	struct sh_msiof_spi_priv *p = spi_master_get_devdata(spi->master);
spi-sh-msiof.c:526:	pm_runtime_get_sync(&p->pdev->dev);
spi-sh-msiof.c:530:		 * Use spi->controller_data for CS (same strategy as spi_gpio),
spi-sh-msiof.c:533:		spi->cs_gpio = (uintptr_t)spi->controller_data;
spi-sh-msiof.c:537:	sh_msiof_spi_set_pin_regs(p, !!(spi->mode & SPI_CPOL),
spi-sh-msiof.c:538:				  !!(spi->mode & SPI_CPHA),
spi-sh-msiof.c:539:				  !!(spi->mode & SPI_3WIRE),
spi-sh-msiof.c:540:				  !!(spi->mode & SPI_LSB_FIRST),
spi-sh-msiof.c:541:				  !!(spi->mode & SPI_CS_HIGH));
spi-sh-msiof.c:543:	if (spi->cs_gpio >= 0)
spi-sh-msiof.c:544:		gpio_set_value(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
spi-sh-msiof.c:547:	pm_runtime_put(&p->pdev->dev);
spi-sh-msiof.c:556:	const struct spi_device *spi = msg->spi;
spi-sh-msiof.c:559:	sh_msiof_spi_set_pin_regs(p, !!(spi->mode & SPI_CPOL),
spi-sh-msiof.c:560:				  !!(spi->mode & SPI_CPHA),
spi-sh-msiof.c:561:				  !!(spi->mode & SPI_3WIRE),
spi-sh-msiof.c:562:				  !!(spi->mode & SPI_LSB_FIRST),
spi-sh-msiof.c:563:				  !!(spi->mode & SPI_CS_HIGH));
spi-sh-msiof.c:614:		words = min_t(int, words, p->tx_fifo_size);
spi-sh-msiof.c:616:		words = min_t(int, words, p->rx_fifo_size);
spi-sh-msiof.c:619:	fifo_shift = 32 - bits;
spi-sh-msiof.c:632:	reinit_completion(&p->done);
spi-sh-msiof.c:636:		dev_err(&p->pdev->dev, "failed to start hardware\n");
spi-sh-msiof.c:641:	if (!wait_for_completion_timeout(&p->done, HZ)) {
spi-sh-msiof.c:642:		dev_err(&p->pdev->dev, "PIO timeout\n");
spi-sh-msiof.c:643:		ret = -ETIMEDOUT;
spi-sh-msiof.c:656:		dev_err(&p->pdev->dev, "failed to shut down hardware\n");
spi-sh-msiof.c:675:	complete(&p->done);
spi-sh-msiof.c:689:		desc_rx = dmaengine_prep_slave_single(p->master->dma_rx,
spi-sh-msiof.c:690:					p->rx_dma_addr, len, DMA_FROM_DEVICE,
spi-sh-msiof.c:693:			return -EAGAIN;
spi-sh-msiof.c:695:		desc_rx->callback = sh_msiof_dma_complete;
spi-sh-msiof.c:696:		desc_rx->callback_param = p;
spi-sh-msiof.c:704:		dma_sync_single_for_device(p->master->dma_tx->device->dev,
spi-sh-msiof.c:705:					   p->tx_dma_addr, len, DMA_TO_DEVICE);
spi-sh-msiof.c:706:		desc_tx = dmaengine_prep_slave_single(p->master->dma_tx,
spi-sh-msiof.c:707:					p->tx_dma_addr, len, DMA_TO_DEVICE,
spi-sh-msiof.c:710:			ret = -EAGAIN;
spi-sh-msiof.c:716:			desc_tx->callback = NULL;
spi-sh-msiof.c:718:			desc_tx->callback = sh_msiof_dma_complete;
spi-sh-msiof.c:719:			desc_tx->callback_param = p;
spi-sh-msiof.c:731:	/* setup msiof transfer mode registers (32-bit words) */
spi-sh-msiof.c:736:	reinit_completion(&p->done);
spi-sh-msiof.c:740:		dma_async_issue_pending(p->master->dma_rx);
spi-sh-msiof.c:742:		dma_async_issue_pending(p->master->dma_tx);
spi-sh-msiof.c:746:		dev_err(&p->pdev->dev, "failed to start hardware\n");
spi-sh-msiof.c:751:	if (!wait_for_completion_timeout(&p->done, HZ)) {
spi-sh-msiof.c:752:		dev_err(&p->pdev->dev, "DMA timeout\n");
spi-sh-msiof.c:753:		ret = -ETIMEDOUT;
spi-sh-msiof.c:762:		dev_err(&p->pdev->dev, "failed to shut down hardware\n");
spi-sh-msiof.c:767:		dma_sync_single_for_cpu(p->master->dma_rx->device->dev,
spi-sh-msiof.c:768:					p->rx_dma_addr, len,
spi-sh-msiof.c:778:		dmaengine_terminate_all(p->master->dma_tx);
spi-sh-msiof.c:781:		dmaengine_terminate_all(p->master->dma_rx);
spi-sh-msiof.c:790:		while (words--) {
spi-sh-msiof.c:795:		while (words--) {
spi-sh-msiof.c:800:		while (words--)
spi-sh-msiof.c:809:		while (words--) {
spi-sh-msiof.c:814:		while (words--) {
spi-sh-msiof.c:819:		while (words--)
spi-sh-msiof.c:837:	const void *tx_buf = t->tx_buf;
spi-sh-msiof.c:838:	void *rx_buf = t->rx_buf;
spi-sh-msiof.c:839:	unsigned int len = t->len;
spi-sh-msiof.c:840:	unsigned int bits = t->bits_per_word;
spi-sh-msiof.c:848:	sh_msiof_spi_set_clk_regs(p, clk_get_rate(p->clk), t->speed_hz);
spi-sh-msiof.c:850:	while (master->dma_tx && len > 15) {
spi-sh-msiof.c:852:		 *  DMA supports 32-bit words only, hence pack 8-bit and 16-bit
spi-sh-msiof.c:858:			l = min(len, p->tx_fifo_size * 4);
spi-sh-msiof.c:860:			l = min(len, p->rx_fifo_size * 4);
spi-sh-msiof.c:875:			copy32(p->tx_dma_page, tx_buf, l / 4);
spi-sh-msiof.c:878:		if (ret == -EAGAIN) {
spi-sh-msiof.c:880:				     dev_driver_string(&p->pdev->dev),
spi-sh-msiof.c:881:				     dev_name(&p->pdev->dev));
spi-sh-msiof.c:888:			copy32(rx_buf, p->rx_dma_page, l / 4);
spi-sh-msiof.c:894:		len -= l;
spi-sh-msiof.c:959:		words -= n;
spi-sh-msiof.c:978:	{ .compatible = "renesas,sh-msiof",        .data = &sh_data },
spi-sh-msiof.c:979:	{ .compatible = "renesas,sh-mobile-msiof", .data = &sh_data },
spi-sh-msiof.c:980:	{ .compatible = "renesas,msiof-r8a7790",   .data = &r8a779x_data },
spi-sh-msiof.c:981:	{ .compatible = "renesas,msiof-r8a7791",   .data = &r8a779x_data },
spi-sh-msiof.c:982:	{ .compatible = "renesas,msiof-r8a7792",   .data = &r8a779x_data },
spi-sh-msiof.c:983:	{ .compatible = "renesas,msiof-r8a7793",   .data = &r8a779x_data },
spi-sh-msiof.c:984:	{ .compatible = "renesas,msiof-r8a7794",   .data = &r8a779x_data },
spi-sh-msiof.c:993:	struct device_node *np = dev->of_node;
spi-sh-msiof.c:1001:	of_property_read_u32(np, "num-cs", &num_cs);
spi-sh-msiof.c:1002:	of_property_read_u32(np, "renesas,tx-fifo-size",
spi-sh-msiof.c:1003:					&info->tx_fifo_override);
spi-sh-msiof.c:1004:	of_property_read_u32(np, "renesas,rx-fifo-size",
spi-sh-msiof.c:1005:					&info->rx_fifo_override);
spi-sh-msiof.c:1006:	of_property_read_u32(np, "renesas,dtdl", &info->dtdl);
spi-sh-msiof.c:1007:	of_property_read_u32(np, "renesas,syncdl", &info->syncdl);
spi-sh-msiof.c:1009:	info->num_chipselect = num_cs;
spi-sh-msiof.c:1061:	struct platform_device *pdev = p->pdev;
spi-sh-msiof.c:1062:	struct device *dev = &pdev->dev;
spi-sh-msiof.c:1069:	if (dev->of_node) {
spi-sh-msiof.c:1073:	} else if (info && info->dma_tx_id && info->dma_rx_id) {
spi-sh-msiof.c:1074:		dma_tx_id = info->dma_tx_id;
spi-sh-msiof.c:1075:		dma_rx_id = info->dma_rx_id;
spi-sh-msiof.c:1086:	master = p->master;
spi-sh-msiof.c:1087:	master->dma_tx = sh_msiof_request_dma_chan(dev, DMA_MEM_TO_DEV,
spi-sh-msiof.c:1089:						   res->start + TFDR);
spi-sh-msiof.c:1090:	if (!master->dma_tx)
spi-sh-msiof.c:1091:		return -ENODEV;
spi-sh-msiof.c:1093:	master->dma_rx = sh_msiof_request_dma_chan(dev, DMA_DEV_TO_MEM,
spi-sh-msiof.c:1095:						   res->start + RFDR);
spi-sh-msiof.c:1096:	if (!master->dma_rx)
spi-sh-msiof.c:1099:	p->tx_dma_page = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
spi-sh-msiof.c:1100:	if (!p->tx_dma_page)
spi-sh-msiof.c:1103:	p->rx_dma_page = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
spi-sh-msiof.c:1104:	if (!p->rx_dma_page)
spi-sh-msiof.c:1107:	tx_dev = master->dma_tx->device->dev;
spi-sh-msiof.c:1108:	p->tx_dma_addr = dma_map_single(tx_dev, p->tx_dma_page, PAGE_SIZE,
spi-sh-msiof.c:1110:	if (dma_mapping_error(tx_dev, p->tx_dma_addr))
spi-sh-msiof.c:1113:	rx_dev = master->dma_rx->device->dev;
spi-sh-msiof.c:1114:	p->rx_dma_addr = dma_map_single(rx_dev, p->rx_dma_page, PAGE_SIZE,
spi-sh-msiof.c:1116:	if (dma_mapping_error(rx_dev, p->rx_dma_addr))
spi-sh-msiof.c:1123:	dma_unmap_single(tx_dev, p->tx_dma_addr, PAGE_SIZE, DMA_TO_DEVICE);
spi-sh-msiof.c:1125:	free_page((unsigned long)p->rx_dma_page);
spi-sh-msiof.c:1127:	free_page((unsigned long)p->tx_dma_page);
spi-sh-msiof.c:1129:	dma_release_channel(master->dma_rx);
spi-sh-msiof.c:1131:	dma_release_channel(master->dma_tx);
spi-sh-msiof.c:1132:	master->dma_tx = NULL;
spi-sh-msiof.c:1133:	return -ENODEV;
spi-sh-msiof.c:1138:	struct spi_master *master = p->master;
spi-sh-msiof.c:1141:	if (!master->dma_tx)
spi-sh-msiof.c:1144:	dev = &p->pdev->dev;
spi-sh-msiof.c:1145:	dma_unmap_single(master->dma_rx->device->dev, p->rx_dma_addr,
spi-sh-msiof.c:1147:	dma_unmap_single(master->dma_tx->device->dev, p->tx_dma_addr,
spi-sh-msiof.c:1149:	free_page((unsigned long)p->rx_dma_page);
spi-sh-msiof.c:1150:	free_page((unsigned long)p->tx_dma_page);
spi-sh-msiof.c:1151:	dma_release_channel(master->dma_rx);
spi-sh-msiof.c:1152:	dma_release_channel(master->dma_tx);
spi-sh-msiof.c:1164:	master = spi_alloc_master(&pdev->dev, sizeof(struct sh_msiof_spi_priv));
spi-sh-msiof.c:1166:		dev_err(&pdev->dev, "failed to allocate spi master\n");
spi-sh-msiof.c:1167:		return -ENOMEM;
spi-sh-msiof.c:1173:	p->master = master;
spi-sh-msiof.c:1175:	of_id = of_match_device(sh_msiof_match, &pdev->dev);
spi-sh-msiof.c:1177:		p->chipdata = of_id->data;
spi-sh-msiof.c:1178:		p->info = sh_msiof_spi_parse_dt(&pdev->dev);
spi-sh-msiof.c:1180:		p->chipdata = (const void *)pdev->id_entry->driver_data;
spi-sh-msiof.c:1181:		p->info = dev_get_platdata(&pdev->dev);
spi-sh-msiof.c:1184:	if (!p->info) {
spi-sh-msiof.c:1185:		dev_err(&pdev->dev, "failed to obtain device info\n");
spi-sh-msiof.c:1186:		ret = -ENXIO;
spi-sh-msiof.c:1190:	init_completion(&p->done);
spi-sh-msiof.c:1192:	p->clk = devm_clk_get(&pdev->dev, NULL);
spi-sh-msiof.c:1193:	if (IS_ERR(p->clk)) {
spi-sh-msiof.c:1194:		dev_err(&pdev->dev, "cannot get clock\n");
spi-sh-msiof.c:1195:		ret = PTR_ERR(p->clk);
spi-sh-msiof.c:1201:		dev_err(&pdev->dev, "cannot get platform IRQ\n");
spi-sh-msiof.c:1202:		ret = -ENOENT;
spi-sh-msiof.c:1207:	p->mapbase = devm_ioremap_resource(&pdev->dev, r);
spi-sh-msiof.c:1208:	if (IS_ERR(p->mapbase)) {
spi-sh-msiof.c:1209:		ret = PTR_ERR(p->mapbase);
spi-sh-msiof.c:1213:	ret = devm_request_irq(&pdev->dev, i, sh_msiof_spi_irq, 0,
spi-sh-msiof.c:1214:			       dev_name(&pdev->dev), p);
spi-sh-msiof.c:1216:		dev_err(&pdev->dev, "unable to request irq\n");
spi-sh-msiof.c:1220:	p->pdev = pdev;
spi-sh-msiof.c:1221:	pm_runtime_enable(&pdev->dev);
spi-sh-msiof.c:1224:	p->tx_fifo_size = p->chipdata->tx_fifo_size;
spi-sh-msiof.c:1225:	p->rx_fifo_size = p->chipdata->rx_fifo_size;
spi-sh-msiof.c:1226:	if (p->info->tx_fifo_override)
spi-sh-msiof.c:1227:		p->tx_fifo_size = p->info->tx_fifo_override;
spi-sh-msiof.c:1228:	if (p->info->rx_fifo_override)
spi-sh-msiof.c:1229:		p->rx_fifo_size = p->info->rx_fifo_override;
spi-sh-msiof.c:1232:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-sh-msiof.c:1233:	master->mode_bits |= SPI_LSB_FIRST | SPI_3WIRE;
spi-sh-msiof.c:1234:	master->flags = p->chipdata->master_flags;
spi-sh-msiof.c:1235:	master->bus_num = pdev->id;
spi-sh-msiof.c:1236:	master->dev.of_node = pdev->dev.of_node;
spi-sh-msiof.c:1237:	master->num_chipselect = p->info->num_chipselect;
spi-sh-msiof.c:1238:	master->setup = sh_msiof_spi_setup;
spi-sh-msiof.c:1239:	master->prepare_message = sh_msiof_prepare_message;
spi-sh-msiof.c:1240:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32);
spi-sh-msiof.c:1241:	master->auto_runtime_pm = true;
spi-sh-msiof.c:1242:	master->transfer_one = sh_msiof_transfer_one;
spi-sh-msiof.c:1246:		dev_warn(&pdev->dev, "DMA not available, using PIO\n");
spi-sh-msiof.c:1248:	ret = devm_spi_register_master(&pdev->dev, master);
spi-sh-msiof.c:1250:		dev_err(&pdev->dev, "spi_register_master error.\n");
spi-sh-msiof.c:1258:	pm_runtime_disable(&pdev->dev);
spi-sh-msiof.c:1269:	pm_runtime_disable(&pdev->dev);
spi-sh-msiof.c:1285:	return spi_master_suspend(p->master);
spi-sh-msiof.c:1293:	return spi_master_resume(p->master);
spi-sun6i.c:2: * Copyright (C) 2012 - 2014 Allwinner Tech
spi-sun6i.c:6: * Maxime Ripard <maxime.ripard@free-electrons.com>
spi-sun6i.c:97:	return readl(sspi->base_addr + reg);
spi-sun6i.c:102:	writel(value, sspi->base_addr + reg);
spi-sun6i.c:118:	while (len--) {
spi-sun6i.c:119:		byte = readb(sspi->base_addr + SUN6I_RXDATA_REG);
spi-sun6i.c:120:		if (sspi->rx_buf)
spi-sun6i.c:121:			*sspi->rx_buf++ = byte;
spi-sun6i.c:129:	if (len > sspi->len)
spi-sun6i.c:130:		len = sspi->len;
spi-sun6i.c:132:	while (len--) {
spi-sun6i.c:133:		byte = sspi->tx_buf ? *sspi->tx_buf++ : 0;
spi-sun6i.c:134:		writeb(byte, sspi->base_addr + SUN6I_TXDATA_REG);
spi-sun6i.c:135:		sspi->len--;
spi-sun6i.c:141:	struct sun6i_spi *sspi = spi_master_get_devdata(spi->master);
spi-sun6i.c:146:	reg |= SUN6I_TFR_CTL_CS(spi->chip_select);
spi-sun6i.c:169:	if (tfr->len > SUN6I_FIFO_DEPTH)
spi-sun6i.c:170:		return -EINVAL;
spi-sun6i.c:172:	reinit_completion(&sspi->done);
spi-sun6i.c:173:	sspi->tx_buf = tfr->tx_buf;
spi-sun6i.c:174:	sspi->rx_buf = tfr->rx_buf;
spi-sun6i.c:175:	sspi->len = tfr->len;
spi-sun6i.c:190:	if (spi->mode & SPI_CPOL)
spi-sun6i.c:195:	if (spi->mode & SPI_CPHA)
spi-sun6i.c:200:	if (spi->mode & SPI_LSB_FIRST)
spi-sun6i.c:209:	if (sspi->rx_buf)
spi-sun6i.c:220:	mclk_rate = clk_get_rate(sspi->mclk);
spi-sun6i.c:221:	if (mclk_rate < (2 * spi->max_speed_hz)) {
spi-sun6i.c:222:		clk_set_rate(sspi->mclk, 2 * spi->max_speed_hz);
spi-sun6i.c:223:		mclk_rate = clk_get_rate(sspi->mclk);
spi-sun6i.c:240:	div = mclk_rate / (2 * spi->max_speed_hz);
spi-sun6i.c:243:			div--;
spi-sun6i.c:247:		div = ilog2(mclk_rate) - ilog2(spi->max_speed_hz);
spi-sun6i.c:254:	if (sspi->tx_buf)
spi-sun6i.c:255:		tx_len = tfr->len;
spi-sun6i.c:258:	sun6i_spi_write(sspi, SUN6I_BURST_CNT_REG, SUN6I_BURST_CNT(tfr->len));
spi-sun6i.c:273:	tx_time = max(tfr->len * 8 * 2 / (tfr->speed_hz / 1000), 100U);
spi-sun6i.c:275:	timeout = wait_for_completion_timeout(&sspi->done,
spi-sun6i.c:279:		dev_warn(&master->dev,
spi-sun6i.c:281:			 dev_name(&spi->dev), tfr->len, tfr->speed_hz,
spi-sun6i.c:282:			 jiffies_to_msecs(end - start), tx_time);
spi-sun6i.c:283:		ret = -ETIMEDOUT;
spi-sun6i.c:303:		complete(&sspi->done);
spi-sun6i.c:316:	ret = clk_prepare_enable(sspi->hclk);
spi-sun6i.c:322:	ret = clk_prepare_enable(sspi->mclk);
spi-sun6i.c:328:	ret = reset_control_deassert(sspi->rstc);
spi-sun6i.c:340:	clk_disable_unprepare(sspi->mclk);
spi-sun6i.c:342:	clk_disable_unprepare(sspi->hclk);
spi-sun6i.c:352:	reset_control_assert(sspi->rstc);
spi-sun6i.c:353:	clk_disable_unprepare(sspi->mclk);
spi-sun6i.c:354:	clk_disable_unprepare(sspi->hclk);
spi-sun6i.c:366:	master = spi_alloc_master(&pdev->dev, sizeof(struct sun6i_spi));
spi-sun6i.c:368:		dev_err(&pdev->dev, "Unable to allocate SPI Master\n");
spi-sun6i.c:369:		return -ENOMEM;
spi-sun6i.c:376:	sspi->base_addr = devm_ioremap_resource(&pdev->dev, res);
spi-sun6i.c:377:	if (IS_ERR(sspi->base_addr)) {
spi-sun6i.c:378:		ret = PTR_ERR(sspi->base_addr);
spi-sun6i.c:384:		dev_err(&pdev->dev, "No spi IRQ specified\n");
spi-sun6i.c:385:		ret = -ENXIO;
spi-sun6i.c:389:	ret = devm_request_irq(&pdev->dev, irq, sun6i_spi_handler,
spi-sun6i.c:390:			       0, "sun6i-spi", sspi);
spi-sun6i.c:392:		dev_err(&pdev->dev, "Cannot request IRQ\n");
spi-sun6i.c:396:	sspi->master = master;
spi-sun6i.c:397:	master->set_cs = sun6i_spi_set_cs;
spi-sun6i.c:398:	master->transfer_one = sun6i_spi_transfer_one;
spi-sun6i.c:399:	master->num_chipselect = 4;
spi-sun6i.c:400:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;
spi-sun6i.c:401:	master->bits_per_word_mask = SPI_BPW_MASK(8);
spi-sun6i.c:402:	master->dev.of_node = pdev->dev.of_node;
spi-sun6i.c:403:	master->auto_runtime_pm = true;
spi-sun6i.c:405:	sspi->hclk = devm_clk_get(&pdev->dev, "ahb");
spi-sun6i.c:406:	if (IS_ERR(sspi->hclk)) {
spi-sun6i.c:407:		dev_err(&pdev->dev, "Unable to acquire AHB clock\n");
spi-sun6i.c:408:		ret = PTR_ERR(sspi->hclk);
spi-sun6i.c:412:	sspi->mclk = devm_clk_get(&pdev->dev, "mod");
spi-sun6i.c:413:	if (IS_ERR(sspi->mclk)) {
spi-sun6i.c:414:		dev_err(&pdev->dev, "Unable to acquire module clock\n");
spi-sun6i.c:415:		ret = PTR_ERR(sspi->mclk);
spi-sun6i.c:419:	init_completion(&sspi->done);
spi-sun6i.c:421:	sspi->rstc = devm_reset_control_get(&pdev->dev, NULL);
spi-sun6i.c:422:	if (IS_ERR(sspi->rstc)) {
spi-sun6i.c:423:		dev_err(&pdev->dev, "Couldn't get reset controller\n");
spi-sun6i.c:424:		ret = PTR_ERR(sspi->rstc);
spi-sun6i.c:429:	 * This wake-up/shutdown pattern is to be able to have the
spi-sun6i.c:432:	ret = sun6i_spi_runtime_resume(&pdev->dev);
spi-sun6i.c:434:		dev_err(&pdev->dev, "Couldn't resume the device\n");
spi-sun6i.c:438:	pm_runtime_set_active(&pdev->dev);
spi-sun6i.c:439:	pm_runtime_enable(&pdev->dev);
spi-sun6i.c:440:	pm_runtime_idle(&pdev->dev);
spi-sun6i.c:442:	ret = devm_spi_register_master(&pdev->dev, master);
spi-sun6i.c:444:		dev_err(&pdev->dev, "cannot register SPI master\n");
spi-sun6i.c:451:	pm_runtime_disable(&pdev->dev);
spi-sun6i.c:452:	sun6i_spi_runtime_suspend(&pdev->dev);
spi-sun6i.c:460:	pm_runtime_force_suspend(&pdev->dev);
spi-sun6i.c:466:	{ .compatible = "allwinner,sun6i-a31-spi", },
spi-sun6i.c:480:		.name		= "sun6i-spi",
spi-sun6i.c:488:MODULE_AUTHOR("Maxime Ripard <maxime.ripard@free-electrons.com>");
spi-au1550.c:30:#include <linux/dma-mapping.h>
spi-au1550.c:32:#include <asm/mach-au1x00/au1000.h>
spi-au1550.c:33:#include <asm/mach-au1x00/au1xxx_psc.h>
spi-au1550.c:34:#include <asm/mach-au1x00/au1xxx_dbdma.h>
spi-au1550.c:36:#include <asm/mach-au1x00/au1550_spi.h>
spi-au1550.c:85:/* we use an 8-bit memory device for dma transfers to/from spi fifo */
spi-au1550.c:113:	u32 mainclk_hz = hw->pdata->mainclk_hz;
spi-au1550.c:130:	brg--;
spi-au1550.c:136:	hw->regs->psc_spimsk =
spi-au1550.c:142:	hw->regs->psc_spievent =
spi-au1550.c:153:	hw->regs->psc_spipcr = PSC_SPIPCR_RC | PSC_SPIPCR_TC;
spi-au1550.c:156:		pcr = hw->regs->psc_spipcr;
spi-au1550.c:162: * dma transfers are used for the most common spi word size of 8-bits
spi-au1550.c:164: * dma support for more than 8-bit words (up to 24 bits), we would need to
spi-au1550.c:172:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
spi-au1550.c:173:	unsigned cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;
spi-au1550.c:178:		if (hw->pdata->deactivate_cs)
spi-au1550.c:179:			hw->pdata->deactivate_cs(hw->pdata, spi->chip_select,
spi-au1550.c:184:		au1550_spi_bits_handlers_set(hw, spi->bits_per_word);
spi-au1550.c:186:		cfg = hw->regs->psc_spicfg;
spi-au1550.c:188:		hw->regs->psc_spicfg = cfg & ~PSC_SPICFG_DE_ENABLE;
spi-au1550.c:191:		if (spi->mode & SPI_CPOL)
spi-au1550.c:195:		if (spi->mode & SPI_CPHA)
spi-au1550.c:200:		if (spi->mode & SPI_LSB_FIRST)
spi-au1550.c:205:		if (hw->usedma && spi->bits_per_word <= 8)
spi-au1550.c:210:		cfg |= PSC_SPICFG_SET_LEN(spi->bits_per_word);
spi-au1550.c:214:		cfg |= au1550_spi_baudcfg(hw, spi->max_speed_hz);
spi-au1550.c:216:		hw->regs->psc_spicfg = cfg | PSC_SPICFG_DE_ENABLE;
spi-au1550.c:219:			stat = hw->regs->psc_spistat;
spi-au1550.c:223:		if (hw->pdata->activate_cs)
spi-au1550.c:224:			hw->pdata->activate_cs(hw->pdata, spi->chip_select,
spi-au1550.c:232:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
spi-au1550.c:237:		bpw = t->bits_per_word;
spi-au1550.c:238:		hz = t->speed_hz;
spi-au1550.c:240:		bpw = spi->bits_per_word;
spi-au1550.c:241:		hz = spi->max_speed_hz;
spi-au1550.c:245:		return -EINVAL;
spi-au1550.c:247:	au1550_spi_bits_handlers_set(hw, spi->bits_per_word);
spi-au1550.c:249:	cfg = hw->regs->psc_spicfg;
spi-au1550.c:251:	hw->regs->psc_spicfg = cfg & ~PSC_SPICFG_DE_ENABLE;
spi-au1550.c:254:	if (hw->usedma && bpw <= 8)
spi-au1550.c:265:	hw->regs->psc_spicfg = cfg;
spi-au1550.c:270:			stat = hw->regs->psc_spistat;
spi-au1550.c:290:	hw->dma_rx_tmpbuf = kmalloc(size, GFP_KERNEL);
spi-au1550.c:291:	if (!hw->dma_rx_tmpbuf)
spi-au1550.c:292:		return -ENOMEM;
spi-au1550.c:293:	hw->dma_rx_tmpbuf_size = size;
spi-au1550.c:294:	hw->dma_rx_tmpbuf_addr = dma_map_single(hw->dev, hw->dma_rx_tmpbuf,
spi-au1550.c:296:	if (dma_mapping_error(hw->dev, hw->dma_rx_tmpbuf_addr)) {
spi-au1550.c:297:		kfree(hw->dma_rx_tmpbuf);
spi-au1550.c:298:		hw->dma_rx_tmpbuf = 0;
spi-au1550.c:299:		hw->dma_rx_tmpbuf_size = 0;
spi-au1550.c:300:		return -EFAULT;
spi-au1550.c:307:	dma_unmap_single(hw->dev, hw->dma_rx_tmpbuf_addr,
spi-au1550.c:308:			hw->dma_rx_tmpbuf_size, DMA_FROM_DEVICE);
spi-au1550.c:309:	kfree(hw->dma_rx_tmpbuf);
spi-au1550.c:310:	hw->dma_rx_tmpbuf = 0;
spi-au1550.c:311:	hw->dma_rx_tmpbuf_size = 0;
spi-au1550.c:316:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
spi-au1550.c:321:	hw->len = t->len;
spi-au1550.c:322:	hw->tx_count = 0;
spi-au1550.c:323:	hw->rx_count = 0;
spi-au1550.c:325:	hw->tx = t->tx_buf;
spi-au1550.c:326:	hw->rx = t->rx_buf;
spi-au1550.c:327:	dma_tx_addr = t->tx_dma;
spi-au1550.c:328:	dma_rx_addr = t->rx_dma;
spi-au1550.c:332:	 * - first map the TX buffer, so cache data gets written to memory
spi-au1550.c:333:	 * - then map the RX buffer, so that cache entries (with
spi-au1550.c:334:	 *   soon-to-be-stale data) get removed
spi-au1550.c:338:	if (t->tx_buf) {
spi-au1550.c:339:		if (t->tx_dma == 0) {	/* if DMA_ADDR_INVALID, map it */
spi-au1550.c:340:			dma_tx_addr = dma_map_single(hw->dev,
spi-au1550.c:341:					(void *)t->tx_buf,
spi-au1550.c:342:					t->len, DMA_TO_DEVICE);
spi-au1550.c:343:			if (dma_mapping_error(hw->dev, dma_tx_addr))
spi-au1550.c:344:				dev_err(hw->dev, "tx dma map error\n");
spi-au1550.c:348:	if (t->rx_buf) {
spi-au1550.c:349:		if (t->rx_dma == 0) {	/* if DMA_ADDR_INVALID, map it */
spi-au1550.c:350:			dma_rx_addr = dma_map_single(hw->dev,
spi-au1550.c:351:					(void *)t->rx_buf,
spi-au1550.c:352:					t->len, DMA_FROM_DEVICE);
spi-au1550.c:353:			if (dma_mapping_error(hw->dev, dma_rx_addr))
spi-au1550.c:354:				dev_err(hw->dev, "rx dma map error\n");
spi-au1550.c:357:		if (t->len > hw->dma_rx_tmpbuf_size) {
spi-au1550.c:361:			ret = au1550_spi_dma_rxtmp_alloc(hw, max(t->len,
spi-au1550.c:366:		hw->rx = hw->dma_rx_tmpbuf;
spi-au1550.c:367:		dma_rx_addr = hw->dma_rx_tmpbuf_addr;
spi-au1550.c:368:		dma_sync_single_for_device(hw->dev, dma_rx_addr,
spi-au1550.c:369:			t->len, DMA_FROM_DEVICE);
spi-au1550.c:372:	if (!t->tx_buf) {
spi-au1550.c:373:		dma_sync_single_for_device(hw->dev, dma_rx_addr,
spi-au1550.c:374:				t->len, DMA_BIDIRECTIONAL);
spi-au1550.c:375:		hw->tx = hw->rx;
spi-au1550.c:379:	res = au1xxx_dbdma_put_dest(hw->dma_rx_ch, virt_to_phys(hw->rx),
spi-au1550.c:380:				    t->len, DDMA_FLAGS_IE);
spi-au1550.c:382:		dev_err(hw->dev, "rx dma put dest error\n");
spi-au1550.c:384:	res = au1xxx_dbdma_put_source(hw->dma_tx_ch, virt_to_phys(hw->tx),
spi-au1550.c:385:				      t->len, DDMA_FLAGS_IE);
spi-au1550.c:387:		dev_err(hw->dev, "tx dma put source error\n");
spi-au1550.c:389:	au1xxx_dbdma_start(hw->dma_rx_ch);
spi-au1550.c:390:	au1xxx_dbdma_start(hw->dma_tx_ch);
spi-au1550.c:393:	hw->regs->psc_spimsk = PSC_SPIMSK_SD;
spi-au1550.c:397:	hw->regs->psc_spipcr = PSC_SPIPCR_MS;
spi-au1550.c:400:	wait_for_completion(&hw->master_done);
spi-au1550.c:402:	au1xxx_dbdma_stop(hw->dma_tx_ch);
spi-au1550.c:403:	au1xxx_dbdma_stop(hw->dma_rx_ch);
spi-au1550.c:405:	if (!t->rx_buf) {
spi-au1550.c:407:		dma_sync_single_for_cpu(hw->dev, dma_rx_addr, t->len,
spi-au1550.c:411:	if (t->rx_buf && t->rx_dma == 0 )
spi-au1550.c:412:		dma_unmap_single(hw->dev, dma_rx_addr, t->len,
spi-au1550.c:414:	if (t->tx_buf && t->tx_dma == 0 )
spi-au1550.c:415:		dma_unmap_single(hw->dev, dma_tx_addr, t->len,
spi-au1550.c:418:	return hw->rx_count < hw->tx_count ? hw->rx_count : hw->tx_count;
spi-au1550.c:425:	stat = hw->regs->psc_spistat;
spi-au1550.c:426:	evnt = hw->regs->psc_spievent;
spi-au1550.c:429:		dev_err(hw->dev, "Unexpected IRQ!\n");
spi-au1550.c:443:		au1xxx_dbdma_stop(hw->dma_rx_ch);
spi-au1550.c:444:		au1xxx_dbdma_stop(hw->dma_tx_ch);
spi-au1550.c:447:		hw->rx_count = hw->len - au1xxx_get_dma_residue(hw->dma_rx_ch);
spi-au1550.c:448:		hw->tx_count = hw->len - au1xxx_get_dma_residue(hw->dma_tx_ch);
spi-au1550.c:450:		au1xxx_dbdma_reset(hw->dma_rx_ch);
spi-au1550.c:451:		au1xxx_dbdma_reset(hw->dma_tx_ch);
spi-au1550.c:455:			dev_err(hw->dev,
spi-au1550.c:458:			dev_err(hw->dev,
spi-au1550.c:462:		complete(&hw->master_done);
spi-au1550.c:469:		hw->rx_count = hw->len;
spi-au1550.c:470:		hw->tx_count = hw->len;
spi-au1550.c:471:		complete(&hw->master_done);
spi-au1550.c:481:	u32 fifoword = hw->regs->psc_spitxrx & (u32)(mask);		\
spi-au1550.c:483:	if (hw->rx) {							\
spi-au1550.c:484:		*(u##size *)hw->rx = (u##size)fifoword;			\
spi-au1550.c:485:		hw->rx += (size) / 8;					\
spi-au1550.c:487:	hw->rx_count += (size) / 8;					\
spi-au1550.c:494:	if (hw->tx) {							\
spi-au1550.c:495:		fifoword = *(u##size *)hw->tx & (u32)(mask);		\
spi-au1550.c:496:		hw->tx += (size) / 8;					\
spi-au1550.c:498:	hw->tx_count += (size) / 8;					\
spi-au1550.c:499:	if (hw->tx_count >= hw->len)					\
spi-au1550.c:501:	hw->regs->psc_spitxrx = fifoword;				\
spi-au1550.c:515:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
spi-au1550.c:517:	hw->tx = t->tx_buf;
spi-au1550.c:518:	hw->rx = t->rx_buf;
spi-au1550.c:519:	hw->len = t->len;
spi-au1550.c:520:	hw->tx_count = 0;
spi-au1550.c:521:	hw->rx_count = 0;
spi-au1550.c:527:	while (hw->tx_count < hw->len) {
spi-au1550.c:529:		hw->tx_word(hw);
spi-au1550.c:531:		if (hw->tx_count >= hw->len) {
spi-au1550.c:536:		stat = hw->regs->psc_spistat;
spi-au1550.c:543:	hw->regs->psc_spimsk = mask;
spi-au1550.c:547:	hw->regs->psc_spipcr = PSC_SPIPCR_MS;
spi-au1550.c:550:	wait_for_completion(&hw->master_done);
spi-au1550.c:552:	return hw->rx_count < hw->tx_count ? hw->rx_count : hw->tx_count;
spi-au1550.c:560:	stat = hw->regs->psc_spistat;
spi-au1550.c:561:	evnt = hw->regs->psc_spievent;
spi-au1550.c:564:		dev_err(hw->dev, "Unexpected IRQ!\n");
spi-au1550.c:578:		dev_err(hw->dev,
spi-au1550.c:581:		complete(&hw->master_done);
spi-au1550.c:591:		stat = hw->regs->psc_spistat;
spi-au1550.c:603:		if (!(stat & PSC_SPISTAT_RE) && hw->rx_count < hw->len) {
spi-au1550.c:604:			hw->rx_word(hw);
spi-au1550.c:607:			if (!(stat & PSC_SPISTAT_TF) && hw->tx_count < hw->len)
spi-au1550.c:608:				hw->tx_word(hw);
spi-au1550.c:612:	hw->regs->psc_spievent = PSC_SPIEVNT_RR | PSC_SPIEVNT_TR;
spi-au1550.c:618:	 * of Figure 8-4 with flowchart for SPI master operation:
spi-au1550.c:622:	 * Rx FIFO Overflow, or Multiple-master Error
spi-au1550.c:631:		hw->regs->psc_spievent = PSC_SPIEVNT_TU | PSC_SPIEVNT_MD;
spi-au1550.c:633:		hw->regs->psc_spipcr = PSC_SPIPCR_MS;
spi-au1550.c:637:	if (hw->rx_count >= hw->len) {
spi-au1550.c:640:		complete(&hw->master_done);
spi-au1550.c:647:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
spi-au1550.c:648:	return hw->txrx_bufs(spi, t);
spi-au1550.c:654:	return hw->irq_callback(hw);
spi-au1550.c:660:		if (hw->usedma) {
spi-au1550.c:661:			hw->txrx_bufs = &au1550_spi_dma_txrxb;
spi-au1550.c:662:			hw->irq_callback = &au1550_spi_dma_irq_callback;
spi-au1550.c:664:			hw->rx_word = &au1550_spi_rx_word_8;
spi-au1550.c:665:			hw->tx_word = &au1550_spi_tx_word_8;
spi-au1550.c:666:			hw->txrx_bufs = &au1550_spi_pio_txrxb;
spi-au1550.c:667:			hw->irq_callback = &au1550_spi_pio_irq_callback;
spi-au1550.c:670:		hw->rx_word = &au1550_spi_rx_word_16;
spi-au1550.c:671:		hw->tx_word = &au1550_spi_tx_word_16;
spi-au1550.c:672:		hw->txrx_bufs = &au1550_spi_pio_txrxb;
spi-au1550.c:673:		hw->irq_callback = &au1550_spi_pio_irq_callback;
spi-au1550.c:675:		hw->rx_word = &au1550_spi_rx_word_32;
spi-au1550.c:676:		hw->tx_word = &au1550_spi_tx_word_32;
spi-au1550.c:677:		hw->txrx_bufs = &au1550_spi_pio_txrxb;
spi-au1550.c:678:		hw->irq_callback = &au1550_spi_pio_irq_callback;
spi-au1550.c:687:	hw->regs->psc_ctrl = PSC_CTRL_DISABLE;
spi-au1550.c:689:	hw->regs->psc_sel = PSC_SEL_PS_SPIMODE;
spi-au1550.c:692:	hw->regs->psc_spicfg = 0;
spi-au1550.c:695:	hw->regs->psc_ctrl = PSC_CTRL_ENABLE;
spi-au1550.c:699:		stat = hw->regs->psc_spistat;
spi-au1550.c:704:	cfg = hw->usedma ? 0 : PSC_SPICFG_DD_DISABLE;
spi-au1550.c:714:	hw->regs->psc_spicfg = cfg;
spi-au1550.c:719:	hw->regs->psc_spicfg |= PSC_SPICFG_DE_ENABLE;
spi-au1550.c:723:		stat = hw->regs->psc_spistat;
spi-au1550.c:738:	master = spi_alloc_master(&pdev->dev, sizeof(struct au1550_spi));
spi-au1550.c:740:		dev_err(&pdev->dev, "No memory for spi_master\n");
spi-au1550.c:741:		err = -ENOMEM;
spi-au1550.c:745:	/* the spi->mode bits understood by this driver: */
spi-au1550.c:746:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;
spi-au1550.c:747:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 24);
spi-au1550.c:751:	hw->master = master;
spi-au1550.c:752:	hw->pdata = dev_get_platdata(&pdev->dev);
spi-au1550.c:753:	hw->dev = &pdev->dev;
spi-au1550.c:755:	if (hw->pdata == NULL) {
spi-au1550.c:756:		dev_err(&pdev->dev, "No platform data supplied\n");
spi-au1550.c:757:		err = -ENOENT;
spi-au1550.c:763:		dev_err(&pdev->dev, "no IRQ\n");
spi-au1550.c:764:		err = -ENODEV;
spi-au1550.c:767:	hw->irq = r->start;
spi-au1550.c:769:	hw->usedma = 0;
spi-au1550.c:772:		hw->dma_tx_id = r->start;
spi-au1550.c:775:			hw->dma_rx_id = r->start;
spi-au1550.c:777:				if (pdev->dev.dma_mask == NULL)
spi-au1550.c:778:					dev_warn(&pdev->dev, "no dma mask\n");
spi-au1550.c:780:					hw->usedma = 1;
spi-au1550.c:787:		dev_err(&pdev->dev, "no mmio resource\n");
spi-au1550.c:788:		err = -ENODEV;
spi-au1550.c:792:	hw->ioarea = request_mem_region(r->start, sizeof(psc_spi_t),
spi-au1550.c:793:					pdev->name);
spi-au1550.c:794:	if (!hw->ioarea) {
spi-au1550.c:795:		dev_err(&pdev->dev, "Cannot reserve iomem region\n");
spi-au1550.c:796:		err = -ENXIO;
spi-au1550.c:800:	hw->regs = (psc_spi_t __iomem *)ioremap(r->start, sizeof(psc_spi_t));
spi-au1550.c:801:	if (!hw->regs) {
spi-au1550.c:802:		dev_err(&pdev->dev, "cannot ioremap\n");
spi-au1550.c:803:		err = -ENXIO;
spi-au1550.c:809:	init_completion(&hw->master_done);
spi-au1550.c:811:	hw->bitbang.master = hw->master;
spi-au1550.c:812:	hw->bitbang.setup_transfer = au1550_spi_setupxfer;
spi-au1550.c:813:	hw->bitbang.chipselect = au1550_spi_chipsel;
spi-au1550.c:814:	hw->bitbang.txrx_bufs = au1550_spi_txrx_bufs;
spi-au1550.c:816:	if (hw->usedma) {
spi-au1550.c:817:		hw->dma_tx_ch = au1xxx_dbdma_chan_alloc(ddma_memid,
spi-au1550.c:818:			hw->dma_tx_id, NULL, (void *)hw);
spi-au1550.c:819:		if (hw->dma_tx_ch == 0) {
spi-au1550.c:820:			dev_err(&pdev->dev,
spi-au1550.c:822:			err = -ENXIO;
spi-au1550.c:825:		au1xxx_dbdma_set_devwidth(hw->dma_tx_ch, 8);
spi-au1550.c:826:		if (au1xxx_dbdma_ring_alloc(hw->dma_tx_ch,
spi-au1550.c:828:			dev_err(&pdev->dev,
spi-au1550.c:830:			err = -ENXIO;
spi-au1550.c:835:		hw->dma_rx_ch = au1xxx_dbdma_chan_alloc(hw->dma_rx_id,
spi-au1550.c:837:		if (hw->dma_rx_ch == 0) {
spi-au1550.c:838:			dev_err(&pdev->dev,
spi-au1550.c:840:			err = -ENXIO;
spi-au1550.c:843:		au1xxx_dbdma_set_devwidth(hw->dma_rx_ch, 8);
spi-au1550.c:844:		if (au1xxx_dbdma_ring_alloc(hw->dma_rx_ch,
spi-au1550.c:846:			dev_err(&pdev->dev,
spi-au1550.c:848:			err = -ENXIO;
spi-au1550.c:855:			dev_err(&pdev->dev,
spi-au1550.c:863:	err = request_irq(hw->irq, au1550_spi_irq, 0, pdev->name, hw);
spi-au1550.c:865:		dev_err(&pdev->dev, "Cannot claim IRQ\n");
spi-au1550.c:869:	master->bus_num = pdev->id;
spi-au1550.c:870:	master->num_chipselect = hw->pdata->num_chipselect;
spi-au1550.c:873:	 *  precompute valid range for spi freq - from au1550 datasheet:
spi-au1550.c:884:		master->max_speed_hz = hw->pdata->mainclk_hz / min_div;
spi-au1550.c:885:		master->min_speed_hz =
spi-au1550.c:886:				hw->pdata->mainclk_hz / (max_div + 1) + 1;
spi-au1550.c:891:	err = spi_bitbang_start(&hw->bitbang);
spi-au1550.c:893:		dev_err(&pdev->dev, "Failed to register SPI master\n");
spi-au1550.c:897:	dev_info(&pdev->dev,
spi-au1550.c:899:		master->bus_num, master->num_chipselect);
spi-au1550.c:904:	free_irq(hw->irq, hw);
spi-au1550.c:911:	if (hw->usedma)
spi-au1550.c:912:		au1xxx_dbdma_chan_free(hw->dma_rx_ch);
spi-au1550.c:916:	if (hw->usedma)
spi-au1550.c:917:		au1xxx_dbdma_chan_free(hw->dma_tx_ch);
spi-au1550.c:920:	iounmap((void __iomem *)hw->regs);
spi-au1550.c:923:	release_mem_region(r->start, sizeof(psc_spi_t));
spi-au1550.c:927:	spi_master_put(hw->master);
spi-au1550.c:937:	dev_info(&pdev->dev, "spi master remove: bus_num=%d\n",
spi-au1550.c:938:		hw->master->bus_num);
spi-au1550.c:940:	spi_bitbang_stop(&hw->bitbang);
spi-au1550.c:941:	free_irq(hw->irq, hw);
spi-au1550.c:942:	iounmap((void __iomem *)hw->regs);
spi-au1550.c:943:	release_mem_region(hw->ioarea->start, sizeof(psc_spi_t));
spi-au1550.c:945:	if (hw->usedma) {
spi-au1550.c:947:		au1xxx_dbdma_chan_free(hw->dma_rx_ch);
spi-au1550.c:948:		au1xxx_dbdma_chan_free(hw->dma_tx_ch);
spi-au1550.c:951:	spi_master_put(hw->master);
spi-au1550.c:956:MODULE_ALIAS("platform:au1550-spi");
spi-au1550.c:962:		.name = "au1550-spi",
spi-au1550.c:978:		return -ENODEV;
spi-au1550.c:984:			printk(KERN_ERR "au1550-spi: cannot add memory"
Kconfig:5:# nobody's needed a slave side API yet.  The master-role API is not
Kconfig:16:	  dynamic device discovery; some are even write-only or read-only.
Kconfig:20:	  chips, analog to digital (and d-to-a) converters, and more.
Kconfig:47:	  If your system has an master-capable SPI controller (which
Kconfig:156:	  this code to manage the per-word or per-transfer accesses to the
Kconfig:183:	  This enables dedicated general purpose SPI/Microwire1-compatible
Kconfig:184:	  master mode interface (SSI1) for CLPS711X-based CPUs.
Kconfig:194:	tristate "Texas Instruments DaVinci/DA8x/OMAP-L/AM1x SoC SPI controller"
Kconfig:198:	  SPI master controller for DaVinci/DA8x/OMAP-L/AM1x SPI modules.
Kconfig:201:       tristate "Diolan DLN-2 USB SPI adapter"
Kconfig:208:         will be called spi-dln2.
Kconfig:229:	  The external bus unit (EBU) found on the FALC-ON SoC has SPI
Kconfig:235:	tristate "GPIO-based bitbanging SPI Master"
Kconfig:239:	  This simple GPIO bitbanging SPI master uses the arch-neutral GPIO
Kconfig:275:	tristate "Freescale MPC52xx SPI (non-PSC) controller support"
Kconfig:464:	  for serial peripheral interface (SPI) mini-core. SPI in master
Kconfig:479:	bool "S3C24XX driver with FIQ pseudo-DMA"
Kconfig:484:	  DMA by using the fast-interrupt request framework, This allows
Kconfig:485:	  the driver to get DMA-like performance when there are either
Kconfig:535:	tristate "STMicroelectronics SPI SSC-based driver"
Kconfig:603:	tristate "Analog Devices AD-FMCOMMS1-EBZ SPI-I2C-bridge driver"
Kconfig:606:	  Support for the SPI-I2C bridge found on the Analog Devices
Kconfig:607:	  AD-FMCOMMS1-EBZ board.
Kconfig:682:	tristate "Memory-mapped io interface driver for DW SPI core"
spi-fsl-dspi.c:2: * drivers/spi/spi-fsl-dspi.c
spi-fsl-dspi.c:36:#define DRIVER_NAME "fsl-dspi"
spi-fsl-dspi.c:100:#define SPI_FRAME_BITS(bits)	SPI_CTAR_FMSZ((bits) - 1)
spi-fsl-dspi.c:170:	regmap_read(dspi->regmap, SPI_CTAR(0), &val);
spi-fsl-dspi.c:178:	/* Valid baud rate pre-scaler values */
spi-fsl-dspi.c:207:		*pbr = ARRAY_SIZE(pbr_tbl) - 1;
spi-fsl-dspi.c:208:		*br =  ARRAY_SIZE(brs) - 1;
spi-fsl-dspi.c:241:		*psc = ARRAY_SIZE(pscale_tbl) - 1;
spi-fsl-dspi.c:250:	if (!(dspi->dataflags & TRAN_STATE_TX_VOID))
spi-fsl-dspi.c:251:		d16 = tx_word ? *(u16 *)dspi->tx : *(u8 *)dspi->tx;
spi-fsl-dspi.c:253:		d16 = dspi->void_write_data;
spi-fsl-dspi.c:255:	dspi->tx += tx_word + 1;
spi-fsl-dspi.c:256:	dspi->len -= tx_word + 1;
spi-fsl-dspi.c:259:		SPI_PUSHR_PCS(dspi->cs) |
spi-fsl-dspi.c:269:	regmap_read(dspi->regmap, SPI_POPR, &val);
spi-fsl-dspi.c:272:	if (!(dspi->dataflags & TRAN_STATE_RX_VOID))
spi-fsl-dspi.c:273:		rx_word ? (*(u16 *)dspi->rx = d) : (*(u8 *)dspi->rx = d);
spi-fsl-dspi.c:275:	dspi->rx += rx_word + 1;
spi-fsl-dspi.c:286:	while (dspi->len && (tx_count < DSPI_FIFO_SIZE)) {
spi-fsl-dspi.c:291:		if (tx_word && (dspi->len == 1)) {
spi-fsl-dspi.c:292:			dspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;
spi-fsl-dspi.c:293:			regmap_update_bits(dspi->regmap, SPI_CTAR(0),
spi-fsl-dspi.c:300:		if (dspi->len == 0 || tx_count == DSPI_FIFO_SIZE - 1) {
spi-fsl-dspi.c:303:			if ((dspi->cs_change) && (!dspi->len))
spi-fsl-dspi.c:305:		} else if (tx_word && (dspi->len == 1))
spi-fsl-dspi.c:308:		regmap_write(dspi->regmap, SPI_PUSHR, dspi_pushr);
spi-fsl-dspi.c:321:	while ((dspi->rx < dspi->rx_end)
spi-fsl-dspi.c:323:		if (rx_word && (dspi->rx_end - dspi->rx) == 1)
spi-fsl-dspi.c:340:	if (tx_word && (dspi->len == 1)) {
spi-fsl-dspi.c:341:		dspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;
spi-fsl-dspi.c:342:		regmap_update_bits(dspi->regmap, SPI_CTAR(0),
spi-fsl-dspi.c:349:	if ((dspi->cs_change) && (!dspi->len))
spi-fsl-dspi.c:352:	regmap_write(dspi->regmap, SPI_PUSHR, dspi_pushr);
spi-fsl-dspi.c:361:	if (rx_word && (dspi->rx_end - dspi->rx) == 1)
spi-fsl-dspi.c:371:	struct spi_device *spi = message->spi;
spi-fsl-dspi.c:377:	regmap_read(dspi->regmap, SPI_TCR, &spi_tcr);
spi-fsl-dspi.c:378:	dspi->spi_tcnt = SPI_TCR_GET_TCNT(spi_tcr);
spi-fsl-dspi.c:380:	message->actual_length = 0;
spi-fsl-dspi.c:382:	list_for_each_entry(transfer, &message->transfers, transfer_list) {
spi-fsl-dspi.c:383:		dspi->cur_transfer = transfer;
spi-fsl-dspi.c:384:		dspi->cur_msg = message;
spi-fsl-dspi.c:385:		dspi->cur_chip = spi_get_ctldata(spi);
spi-fsl-dspi.c:386:		dspi->cs = spi->chip_select;
spi-fsl-dspi.c:387:		dspi->cs_change = 0;
spi-fsl-dspi.c:388:		if (dspi->cur_transfer->transfer_list.next
spi-fsl-dspi.c:389:				== &dspi->cur_msg->transfers)
spi-fsl-dspi.c:390:			dspi->cs_change = 1;
spi-fsl-dspi.c:391:		dspi->void_write_data = dspi->cur_chip->void_write_data;
spi-fsl-dspi.c:393:		dspi->dataflags = 0;
spi-fsl-dspi.c:394:		dspi->tx = (void *)transfer->tx_buf;
spi-fsl-dspi.c:395:		dspi->tx_end = dspi->tx + transfer->len;
spi-fsl-dspi.c:396:		dspi->rx = transfer->rx_buf;
spi-fsl-dspi.c:397:		dspi->rx_end = dspi->rx + transfer->len;
spi-fsl-dspi.c:398:		dspi->len = transfer->len;
spi-fsl-dspi.c:400:		if (!dspi->rx)
spi-fsl-dspi.c:401:			dspi->dataflags |= TRAN_STATE_RX_VOID;
spi-fsl-dspi.c:403:		if (!dspi->tx)
spi-fsl-dspi.c:404:			dspi->dataflags |= TRAN_STATE_TX_VOID;
spi-fsl-dspi.c:406:		regmap_write(dspi->regmap, SPI_MCR, dspi->cur_chip->mcr_val);
spi-fsl-dspi.c:407:		regmap_update_bits(dspi->regmap, SPI_MCR,
spi-fsl-dspi.c:410:		regmap_write(dspi->regmap, SPI_CTAR(0),
spi-fsl-dspi.c:411:				dspi->cur_chip->ctar_val);
spi-fsl-dspi.c:413:		trans_mode = dspi->devtype_data->trans_mode;
spi-fsl-dspi.c:416:			regmap_write(dspi->regmap, SPI_RSER, SPI_RSER_EOQFE);
spi-fsl-dspi.c:420:			regmap_write(dspi->regmap, SPI_RSER, SPI_RSER_TCFQE);
spi-fsl-dspi.c:424:			dev_err(&dspi->pdev->dev, "unsupported trans_mode %u\n",
spi-fsl-dspi.c:426:			status = -EINVAL;
spi-fsl-dspi.c:430:		if (wait_event_interruptible(dspi->waitq, dspi->waitflags))
spi-fsl-dspi.c:431:			dev_err(&dspi->pdev->dev, "wait transfer complete fail!\n");
spi-fsl-dspi.c:432:		dspi->waitflags = 0;
spi-fsl-dspi.c:434:		if (transfer->delay_usecs)
spi-fsl-dspi.c:435:			udelay(transfer->delay_usecs);
spi-fsl-dspi.c:439:	message->status = status;
spi-fsl-dspi.c:448:	struct fsl_dspi *dspi = spi_master_get_devdata(spi->master);
spi-fsl-dspi.c:454:	if ((spi->bits_per_word >= 4) && (spi->bits_per_word <= 16)) {
spi-fsl-dspi.c:455:		fmsz = spi->bits_per_word - 1;
spi-fsl-dspi.c:458:		return -ENODEV;
spi-fsl-dspi.c:466:			return -ENOMEM;
spi-fsl-dspi.c:469:	of_property_read_u32(spi->dev.of_node, "fsl,spi-cs-sck-delay",
spi-fsl-dspi.c:472:	of_property_read_u32(spi->dev.of_node, "fsl,spi-sck-cs-delay",
spi-fsl-dspi.c:475:	chip->mcr_val = SPI_MCR_MASTER | SPI_MCR_PCSIS |
spi-fsl-dspi.c:478:	chip->void_write_data = 0;
spi-fsl-dspi.c:480:	clkrate = clk_get_rate(dspi->clk);
spi-fsl-dspi.c:481:	hz_to_spi_baud(&pbr, &br, spi->max_speed_hz, clkrate);
spi-fsl-dspi.c:489:	chip->ctar_val =  SPI_CTAR_FMSZ(fmsz)
spi-fsl-dspi.c:490:		| SPI_CTAR_CPOL(spi->mode & SPI_CPOL ? 1 : 0)
spi-fsl-dspi.c:491:		| SPI_CTAR_CPHA(spi->mode & SPI_CPHA ? 1 : 0)
spi-fsl-dspi.c:492:		| SPI_CTAR_LSBFE(spi->mode & SPI_LSB_FIRST ? 1 : 0)
spi-fsl-dspi.c:509:	dev_dbg(&spi->dev, "spi_device %u.%u cleanup\n",
spi-fsl-dspi.c:510:			spi->master->bus_num, spi->chip_select);
spi-fsl-dspi.c:518:	struct spi_message *msg = dspi->cur_msg;
spi-fsl-dspi.c:524:	regmap_read(dspi->regmap, SPI_SR, &spi_sr);
spi-fsl-dspi.c:525:	regmap_write(dspi->regmap, SPI_SR, spi_sr);
spi-fsl-dspi.c:531:		regmap_read(dspi->regmap, SPI_TCR, &spi_tcr);
spi-fsl-dspi.c:537:		 * spi_tcnt my be less than dspi->spi_tcnt, it means the
spi-fsl-dspi.c:542:		tcnt_diff = ((spi_tcnt + SPI_TCR_TCNT_MAX) - dspi->spi_tcnt)
spi-fsl-dspi.c:545:		if (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM)
spi-fsl-dspi.c:546:			tcnt_diff--;
spi-fsl-dspi.c:548:		msg->actual_length += tcnt_diff;
spi-fsl-dspi.c:550:		dspi->spi_tcnt = spi_tcnt;
spi-fsl-dspi.c:552:		trans_mode = dspi->devtype_data->trans_mode;
spi-fsl-dspi.c:561:			dev_err(&dspi->pdev->dev, "unsupported trans_mode %u\n",
spi-fsl-dspi.c:566:		if (!dspi->len) {
spi-fsl-dspi.c:567:			if (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM) {
spi-fsl-dspi.c:568:				regmap_update_bits(dspi->regmap,
spi-fsl-dspi.c:572:				dspi->dataflags &= ~TRAN_STATE_WORD_ODD_NUM;
spi-fsl-dspi.c:575:			dspi->waitflags = 1;
spi-fsl-dspi.c:576:			wake_up_interruptible(&dspi->waitq);
spi-fsl-dspi.c:586:				dev_err(&dspi->pdev->dev,
spi-fsl-dspi.c:597:	{ .compatible = "fsl,vf610-dspi", .data = (void *)&vf610_data, },
spi-fsl-dspi.c:598:	{ .compatible = "fsl,ls1021a-v1.0-dspi",
spi-fsl-dspi.c:600:	{ .compatible = "fsl,ls2085a-dspi", .data = (void *)&ls2085a_data, },
spi-fsl-dspi.c:612:	clk_disable_unprepare(dspi->clk);
spi-fsl-dspi.c:626:	clk_prepare_enable(dspi->clk);
spi-fsl-dspi.c:644:	struct device_node *np = pdev->dev.of_node;
spi-fsl-dspi.c:651:			of_match_device(fsl_dspi_dt_ids, &pdev->dev);
spi-fsl-dspi.c:653:	master = spi_alloc_master(&pdev->dev, sizeof(struct fsl_dspi));
spi-fsl-dspi.c:655:		return -ENOMEM;
spi-fsl-dspi.c:658:	dspi->pdev = pdev;
spi-fsl-dspi.c:659:	dspi->master = master;
spi-fsl-dspi.c:661:	master->transfer = NULL;
spi-fsl-dspi.c:662:	master->setup = dspi_setup;
spi-fsl-dspi.c:663:	master->transfer_one_message = dspi_transfer_one_message;
spi-fsl-dspi.c:664:	master->dev.of_node = pdev->dev.of_node;
spi-fsl-dspi.c:666:	master->cleanup = dspi_cleanup;
spi-fsl-dspi.c:667:	master->mode_bits = SPI_CPOL | SPI_CPHA;
spi-fsl-dspi.c:668:	master->bits_per_word_mask = SPI_BPW_MASK(4) | SPI_BPW_MASK(8) |
spi-fsl-dspi.c:671:	ret = of_property_read_u32(np, "spi-num-chipselects", &cs_num);
spi-fsl-dspi.c:673:		dev_err(&pdev->dev, "can't get spi-num-chipselects\n");
spi-fsl-dspi.c:676:	master->num_chipselect = cs_num;
spi-fsl-dspi.c:678:	ret = of_property_read_u32(np, "bus-num", &bus_num);
spi-fsl-dspi.c:680:		dev_err(&pdev->dev, "can't get bus-num\n");
spi-fsl-dspi.c:683:	master->bus_num = bus_num;
spi-fsl-dspi.c:685:	dspi->devtype_data = (struct fsl_dspi_devtype_data *)of_id->data;
spi-fsl-dspi.c:686:	if (!dspi->devtype_data) {
spi-fsl-dspi.c:687:		dev_err(&pdev->dev, "can't get devtype_data\n");
spi-fsl-dspi.c:688:		ret = -EFAULT;
spi-fsl-dspi.c:693:	base = devm_ioremap_resource(&pdev->dev, res);
spi-fsl-dspi.c:699:	dspi->regmap = devm_regmap_init_mmio_clk(&pdev->dev, NULL, base,
spi-fsl-dspi.c:701:	if (IS_ERR(dspi->regmap)) {
spi-fsl-dspi.c:702:		dev_err(&pdev->dev, "failed to init regmap: %ld\n",
spi-fsl-dspi.c:703:				PTR_ERR(dspi->regmap));
spi-fsl-dspi.c:704:		return PTR_ERR(dspi->regmap);
spi-fsl-dspi.c:707:	dspi->irq = platform_get_irq(pdev, 0);
spi-fsl-dspi.c:708:	if (dspi->irq < 0) {
spi-fsl-dspi.c:709:		dev_err(&pdev->dev, "can't get platform irq\n");
spi-fsl-dspi.c:710:		ret = dspi->irq;
spi-fsl-dspi.c:714:	ret = devm_request_irq(&pdev->dev, dspi->irq, dspi_interrupt, 0,
spi-fsl-dspi.c:715:			pdev->name, dspi);
spi-fsl-dspi.c:717:		dev_err(&pdev->dev, "Unable to attach DSPI interrupt\n");
spi-fsl-dspi.c:721:	dspi->clk = devm_clk_get(&pdev->dev, "dspi");
spi-fsl-dspi.c:722:	if (IS_ERR(dspi->clk)) {
spi-fsl-dspi.c:723:		ret = PTR_ERR(dspi->clk);
spi-fsl-dspi.c:724:		dev_err(&pdev->dev, "unable to get clock\n");
spi-fsl-dspi.c:727:	clk_prepare_enable(dspi->clk);
spi-fsl-dspi.c:729:	init_waitqueue_head(&dspi->waitq);
spi-fsl-dspi.c:734:		dev_err(&pdev->dev, "Problem registering DSPI master\n");
spi-fsl-dspi.c:741:	clk_disable_unprepare(dspi->clk);
spi-fsl-dspi.c:754:	clk_disable_unprepare(dspi->clk);
spi-fsl-dspi.c:755:	spi_unregister_master(dspi->master);
spi-atmel.c:16:#include <linux/dma-mapping.h>
spi-atmel.c:22:#include <linux/platform_data/dma-atmel.h>
spi-atmel.c:219:	(((value) & ((1 << SPI_##name##_SIZE) - 1)) << SPI_##name##_OFFSET)
spi-atmel.c:221:	(((value) >> SPI_##name##_OFFSET) & ((1 << SPI_##name##_SIZE) - 1))
spi-atmel.c:223:	(((old) & ~(((1 << SPI_##name##_SIZE) - 1) << SPI_##name##_OFFSET)) \
spi-atmel.c:229:	__raw_readl((port)->regs + SPI_##reg)
spi-atmel.c:231:	__raw_writel((value), (port)->regs + SPI_##reg)
spi-atmel.c:234:	__raw_readw((port)->regs + SPI_##reg)
spi-atmel.c:236:	__raw_writew((value), (port)->regs + SPI_##reg)
spi-atmel.c:239:	__raw_readb((port)->regs + SPI_##reg)
spi-atmel.c:241:	__raw_writeb((value), (port)->regs + SPI_##reg)
spi-atmel.c:244:	readl_relaxed((port)->regs + SPI_##reg)
spi-atmel.c:246:	writel_relaxed((value), (port)->regs + SPI_##reg)
spi-atmel.c:249:	readw_relaxed((port)->regs + SPI_##reg)
spi-atmel.c:251:	writew_relaxed((value), (port)->regs + SPI_##reg)
spi-atmel.c:254:	readb_relaxed((port)->regs + SPI_##reg)
spi-atmel.c:256:	writeb_relaxed((value), (port)->regs + SPI_##reg)
spi-atmel.c:323:/* Controller-specific per-slave state */
spi-atmel.c:334: *  - CR.LASTXFER
spi-atmel.c:335: *  - SPI_MR.DIV32 may become FDIV or must-be-zero (here: always zero)
spi-atmel.c:336: *  - SPI_SR.TXEMPTY, SPI_SR.NSSR (and corresponding irqs)
spi-atmel.c:337: *  - SPI_CSRx.CSAAT
spi-atmel.c:338: *  - SPI_CSRx.SBCR allows faster clocking
spi-atmel.c:342:	return as->caps.is_spi2;
spi-atmel.c:355: * support active-high chipselects despite the controller's belief that
spi-atmel.c:356: * only active-low devices/systems exists.
spi-atmel.c:367:	struct atmel_spi_device *asd = spi->controller_state;
spi-atmel.c:368:	unsigned active = spi->mode & SPI_CS_HIGH;
spi-atmel.c:372:		spi_writel(as, CSR0 + 4 * spi->chip_select, asd->csr);
spi-atmel.c:376:		spi_writel(as, CSR0, asd->csr);
spi-atmel.c:377:		if (as->caps.has_wdrbt) {
spi-atmel.c:379:					SPI_BF(PCS, ~(0x01 << spi->chip_select))
spi-atmel.c:385:					SPI_BF(PCS, ~(0x01 << spi->chip_select))
spi-atmel.c:391:		if (as->use_cs_gpios)
spi-atmel.c:392:			gpio_set_value(asd->npcs_pin, active);
spi-atmel.c:394:		u32 cpol = (spi->mode & SPI_CPOL) ? SPI_BIT(CPOL) : 0;
spi-atmel.c:399:		for (i = 0; i < spi->master->num_chipselect; i++) {
spi-atmel.c:407:		mr = SPI_BFINS(PCS, ~(1 << spi->chip_select), mr);
spi-atmel.c:408:		if (as->use_cs_gpios && spi->chip_select != 0)
spi-atmel.c:409:			gpio_set_value(asd->npcs_pin, active);
spi-atmel.c:413:	dev_dbg(&spi->dev, "activate %u%s, mr %08x\n",
spi-atmel.c:414:			asd->npcs_pin, active ? " (high)" : "",
spi-atmel.c:420:	struct atmel_spi_device *asd = spi->controller_state;
spi-atmel.c:421:	unsigned active = spi->mode & SPI_CS_HIGH;
spi-atmel.c:428:	if (~SPI_BFEXT(PCS, mr) & (1 << spi->chip_select)) {
spi-atmel.c:433:	dev_dbg(&spi->dev, "DEactivate %u%s, mr %08x\n",
spi-atmel.c:434:			asd->npcs_pin, active ? " (low)" : "",
spi-atmel.c:437:	if (!as->use_cs_gpios)
spi-atmel.c:439:	else if (atmel_spi_is_v2(as) || spi->chip_select != 0)
spi-atmel.c:440:		gpio_set_value(asd->npcs_pin, !active);
spi-atmel.c:443:static void atmel_spi_lock(struct atmel_spi *as) __acquires(&as->lock)
spi-atmel.c:445:	spin_lock_irqsave(&as->lock, as->flags);
spi-atmel.c:448:static void atmel_spi_unlock(struct atmel_spi *as) __releases(&as->lock)
spi-atmel.c:450:	spin_unlock_irqrestore(&as->lock, as->flags);
spi-atmel.c:456:	return as->use_dma && xfer->len >= DMA_MIN_BYTES;
spi-atmel.c:466:		slave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
spi-atmel.c:467:		slave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
spi-atmel.c:469:		slave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
spi-atmel.c:470:		slave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
spi-atmel.c:473:	slave_config->dst_addr = (dma_addr_t)as->phybase + SPI_TDR;
spi-atmel.c:474:	slave_config->src_addr = (dma_addr_t)as->phybase + SPI_RDR;
spi-atmel.c:475:	slave_config->src_maxburst = 1;
spi-atmel.c:476:	slave_config->dst_maxburst = 1;
spi-atmel.c:477:	slave_config->device_fc = false;
spi-atmel.c:493:	slave_config->direction = DMA_MEM_TO_DEV;
spi-atmel.c:494:	if (dmaengine_slave_config(as->dma.chan_tx, slave_config)) {
spi-atmel.c:495:		dev_err(&as->pdev->dev,
spi-atmel.c:497:		err = -EINVAL;
spi-atmel.c:508:	slave_config->direction = DMA_DEV_TO_MEM;
spi-atmel.c:509:	if (dmaengine_slave_config(as->dma.chan_rx, slave_config)) {
spi-atmel.c:510:		dev_err(&as->pdev->dev,
spi-atmel.c:512:		err = -EINVAL;
spi-atmel.c:521:	struct device *dev = &as->pdev->dev;
spi-atmel.c:528:	as->dma.chan_tx = dma_request_slave_channel_reason(dev, "tx");
spi-atmel.c:529:	if (IS_ERR(as->dma.chan_tx)) {
spi-atmel.c:530:		err = PTR_ERR(as->dma.chan_tx);
spi-atmel.c:531:		if (err == -EPROBE_DEFER) {
spi-atmel.c:537:		err = -EBUSY;
spi-atmel.c:545:	as->dma.chan_rx = dma_request_slave_channel(dev, "rx");
spi-atmel.c:547:	if (!as->dma.chan_rx) {
spi-atmel.c:550:		err = -EBUSY;
spi-atmel.c:558:	dev_info(&as->pdev->dev,
spi-atmel.c:560:			dma_chan_name(as->dma.chan_tx),
spi-atmel.c:561:			dma_chan_name(as->dma.chan_rx));
spi-atmel.c:564:	if (as->dma.chan_rx)
spi-atmel.c:565:		dma_release_channel(as->dma.chan_rx);
spi-atmel.c:566:	if (!IS_ERR(as->dma.chan_tx))
spi-atmel.c:567:		dma_release_channel(as->dma.chan_tx);
spi-atmel.c:573:	if (as->dma.chan_rx)
spi-atmel.c:574:		dmaengine_terminate_all(as->dma.chan_rx);
spi-atmel.c:575:	if (as->dma.chan_tx)
spi-atmel.c:576:		dmaengine_terminate_all(as->dma.chan_tx);
spi-atmel.c:581:	if (as->dma.chan_rx)
spi-atmel.c:582:		dma_release_channel(as->dma.chan_rx);
spi-atmel.c:583:	if (as->dma.chan_tx)
spi-atmel.c:584:		dma_release_channel(as->dma.chan_tx);
spi-atmel.c:593:	complete(&as->xfer_completion);
spi-atmel.c:603:	unsigned long xfer_pos = xfer->len - as->current_remaining_bytes;
spi-atmel.c:605:	dev_vdbg(master->dev.parent, "atmel_spi_next_xfer_pio\n");
spi-atmel.c:614:	if (xfer->tx_buf) {
spi-atmel.c:615:		if (xfer->bits_per_word > 8)
spi-atmel.c:616:			spi_writel(as, TDR, *(u16 *)(xfer->tx_buf + xfer_pos));
spi-atmel.c:618:			spi_writel(as, TDR, *(u8 *)(xfer->tx_buf + xfer_pos));
spi-atmel.c:623:	dev_dbg(master->dev.parent,
spi-atmel.c:625:		xfer, xfer->len, xfer->tx_buf, xfer->rx_buf,
spi-atmel.c:626:		xfer->bits_per_word);
spi-atmel.c:640:	u32 offset = xfer->len - as->current_remaining_bytes;
spi-atmel.c:641:	const u16 *words = (const u16 *)((u8 *)xfer->tx_buf + offset);
spi-atmel.c:642:	const u8  *bytes = (const u8  *)((u8 *)xfer->tx_buf + offset);
spi-atmel.c:646:	dev_vdbg(master->dev.parent, "atmel_spi_next_xfer_fifo\n");
spi-atmel.c:649:	current_remaining_data = ((xfer->bits_per_word > 8) ?
spi-atmel.c:650:				  ((u32)as->current_remaining_bytes >> 1) :
spi-atmel.c:651:				  (u32)as->current_remaining_bytes);
spi-atmel.c:652:	num_data = min(current_remaining_data, as->fifo_size);
spi-atmel.c:668:		if (xfer->tx_buf) {
spi-atmel.c:669:			if (xfer->bits_per_word > 8) {
spi-atmel.c:682:		num_data -= 2;
spi-atmel.c:686:		if (xfer->tx_buf) {
spi-atmel.c:687:			if (xfer->bits_per_word > 8)
spi-atmel.c:696:		num_data--;
spi-atmel.c:699:	dev_dbg(master->dev.parent,
spi-atmel.c:701:		xfer, xfer->len, xfer->tx_buf, xfer->rx_buf,
spi-atmel.c:702:		xfer->bits_per_word);
spi-atmel.c:719:	if (as->fifo_size)
spi-atmel.c:733:	struct dma_chan		*rxchan = as->dma.chan_rx;
spi-atmel.c:734:	struct dma_chan		*txchan = as->dma.chan_tx;
spi-atmel.c:741:	dev_vdbg(master->dev.parent, "atmel_spi_next_xfer_dma_submit\n");
spi-atmel.c:745:		return -ENODEV;
spi-atmel.c:751:	sg_init_table(&as->dma.sgrx, 1);
spi-atmel.c:752:	if (xfer->rx_buf) {
spi-atmel.c:753:		as->dma.sgrx.dma_address = xfer->rx_dma + xfer->len - *plen;
spi-atmel.c:755:		as->dma.sgrx.dma_address = as->buffer_dma;
spi-atmel.c:761:	sg_init_table(&as->dma.sgtx, 1);
spi-atmel.c:762:	if (xfer->tx_buf) {
spi-atmel.c:763:		as->dma.sgtx.dma_address = xfer->tx_dma + xfer->len - *plen;
spi-atmel.c:765:		as->dma.sgtx.dma_address = as->buffer_dma;
spi-atmel.c:768:		memset(as->buffer, 0, len);
spi-atmel.c:771:	sg_dma_len(&as->dma.sgtx) = len;
spi-atmel.c:772:	sg_dma_len(&as->dma.sgrx) = len;
spi-atmel.c:777:				       xfer->bits_per_word))
spi-atmel.c:781:	rxdesc = dmaengine_prep_slave_sg(rxchan, &as->dma.sgrx, 1,
spi-atmel.c:787:	txdesc = dmaengine_prep_slave_sg(txchan, &as->dma.sgtx, 1,
spi-atmel.c:793:	dev_dbg(master->dev.parent,
spi-atmel.c:795:		xfer, xfer->len, xfer->tx_buf, (unsigned long long)xfer->tx_dma,
spi-atmel.c:796:		xfer->rx_buf, (unsigned long long)xfer->rx_dma);
spi-atmel.c:802:	rxdesc->callback = dma_callback;
spi-atmel.c:803:	rxdesc->callback_param = master;
spi-atmel.c:806:	cookie = rxdesc->tx_submit(rxdesc);
spi-atmel.c:809:	cookie = txdesc->tx_submit(txdesc);
spi-atmel.c:812:	rxchan->device->device_issue_pending(rxchan);
spi-atmel.c:813:	txchan->device->device_issue_pending(txchan);
spi-atmel.c:824:	return -ENOMEM;
spi-atmel.c:837:	if (xfer->rx_buf)
spi-atmel.c:838:		*rx_dma = xfer->rx_dma + xfer->len - *plen;
spi-atmel.c:840:		*rx_dma = as->buffer_dma;
spi-atmel.c:845:	if (xfer->tx_buf)
spi-atmel.c:846:		*tx_dma = xfer->tx_dma + xfer->len - *plen;
spi-atmel.c:848:		*tx_dma = as->buffer_dma;
spi-atmel.c:851:		memset(as->buffer, 0, len);
spi-atmel.c:852:		dma_sync_single_for_device(&as->pdev->dev,
spi-atmel.c:853:				as->buffer_dma, len, DMA_TO_DEVICE);
spi-atmel.c:867:	bus_hz = clk_get_rate(as->clk);
spi-atmel.c:875:	scbr = DIV_ROUND_UP(bus_hz, xfer->speed_hz);
spi-atmel.c:882:		dev_err(&spi->dev,
spi-atmel.c:884:			xfer->speed_hz, scbr, bus_hz/255);
spi-atmel.c:885:		return -EINVAL;
spi-atmel.c:888:		dev_err(&spi->dev,
spi-atmel.c:890:			xfer->speed_hz, scbr, bus_hz);
spi-atmel.c:891:		return -EINVAL;
spi-atmel.c:893:	csr = spi_readl(as, CSR0 + 4 * spi->chip_select);
spi-atmel.c:895:	spi_writel(as, CSR0 + 4 * spi->chip_select, csr);
spi-atmel.c:914:	len = as->current_remaining_bytes;
spi-atmel.c:916:	as->current_remaining_bytes -= len;
spi-atmel.c:921:	if (msg->spi->bits_per_word > 8)
spi-atmel.c:926:	dev_dbg(&msg->spi->dev,
spi-atmel.c:928:		xfer, xfer->len, xfer->tx_buf,
spi-atmel.c:929:		(unsigned long long)xfer->tx_dma, xfer->rx_buf,
spi-atmel.c:930:		(unsigned long long)xfer->rx_dma);
spi-atmel.c:932:	if (as->current_remaining_bytes) {
spi-atmel.c:933:		len = as->current_remaining_bytes;
spi-atmel.c:935:		as->current_remaining_bytes -= len;
spi-atmel.c:940:		if (msg->spi->bits_per_word > 8)
spi-atmel.c:945:		dev_dbg(&msg->spi->dev,
spi-atmel.c:947:			xfer, xfer->len, xfer->tx_buf,
spi-atmel.c:948:			(unsigned long long)xfer->tx_dma, xfer->rx_buf,
spi-atmel.c:949:			(unsigned long long)xfer->rx_dma);
spi-atmel.c:968: *  - The buffer is either valid for CPU access, else NULL
spi-atmel.c:969: *  - If the buffer is valid, so is its DMA address
spi-atmel.c:971: * This driver manages the dma address unless message->is_dma_mapped.
spi-atmel.c:976:	struct device	*dev = &as->pdev->dev;
spi-atmel.c:978:	xfer->tx_dma = xfer->rx_dma = INVALID_DMA_ADDRESS;
spi-atmel.c:979:	if (xfer->tx_buf) {
spi-atmel.c:982:		void *nonconst_tx = (void *)xfer->tx_buf;
spi-atmel.c:984:		xfer->tx_dma = dma_map_single(dev,
spi-atmel.c:985:				nonconst_tx, xfer->len,
spi-atmel.c:987:		if (dma_mapping_error(dev, xfer->tx_dma))
spi-atmel.c:988:			return -ENOMEM;
spi-atmel.c:990:	if (xfer->rx_buf) {
spi-atmel.c:991:		xfer->rx_dma = dma_map_single(dev,
spi-atmel.c:992:				xfer->rx_buf, xfer->len,
spi-atmel.c:994:		if (dma_mapping_error(dev, xfer->rx_dma)) {
spi-atmel.c:995:			if (xfer->tx_buf)
spi-atmel.c:997:						xfer->tx_dma, xfer->len,
spi-atmel.c:999:			return -ENOMEM;
spi-atmel.c:1008:	if (xfer->tx_dma != INVALID_DMA_ADDRESS)
spi-atmel.c:1009:		dma_unmap_single(master->dev.parent, xfer->tx_dma,
spi-atmel.c:1010:				 xfer->len, DMA_TO_DEVICE);
spi-atmel.c:1011:	if (xfer->rx_dma != INVALID_DMA_ADDRESS)
spi-atmel.c:1012:		dma_unmap_single(master->dev.parent, xfer->rx_dma,
spi-atmel.c:1013:				 xfer->len, DMA_FROM_DEVICE);
spi-atmel.c:1026:	unsigned long	xfer_pos = xfer->len - as->current_remaining_bytes;
spi-atmel.c:1028:	if (xfer->rx_buf) {
spi-atmel.c:1029:		if (xfer->bits_per_word > 8) {
spi-atmel.c:1030:			rxp16 = (u16 *)(((u8 *)xfer->rx_buf) + xfer_pos);
spi-atmel.c:1033:			rxp = ((u8 *)xfer->rx_buf) + xfer_pos;
spi-atmel.c:1039:	if (xfer->bits_per_word > 8) {
spi-atmel.c:1040:		if (as->current_remaining_bytes > 2)
spi-atmel.c:1041:			as->current_remaining_bytes -= 2;
spi-atmel.c:1043:			as->current_remaining_bytes = 0;
spi-atmel.c:1045:		as->current_remaining_bytes--;
spi-atmel.c:1054:	u32 offset = xfer->len - as->current_remaining_bytes;
spi-atmel.c:1055:	u16 *words = (u16 *)((u8 *)xfer->rx_buf + offset);
spi-atmel.c:1056:	u8  *bytes = (u8  *)((u8 *)xfer->rx_buf + offset);
spi-atmel.c:1060:	num_bytes = ((xfer->bits_per_word > 8) ?
spi-atmel.c:1064:	if (as->current_remaining_bytes > num_bytes)
spi-atmel.c:1065:		as->current_remaining_bytes -= num_bytes;
spi-atmel.c:1067:		as->current_remaining_bytes = 0;
spi-atmel.c:1070:	if (xfer->bits_per_word > 8)
spi-atmel.c:1071:		as->current_remaining_bytes &= ~0x1;
spi-atmel.c:1076:		if (xfer->rx_buf) {
spi-atmel.c:1077:			if (xfer->bits_per_word > 8)
spi-atmel.c:1082:		num_data--;
spi-atmel.c:1094:	if (as->fifo_size)
spi-atmel.c:1121:		dev_warn(master->dev.parent, "overrun\n");
spi-atmel.c:1126:		 * bounce buffer and msg->actual_len will not be
spi-atmel.c:1132:		as->done_status = -EIO;
spi-atmel.c:1138:		complete(&as->xfer_completion);
spi-atmel.c:1143:		if (as->current_remaining_bytes) {
spi-atmel.c:1145:			xfer = as->current_transfer;
spi-atmel.c:1147:			if (!as->current_remaining_bytes)
spi-atmel.c:1150:			complete(&as->xfer_completion);
spi-atmel.c:1185:		as->done_status = -EIO;
spi-atmel.c:1187:		complete(&as->xfer_completion);
spi-atmel.c:1194:		complete(&as->xfer_completion);
spi-atmel.c:1205:	unsigned int		bits = spi->bits_per_word;
spi-atmel.c:1209:	as = spi_master_get_devdata(spi->master);
spi-atmel.c:1213:			&& spi->chip_select == 0
spi-atmel.c:1214:			&& (spi->mode & SPI_CS_HIGH)) {
spi-atmel.c:1215:		dev_dbg(&spi->dev, "setup: can't be active-high\n");
spi-atmel.c:1216:		return -EINVAL;
spi-atmel.c:1219:	csr = SPI_BF(BITS, bits - 8);
spi-atmel.c:1220:	if (spi->mode & SPI_CPOL)
spi-atmel.c:1222:	if (!(spi->mode & SPI_CPHA))
spi-atmel.c:1224:	if (!as->use_cs_gpios)
spi-atmel.c:1237:	npcs_pin = (unsigned long)spi->controller_data;
spi-atmel.c:1239:	if (!as->use_cs_gpios)
spi-atmel.c:1240:		npcs_pin = spi->chip_select;
spi-atmel.c:1241:	else if (gpio_is_valid(spi->cs_gpio))
spi-atmel.c:1242:		npcs_pin = spi->cs_gpio;
spi-atmel.c:1244:	asd = spi->controller_state;
spi-atmel.c:1248:			return -ENOMEM;
spi-atmel.c:1250:		if (as->use_cs_gpios) {
spi-atmel.c:1251:			ret = gpio_request(npcs_pin, dev_name(&spi->dev));
spi-atmel.c:1258:					      !(spi->mode & SPI_CS_HIGH));
spi-atmel.c:1261:		asd->npcs_pin = npcs_pin;
spi-atmel.c:1262:		spi->controller_state = asd;
spi-atmel.c:1265:	asd->csr = csr;
spi-atmel.c:1267:	dev_dbg(&spi->dev,
spi-atmel.c:1268:		"setup: bpw %u mode 0x%x -> csr%d %08x\n",
spi-atmel.c:1269:		bits, spi->mode, spi->chip_select, csr);
spi-atmel.c:1272:		spi_writel(as, CSR0 + 4 * spi->chip_select, csr);
spi-atmel.c:1282:	struct spi_device	*spi = msg->spi;
spi-atmel.c:1292:	if (!(xfer->tx_buf || xfer->rx_buf) && xfer->len) {
spi-atmel.c:1293:		dev_dbg(&spi->dev, "missing rx or tx buf\n");
spi-atmel.c:1294:		return -EINVAL;
spi-atmel.c:1297:	asd = spi->controller_state;
spi-atmel.c:1298:	bits = (asd->csr >> 4) & 0xf;
spi-atmel.c:1299:	if (bits != xfer->bits_per_word - 8) {
spi-atmel.c:1300:		dev_dbg(&spi->dev,
spi-atmel.c:1302:		return -ENOPROTOOPT;
spi-atmel.c:1309:	if ((!msg->is_dma_mapped)
spi-atmel.c:1310:		&& (atmel_spi_use_dma(as, xfer)	|| as->use_pdc)) {
spi-atmel.c:1312:			return -ENOMEM;
spi-atmel.c:1315:	atmel_spi_set_xfer_speed(as, msg->spi, xfer);
spi-atmel.c:1317:	as->done_status = 0;
spi-atmel.c:1318:	as->current_transfer = xfer;
spi-atmel.c:1319:	as->current_remaining_bytes = xfer->len;
spi-atmel.c:1320:	while (as->current_remaining_bytes) {
spi-atmel.c:1321:		reinit_completion(&as->xfer_completion);
spi-atmel.c:1323:		if (as->use_pdc) {
spi-atmel.c:1326:			len = as->current_remaining_bytes;
spi-atmel.c:1330:				dev_err(&spi->dev,
spi-atmel.c:1334:				as->current_remaining_bytes -= len;
spi-atmel.c:1335:				if (as->current_remaining_bytes < 0)
spi-atmel.c:1336:					as->current_remaining_bytes = 0;
spi-atmel.c:1344:		dma_timeout = wait_for_completion_timeout(&as->xfer_completion,
spi-atmel.c:1348:			dev_err(&spi->dev, "spi transfer timeout\n");
spi-atmel.c:1349:			as->done_status = -EIO;
spi-atmel.c:1352:		if (as->done_status)
spi-atmel.c:1356:	if (as->done_status) {
spi-atmel.c:1357:		if (as->use_pdc) {
spi-atmel.c:1358:			dev_warn(master->dev.parent,
spi-atmel.c:1370:			for (timeout = 1000; timeout; timeout--)
spi-atmel.c:1374:				dev_warn(master->dev.parent,
spi-atmel.c:1386:		if (!msg->is_dma_mapped
spi-atmel.c:1387:			&& (atmel_spi_use_dma(as, xfer) || as->use_pdc))
spi-atmel.c:1394:		msg->actual_length += xfer->len;
spi-atmel.c:1397:	if (!msg->is_dma_mapped
spi-atmel.c:1398:		&& (atmel_spi_use_dma(as, xfer) || as->use_pdc))
spi-atmel.c:1401:	if (xfer->delay_usecs)
spi-atmel.c:1402:		udelay(xfer->delay_usecs);
spi-atmel.c:1404:	if (xfer->cs_change) {
spi-atmel.c:1405:		if (list_is_last(&xfer->transfer_list,
spi-atmel.c:1406:				 &msg->transfers)) {
spi-atmel.c:1407:			as->keep_cs = true;
spi-atmel.c:1409:			as->cs_active = !as->cs_active;
spi-atmel.c:1410:			if (as->cs_active)
spi-atmel.c:1411:				cs_activate(as, msg->spi);
spi-atmel.c:1413:				cs_deactivate(as, msg->spi);
spi-atmel.c:1425:	struct spi_device *spi = msg->spi;
spi-atmel.c:1430:	dev_dbg(&spi->dev, "new message %p submitted for %s\n",
spi-atmel.c:1431:					msg, dev_name(&spi->dev));
spi-atmel.c:1436:	as->cs_active = true;
spi-atmel.c:1437:	as->keep_cs = false;
spi-atmel.c:1439:	msg->status = 0;
spi-atmel.c:1440:	msg->actual_length = 0;
spi-atmel.c:1442:	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
spi-atmel.c:1448:	if (as->use_pdc)
spi-atmel.c:1451:	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
spi-atmel.c:1452:		dev_dbg(&spi->dev,
spi-atmel.c:1454:			xfer, xfer->len,
spi-atmel.c:1455:			xfer->tx_buf, &xfer->tx_dma,
spi-atmel.c:1456:			xfer->rx_buf, &xfer->rx_dma);
spi-atmel.c:1460:	if (!as->keep_cs)
spi-atmel.c:1461:		cs_deactivate(as, msg->spi);
spi-atmel.c:1465:	msg->status = as->done_status;
spi-atmel.c:1466:	spi_finalize_current_message(spi->master);
spi-atmel.c:1473:	struct atmel_spi_device	*asd = spi->controller_state;
spi-atmel.c:1474:	unsigned		gpio = (unsigned long) spi->controller_data;
spi-atmel.c:1479:	spi->controller_state = NULL;
spi-atmel.c:1494:	dev_info(&as->pdev->dev, "version: 0x%x\n", version);
spi-atmel.c:1496:	as->caps.is_spi2 = version > 0x121;
spi-atmel.c:1497:	as->caps.has_wdrbt = version >= 0x210;
spi-atmel.c:1498:	as->caps.has_dma_support = version >= 0x212;
spi-atmel.c:1501:/*-------------------------------------------------------------------------*/
spi-atmel.c:1513:	pinctrl_pm_select_default_state(&pdev->dev);
spi-atmel.c:1517:		return -ENXIO;
spi-atmel.c:1523:	clk = devm_clk_get(&pdev->dev, "spi_clk");
spi-atmel.c:1527:	/* setup spi core then atmel-specific driver state */
spi-atmel.c:1528:	ret = -ENOMEM;
spi-atmel.c:1529:	master = spi_alloc_master(&pdev->dev, sizeof(*as));
spi-atmel.c:1533:	/* the spi->mode bits understood by this driver: */
spi-atmel.c:1534:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-atmel.c:1535:	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 16);
spi-atmel.c:1536:	master->dev.of_node = pdev->dev.of_node;
spi-atmel.c:1537:	master->bus_num = pdev->id;
spi-atmel.c:1538:	master->num_chipselect = master->dev.of_node ? 0 : 4;
spi-atmel.c:1539:	master->setup = atmel_spi_setup;
spi-atmel.c:1540:	master->transfer_one_message = atmel_spi_transfer_one_message;
spi-atmel.c:1541:	master->cleanup = atmel_spi_cleanup;
spi-atmel.c:1542:	master->auto_runtime_pm = true;
spi-atmel.c:1551:	as->buffer = dma_alloc_coherent(&pdev->dev, BUFFER_SIZE,
spi-atmel.c:1552:					&as->buffer_dma, GFP_KERNEL);
spi-atmel.c:1553:	if (!as->buffer)
spi-atmel.c:1556:	spin_lock_init(&as->lock);
spi-atmel.c:1558:	as->pdev = pdev;
spi-atmel.c:1559:	as->regs = devm_ioremap_resource(&pdev->dev, regs);
spi-atmel.c:1560:	if (IS_ERR(as->regs)) {
spi-atmel.c:1561:		ret = PTR_ERR(as->regs);
spi-atmel.c:1564:	as->phybase = regs->start;
spi-atmel.c:1565:	as->irq = irq;
spi-atmel.c:1566:	as->clk = clk;
spi-atmel.c:1568:	init_completion(&as->xfer_completion);
spi-atmel.c:1572:	as->use_cs_gpios = true;
spi-atmel.c:1574:	    pdev->dev.of_node &&
spi-atmel.c:1575:	    !of_get_property(pdev->dev.of_node, "cs-gpios", NULL)) {
spi-atmel.c:1576:		as->use_cs_gpios = false;
spi-atmel.c:1577:		master->num_chipselect = 4;
spi-atmel.c:1580:	as->use_dma = false;
spi-atmel.c:1581:	as->use_pdc = false;
spi-atmel.c:1582:	if (as->caps.has_dma_support) {
spi-atmel.c:1585:			as->use_dma = true;
spi-atmel.c:1586:		else if (ret == -EPROBE_DEFER)
spi-atmel.c:1589:		as->use_pdc = true;
spi-atmel.c:1592:	if (as->caps.has_dma_support && !as->use_dma)
spi-atmel.c:1593:		dev_info(&pdev->dev, "Atmel SPI Controller using PIO only\n");
spi-atmel.c:1595:	if (as->use_pdc) {
spi-atmel.c:1596:		ret = devm_request_irq(&pdev->dev, irq, atmel_spi_pdc_interrupt,
spi-atmel.c:1597:					0, dev_name(&pdev->dev), master);
spi-atmel.c:1599:		ret = devm_request_irq(&pdev->dev, irq, atmel_spi_pio_interrupt,
spi-atmel.c:1600:					0, dev_name(&pdev->dev), master);
spi-atmel.c:1611:	if (as->caps.has_wdrbt) {
spi-atmel.c:1618:	if (as->use_pdc)
spi-atmel.c:1622:	as->fifo_size = 0;
spi-atmel.c:1623:	if (!of_property_read_u32(pdev->dev.of_node, "atmel,fifo-size",
spi-atmel.c:1624:				  &as->fifo_size)) {
spi-atmel.c:1625:		dev_info(&pdev->dev, "Using FIFO (%u data)\n", as->fifo_size);
spi-atmel.c:1630:	dev_info(&pdev->dev, "Atmel SPI Controller at 0x%08lx (irq %d)\n",
spi-atmel.c:1631:			(unsigned long)regs->start, irq);
spi-atmel.c:1633:	pm_runtime_set_autosuspend_delay(&pdev->dev, AUTOSUSPEND_TIMEOUT);
spi-atmel.c:1634:	pm_runtime_use_autosuspend(&pdev->dev);
spi-atmel.c:1635:	pm_runtime_set_active(&pdev->dev);
spi-atmel.c:1636:	pm_runtime_enable(&pdev->dev);
spi-atmel.c:1638:	ret = devm_spi_register_master(&pdev->dev, master);
spi-atmel.c:1645:	pm_runtime_disable(&pdev->dev);
spi-atmel.c:1646:	pm_runtime_set_suspended(&pdev->dev);
spi-atmel.c:1648:	if (as->use_dma)
spi-atmel.c:1657:	dma_free_coherent(&pdev->dev, BUFFER_SIZE, as->buffer,
spi-atmel.c:1658:			as->buffer_dma);
spi-atmel.c:1669:	pm_runtime_get_sync(&pdev->dev);
spi-atmel.c:1672:	if (as->use_dma) {
spi-atmel.c:1677:	spin_lock_irq(&as->lock);
spi-atmel.c:1681:	spin_unlock_irq(&as->lock);
spi-atmel.c:1683:	dma_free_coherent(&pdev->dev, BUFFER_SIZE, as->buffer,
spi-atmel.c:1684:			as->buffer_dma);
spi-atmel.c:1686:	clk_disable_unprepare(as->clk);
spi-atmel.c:1688:	pm_runtime_put_noidle(&pdev->dev);
spi-atmel.c:1689:	pm_runtime_disable(&pdev->dev);
spi-atmel.c:1700:	clk_disable_unprepare(as->clk);
spi-atmel.c:1713:	return clk_prepare_enable(as->clk);
spi-atmel.c:1767:	{ .compatible = "atmel,at91rm9200-spi" },
spi-bfin5xx.c:2: * Blackfin On-Chip SPI Driver
spi-bfin5xx.c:4: * Copyright 2004-2010 Analog Devices Inc.
spi-bfin5xx.c:8: * Licensed under the GPL-2 or later.
spi-bfin5xx.c:23:#include <linux/dma-mapping.h>
spi-bfin5xx.c:32:#define DRV_NAME	"bfin-spi"
spi-bfin5xx.c:34:#define DRV_DESC	"Blackfin on-chip SPI Controller Driver"
spi-bfin5xx.c:44:#define ERROR_STATE	((void *)-1)
spi-bfin5xx.c:128:	bfin_write_or(&drv_data->regs->ctl, BIT_CTL_ENABLE);
spi-bfin5xx.c:133:	bfin_write_and(&drv_data->regs->ctl, ~BIT_CTL_ENABLE);
spi-bfin5xx.c:156:	while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_SPIF) && --limit)
spi-bfin5xx.c:159:	bfin_write(&drv_data->regs->stat, BIT_STAT_CLR);
spi-bfin5xx.c:167:	if (likely(chip->chip_select_num < MAX_CTRL_CS))
spi-bfin5xx.c:168:		bfin_write_and(&drv_data->regs->flg, ~chip->flag);
spi-bfin5xx.c:170:		gpio_set_value(chip->cs_gpio, 0);
spi-bfin5xx.c:176:	if (likely(chip->chip_select_num < MAX_CTRL_CS))
spi-bfin5xx.c:177:		bfin_write_or(&drv_data->regs->flg, chip->flag);
spi-bfin5xx.c:179:		gpio_set_value(chip->cs_gpio, 1);
spi-bfin5xx.c:182:	if (chip->cs_chg_udelay)
spi-bfin5xx.c:183:		udelay(chip->cs_chg_udelay);
spi-bfin5xx.c:190:	if (chip->chip_select_num < MAX_CTRL_CS)
spi-bfin5xx.c:191:		bfin_write_or(&drv_data->regs->flg, chip->flag >> 8);
spi-bfin5xx.c:197:	if (chip->chip_select_num < MAX_CTRL_CS)
spi-bfin5xx.c:198:		bfin_write_and(&drv_data->regs->flg, ~(chip->flag >> 8));
spi-bfin5xx.c:201:/* stop controller and re-config current chip*/
spi-bfin5xx.c:204:	struct bfin_spi_slave_data *chip = drv_data->cur_chip;
spi-bfin5xx.c:207:	bfin_write(&drv_data->regs->stat, BIT_STAT_CLR);
spi-bfin5xx.c:209:	dev_dbg(&drv_data->pdev->dev, "restoring spi ctl state\n");
spi-bfin5xx.c:214:	bfin_write(&drv_data->regs->ctl, chip->ctl_reg);
spi-bfin5xx.c:215:	bfin_write(&drv_data->regs->baud, chip->baud);
spi-bfin5xx.c:224:	(void) bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:232:	while (drv_data->tx < drv_data->tx_end) {
spi-bfin5xx.c:233:		bfin_write(&drv_data->regs->tdbr, (*(u8 *) (drv_data->tx++)));
spi-bfin5xx.c:236:		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
spi-bfin5xx.c:245:	u16 tx_val = drv_data->cur_chip->idle_tx_val;
spi-bfin5xx.c:250:	while (drv_data->rx < drv_data->rx_end) {
spi-bfin5xx.c:251:		bfin_write(&drv_data->regs->tdbr, tx_val);
spi-bfin5xx.c:252:		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
spi-bfin5xx.c:254:		*(u8 *) (drv_data->rx++) = bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:263:	while (drv_data->rx < drv_data->rx_end) {
spi-bfin5xx.c:264:		bfin_write(&drv_data->regs->tdbr, (*(u8 *) (drv_data->tx++)));
spi-bfin5xx.c:265:		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
spi-bfin5xx.c:267:		*(u8 *) (drv_data->rx++) = bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:282:	while (drv_data->tx < drv_data->tx_end) {
spi-bfin5xx.c:283:		bfin_write(&drv_data->regs->tdbr, (*(u16 *) (drv_data->tx)));
spi-bfin5xx.c:284:		drv_data->tx += 2;
spi-bfin5xx.c:287:		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
spi-bfin5xx.c:296:	u16 tx_val = drv_data->cur_chip->idle_tx_val;
spi-bfin5xx.c:301:	while (drv_data->rx < drv_data->rx_end) {
spi-bfin5xx.c:302:		bfin_write(&drv_data->regs->tdbr, tx_val);
spi-bfin5xx.c:303:		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
spi-bfin5xx.c:305:		*(u16 *) (drv_data->rx) = bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:306:		drv_data->rx += 2;
spi-bfin5xx.c:315:	while (drv_data->rx < drv_data->rx_end) {
spi-bfin5xx.c:316:		bfin_write(&drv_data->regs->tdbr, (*(u16 *) (drv_data->tx)));
spi-bfin5xx.c:317:		drv_data->tx += 2;
spi-bfin5xx.c:318:		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
spi-bfin5xx.c:320:		*(u16 *) (drv_data->rx) = bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:321:		drv_data->rx += 2;
spi-bfin5xx.c:334:	struct spi_message *msg = drv_data->cur_msg;
spi-bfin5xx.c:335:	struct spi_transfer *trans = drv_data->cur_transfer;
spi-bfin5xx.c:338:	if (trans->transfer_list.next != &msg->transfers) {
spi-bfin5xx.c:339:		drv_data->cur_transfer =
spi-bfin5xx.c:340:		    list_entry(trans->transfer_list.next,
spi-bfin5xx.c:348: * caller already set message->status;
spi-bfin5xx.c:353:	struct bfin_spi_slave_data *chip = drv_data->cur_chip;
spi-bfin5xx.c:357:	spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin5xx.c:358:	msg = drv_data->cur_msg;
spi-bfin5xx.c:359:	drv_data->cur_msg = NULL;
spi-bfin5xx.c:360:	drv_data->cur_transfer = NULL;
spi-bfin5xx.c:361:	drv_data->cur_chip = NULL;
spi-bfin5xx.c:362:	queue_work(drv_data->workqueue, &drv_data->pump_messages);
spi-bfin5xx.c:363:	spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin5xx.c:365:	msg->state = NULL;
spi-bfin5xx.c:367:	if (!drv_data->cs_change)
spi-bfin5xx.c:371:	if (drv_data->tx_dma != 0xFFFF)
spi-bfin5xx.c:374:	if (msg->complete)
spi-bfin5xx.c:375:		msg->complete(msg->context);
spi-bfin5xx.c:382:	struct bfin_spi_slave_data *chip = drv_data->cur_chip;
spi-bfin5xx.c:383:	struct spi_message *msg = drv_data->cur_msg;
spi-bfin5xx.c:384:	int n_bytes = drv_data->n_bytes;
spi-bfin5xx.c:388:	while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
spi-bfin5xx.c:391:	if ((drv_data->tx && drv_data->tx >= drv_data->tx_end) ||
spi-bfin5xx.c:392:		(drv_data->rx && drv_data->rx >= (drv_data->rx_end - n_bytes))) {
spi-bfin5xx.c:394:		if (drv_data->rx) {
spi-bfin5xx.c:395:			dev_dbg(&drv_data->pdev->dev, "last read\n");
spi-bfin5xx.c:397:				u16 *buf = (u16 *)drv_data->rx;
spi-bfin5xx.c:399:					*buf++ = bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:401:				u8 *buf = (u8 *)drv_data->rx;
spi-bfin5xx.c:403:					*buf++ = bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:405:			drv_data->rx += n_bytes;
spi-bfin5xx.c:408:		msg->actual_length += drv_data->len_in_bytes;
spi-bfin5xx.c:409:		if (drv_data->cs_change)
spi-bfin5xx.c:412:		msg->state = bfin_spi_next_transfer(drv_data);
spi-bfin5xx.c:414:		disable_irq_nosync(drv_data->spi_irq);
spi-bfin5xx.c:417:		tasklet_schedule(&drv_data->pump_transfers);
spi-bfin5xx.c:421:	if (drv_data->rx && drv_data->tx) {
spi-bfin5xx.c:423:		dev_dbg(&drv_data->pdev->dev, "duplex: write_TDBR\n");
spi-bfin5xx.c:425:			u16 *buf = (u16 *)drv_data->rx;
spi-bfin5xx.c:426:			u16 *buf2 = (u16 *)drv_data->tx;
spi-bfin5xx.c:428:				*buf++ = bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:429:				bfin_write(&drv_data->regs->tdbr, *buf2++);
spi-bfin5xx.c:432:			u8 *buf = (u8 *)drv_data->rx;
spi-bfin5xx.c:433:			u8 *buf2 = (u8 *)drv_data->tx;
spi-bfin5xx.c:435:				*buf++ = bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:436:				bfin_write(&drv_data->regs->tdbr, *buf2++);
spi-bfin5xx.c:439:	} else if (drv_data->rx) {
spi-bfin5xx.c:441:		dev_dbg(&drv_data->pdev->dev, "read: write_TDBR\n");
spi-bfin5xx.c:443:			u16 *buf = (u16 *)drv_data->rx;
spi-bfin5xx.c:445:				*buf++ = bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:446:				bfin_write(&drv_data->regs->tdbr, chip->idle_tx_val);
spi-bfin5xx.c:449:			u8 *buf = (u8 *)drv_data->rx;
spi-bfin5xx.c:451:				*buf++ = bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:452:				bfin_write(&drv_data->regs->tdbr, chip->idle_tx_val);
spi-bfin5xx.c:455:	} else if (drv_data->tx) {
spi-bfin5xx.c:457:		dev_dbg(&drv_data->pdev->dev, "write: write_TDBR\n");
spi-bfin5xx.c:459:			u16 *buf = (u16 *)drv_data->tx;
spi-bfin5xx.c:461:				bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:462:				bfin_write(&drv_data->regs->tdbr, *buf++);
spi-bfin5xx.c:465:			u8 *buf = (u8 *)drv_data->tx;
spi-bfin5xx.c:467:				bfin_read(&drv_data->regs->rdbr);
spi-bfin5xx.c:468:				bfin_write(&drv_data->regs->tdbr, *buf++);
spi-bfin5xx.c:473:	if (drv_data->tx)
spi-bfin5xx.c:474:		drv_data->tx += n_bytes;
spi-bfin5xx.c:475:	if (drv_data->rx)
spi-bfin5xx.c:476:		drv_data->rx += n_bytes;
spi-bfin5xx.c:484:	struct bfin_spi_slave_data *chip = drv_data->cur_chip;
spi-bfin5xx.c:485:	struct spi_message *msg = drv_data->cur_msg;
spi-bfin5xx.c:487:	unsigned short dmastat = get_dma_curr_irqstat(drv_data->dma_channel);
spi-bfin5xx.c:488:	u16 spistat = bfin_read(&drv_data->regs->stat);
spi-bfin5xx.c:490:	dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:494:	if (drv_data->rx != NULL) {
spi-bfin5xx.c:495:		u16 cr = bfin_read(&drv_data->regs->ctl);
spi-bfin5xx.c:498:		bfin_write(&drv_data->regs->ctl, cr & ~BIT_CTL_ENABLE); /* Disable SPI */
spi-bfin5xx.c:499:		bfin_write(&drv_data->regs->ctl, cr & ~BIT_CTL_TIMOD); /* Restore State */
spi-bfin5xx.c:500:		bfin_write(&drv_data->regs->stat, BIT_STAT_CLR); /* Clear Status */
spi-bfin5xx.c:503:	clear_dma_irqstat(drv_data->dma_channel);
spi-bfin5xx.c:511:	if (drv_data->tx != NULL) {
spi-bfin5xx.c:512:		while ((bfin_read(&drv_data->regs->stat) & BIT_STAT_TXS) ||
spi-bfin5xx.c:513:		       (bfin_read(&drv_data->regs->stat) & BIT_STAT_TXS))
spi-bfin5xx.c:517:	dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:519:		dmastat, bfin_read(&drv_data->regs->stat));
spi-bfin5xx.c:522:	while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_SPIF))
spi-bfin5xx.c:524:			dev_warn(&drv_data->pdev->dev, "timeout waiting for SPIF\n");
spi-bfin5xx.c:530:		msg->state = ERROR_STATE;
spi-bfin5xx.c:531:		dev_err(&drv_data->pdev->dev, "dma receive: fifo/buffer overflow\n");
spi-bfin5xx.c:533:		msg->actual_length += drv_data->len_in_bytes;
spi-bfin5xx.c:535:		if (drv_data->cs_change)
spi-bfin5xx.c:539:		msg->state = bfin_spi_next_transfer(drv_data);
spi-bfin5xx.c:543:	tasklet_schedule(&drv_data->pump_transfers);
spi-bfin5xx.c:546:	dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:548:		drv_data->dma_channel);
spi-bfin5xx.c:549:	dma_disable_irq_nosync(drv_data->dma_channel);
spi-bfin5xx.c:567:	message = drv_data->cur_msg;
spi-bfin5xx.c:568:	transfer = drv_data->cur_transfer;
spi-bfin5xx.c:569:	chip = drv_data->cur_chip;
spi-bfin5xx.c:576:	if (message->state == ERROR_STATE) {
spi-bfin5xx.c:577:		dev_dbg(&drv_data->pdev->dev, "transfer: we've hit an error\n");
spi-bfin5xx.c:578:		message->status = -EIO;
spi-bfin5xx.c:584:	if (message->state == DONE_STATE) {
spi-bfin5xx.c:585:		dev_dbg(&drv_data->pdev->dev, "transfer: all done!\n");
spi-bfin5xx.c:586:		message->status = 0;
spi-bfin5xx.c:593:	if (message->state == RUNNING_STATE) {
spi-bfin5xx.c:594:		dev_dbg(&drv_data->pdev->dev, "transfer: still running ...\n");
spi-bfin5xx.c:595:		previous = list_entry(transfer->transfer_list.prev,
spi-bfin5xx.c:597:		if (previous->delay_usecs)
spi-bfin5xx.c:598:			udelay(previous->delay_usecs);
spi-bfin5xx.c:603:		dev_err(&drv_data->pdev->dev, "pump_transfers: flush failed\n");
spi-bfin5xx.c:604:		message->status = -EIO;
spi-bfin5xx.c:609:	if (transfer->len == 0) {
spi-bfin5xx.c:611:		message->state = bfin_spi_next_transfer(drv_data);
spi-bfin5xx.c:613:		tasklet_schedule(&drv_data->pump_transfers);
spi-bfin5xx.c:617:	if (transfer->tx_buf != NULL) {
spi-bfin5xx.c:618:		drv_data->tx = (void *)transfer->tx_buf;
spi-bfin5xx.c:619:		drv_data->tx_end = drv_data->tx + transfer->len;
spi-bfin5xx.c:620:		dev_dbg(&drv_data->pdev->dev, "tx_buf is %p, tx_end is %p\n",
spi-bfin5xx.c:621:			transfer->tx_buf, drv_data->tx_end);
spi-bfin5xx.c:623:		drv_data->tx = NULL;
spi-bfin5xx.c:626:	if (transfer->rx_buf != NULL) {
spi-bfin5xx.c:627:		full_duplex = transfer->tx_buf != NULL;
spi-bfin5xx.c:628:		drv_data->rx = transfer->rx_buf;
spi-bfin5xx.c:629:		drv_data->rx_end = drv_data->rx + transfer->len;
spi-bfin5xx.c:630:		dev_dbg(&drv_data->pdev->dev, "rx_buf is %p, rx_end is %p\n",
spi-bfin5xx.c:631:			transfer->rx_buf, drv_data->rx_end);
spi-bfin5xx.c:633:		drv_data->rx = NULL;
spi-bfin5xx.c:636:	drv_data->rx_dma = transfer->rx_dma;
spi-bfin5xx.c:637:	drv_data->tx_dma = transfer->tx_dma;
spi-bfin5xx.c:638:	drv_data->len_in_bytes = transfer->len;
spi-bfin5xx.c:639:	drv_data->cs_change = transfer->cs_change;
spi-bfin5xx.c:642:	bits_per_word = transfer->bits_per_word;
spi-bfin5xx.c:644:		drv_data->n_bytes = bits_per_word/8;
spi-bfin5xx.c:645:		drv_data->len = (transfer->len) >> 1;
spi-bfin5xx.c:647:		drv_data->ops = &bfin_bfin_spi_transfer_ops_u16;
spi-bfin5xx.c:649:		drv_data->n_bytes = bits_per_word/8;
spi-bfin5xx.c:650:		drv_data->len = transfer->len;
spi-bfin5xx.c:651:		drv_data->ops = &bfin_bfin_spi_transfer_ops_u8;
spi-bfin5xx.c:653:	cr = bfin_read(&drv_data->regs->ctl) & ~(BIT_CTL_TIMOD | BIT_CTL_WORDSIZE);
spi-bfin5xx.c:655:	bfin_write(&drv_data->regs->ctl, cr);
spi-bfin5xx.c:657:	dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:658:		"transfer: drv_data->ops is %p, chip->ops is %p, u8_ops is %p\n",
spi-bfin5xx.c:659:		drv_data->ops, chip->ops, &bfin_bfin_spi_transfer_ops_u8);
spi-bfin5xx.c:661:	message->state = RUNNING_STATE;
spi-bfin5xx.c:664:	bfin_write(&drv_data->regs->baud, hz_to_spi_baud(transfer->speed_hz));
spi-bfin5xx.c:666:	bfin_write(&drv_data->regs->stat, BIT_STAT_CLR);
spi-bfin5xx.c:669:	dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:671:		cr_width, transfer->len);
spi-bfin5xx.c:679:	if (!full_duplex && drv_data->cur_chip->enable_dma
spi-bfin5xx.c:680:				&& drv_data->len > 6) {
spi-bfin5xx.c:684:		disable_dma(drv_data->dma_channel);
spi-bfin5xx.c:685:		clear_dma_irqstat(drv_data->dma_channel);
spi-bfin5xx.c:688:		dev_dbg(&drv_data->pdev->dev, "doing dma transfer\n");
spi-bfin5xx.c:689:		set_dma_x_count(drv_data->dma_channel, drv_data->len);
spi-bfin5xx.c:691:			set_dma_x_modify(drv_data->dma_channel, 2);
spi-bfin5xx.c:694:			set_dma_x_modify(drv_data->dma_channel, 1);
spi-bfin5xx.c:699:		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_SPIF))
spi-bfin5xx.c:703:		if (drv_data->tx_dma == 0xFFFF) {
spi-bfin5xx.c:704:			dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:710:			set_dma_config(drv_data->dma_channel, dma_config);
spi-bfin5xx.c:711:			set_dma_start_addr(drv_data->dma_channel,
spi-bfin5xx.c:712:					(unsigned long)drv_data->tx);
spi-bfin5xx.c:713:			enable_dma(drv_data->dma_channel);
spi-bfin5xx.c:716:			bfin_write(&drv_data->regs->ctl, cr | BIT_CTL_TIMOD_DMA_TX);
spi-bfin5xx.c:721:			message->status = 0;
spi-bfin5xx.c:728:		if (drv_data->rx != NULL) {
spi-bfin5xx.c:730:			dev_dbg(&drv_data->pdev->dev, "doing DMA in to %p (size %zx)\n",
spi-bfin5xx.c:731:				drv_data->rx, drv_data->len_in_bytes);
spi-bfin5xx.c:734:			if (bfin_addr_dcacheable((unsigned long) drv_data->rx))
spi-bfin5xx.c:735:				invalidate_dcache_range((unsigned long) drv_data->rx,
spi-bfin5xx.c:736:							(unsigned long) (drv_data->rx +
spi-bfin5xx.c:737:							drv_data->len_in_bytes));
spi-bfin5xx.c:740:			dma_start_addr = (unsigned long)drv_data->rx;
spi-bfin5xx.c:743:		} else if (drv_data->tx != NULL) {
spi-bfin5xx.c:744:			dev_dbg(&drv_data->pdev->dev, "doing DMA out.\n");
spi-bfin5xx.c:747:			if (bfin_addr_dcacheable((unsigned long) drv_data->tx))
spi-bfin5xx.c:748:				flush_dcache_range((unsigned long) drv_data->tx,
spi-bfin5xx.c:749:						(unsigned long) (drv_data->tx +
spi-bfin5xx.c:750:						drv_data->len_in_bytes));
spi-bfin5xx.c:752:			dma_start_addr = (unsigned long)drv_data->tx;
spi-bfin5xx.c:767:		set_dma_start_addr(drv_data->dma_channel, dma_start_addr);
spi-bfin5xx.c:768:		set_dma_config(drv_data->dma_channel, dma_config);
spi-bfin5xx.c:771:		bfin_write(&drv_data->regs->ctl, cr);
spi-bfin5xx.c:772:		enable_dma(drv_data->dma_channel);
spi-bfin5xx.c:773:		dma_enable_irq(drv_data->dma_channel);
spi-bfin5xx.c:785:	bfin_write(&drv_data->regs->ctl, cr | BIT_CTL_TXMOD);
spi-bfin5xx.c:787:	if (chip->pio_interrupt) {
spi-bfin5xx.c:794:		if (drv_data->tx == NULL)
spi-bfin5xx.c:795:			bfin_write(&drv_data->regs->tdbr, chip->idle_tx_val);
spi-bfin5xx.c:799:				u16 *buf = (u16 *)drv_data->tx;
spi-bfin5xx.c:802:					bfin_write(&drv_data->regs->tdbr, *buf++);
spi-bfin5xx.c:805:				u8 *buf = (u8 *)drv_data->tx;
spi-bfin5xx.c:807:					bfin_write(&drv_data->regs->tdbr, *buf++);
spi-bfin5xx.c:810:			drv_data->tx += drv_data->n_bytes;
spi-bfin5xx.c:814:		enable_irq(drv_data->spi_irq);
spi-bfin5xx.c:819:	dev_dbg(&drv_data->pdev->dev, "doing IO transfer\n");
spi-bfin5xx.c:823:		BUG_ON((drv_data->tx_end - drv_data->tx) !=
spi-bfin5xx.c:824:		       (drv_data->rx_end - drv_data->rx));
spi-bfin5xx.c:825:		dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:828:		drv_data->ops->duplex(drv_data);
spi-bfin5xx.c:830:		if (drv_data->tx != drv_data->tx_end)
spi-bfin5xx.c:832:	} else if (drv_data->tx != NULL) {
spi-bfin5xx.c:834:		dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:837:		drv_data->ops->write(drv_data);
spi-bfin5xx.c:839:		if (drv_data->tx != drv_data->tx_end)
spi-bfin5xx.c:841:	} else if (drv_data->rx != NULL) {
spi-bfin5xx.c:843:		dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:846:		drv_data->ops->read(drv_data);
spi-bfin5xx.c:847:		if (drv_data->rx != drv_data->rx_end)
spi-bfin5xx.c:852:		dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:854:		message->state = ERROR_STATE;
spi-bfin5xx.c:857:		message->actual_length += drv_data->len_in_bytes;
spi-bfin5xx.c:859:		message->state = bfin_spi_next_transfer(drv_data);
spi-bfin5xx.c:860:		if (drv_data->cs_change && message->state != DONE_STATE) {
spi-bfin5xx.c:867:	tasklet_schedule(&drv_data->pump_transfers);
spi-bfin5xx.c:879:	spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin5xx.c:880:	if (list_empty(&drv_data->queue) || !drv_data->running) {
spi-bfin5xx.c:882:		drv_data->busy = 0;
spi-bfin5xx.c:883:		spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin5xx.c:888:	if (drv_data->cur_msg) {
spi-bfin5xx.c:889:		spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin5xx.c:894:	drv_data->cur_msg = list_entry(drv_data->queue.next,
spi-bfin5xx.c:898:	drv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);
spi-bfin5xx.c:901:	list_del_init(&drv_data->cur_msg->queue);
spi-bfin5xx.c:904:	drv_data->cur_msg->state = START_STATE;
spi-bfin5xx.c:905:	drv_data->cur_transfer = list_entry(drv_data->cur_msg->transfers.next,
spi-bfin5xx.c:908:	dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:911:		drv_data->cur_chip->baud, drv_data->cur_chip->flag,
spi-bfin5xx.c:912:		drv_data->cur_chip->ctl_reg);
spi-bfin5xx.c:914:	dev_dbg(&drv_data->pdev->dev,
spi-bfin5xx.c:916:		drv_data->cur_transfer->len);
spi-bfin5xx.c:919:	tasklet_schedule(&drv_data->pump_transfers);
spi-bfin5xx.c:921:	drv_data->busy = 1;
spi-bfin5xx.c:922:	spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin5xx.c:926: * got a msg to transfer, queue it in drv_data->queue.
spi-bfin5xx.c:931:	struct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
spi-bfin5xx.c:934:	spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin5xx.c:936:	if (!drv_data->running) {
spi-bfin5xx.c:937:		spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin5xx.c:938:		return -ESHUTDOWN;
spi-bfin5xx.c:941:	msg->actual_length = 0;
spi-bfin5xx.c:942:	msg->status = -EINPROGRESS;
spi-bfin5xx.c:943:	msg->state = START_STATE;
spi-bfin5xx.c:945:	dev_dbg(&spi->dev, "adding an msg in transfer() \n");
spi-bfin5xx.c:946:	list_add_tail(&msg->queue, &drv_data->queue);
spi-bfin5xx.c:948:	if (drv_data->running && !drv_data->busy)
spi-bfin5xx.c:949:		queue_work(drv_data->workqueue, &drv_data->pump_messages);
spi-bfin5xx.c:951:	spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin5xx.c:972:/* setup for devices (may be called multiple times -- not just first setup) */
spi-bfin5xx.c:977:	struct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
spi-bfin5xx.c:979:	int ret = -EINVAL;
spi-bfin5xx.c:987:			dev_err(&spi->dev, "cannot allocate chip data\n");
spi-bfin5xx.c:988:			ret = -ENOMEM;
spi-bfin5xx.c:992:		chip->enable_dma = 0;
spi-bfin5xx.c:993:		chip_info = spi->controller_data;
spi-bfin5xx.c:996:	/* Let people set non-standard bits directly */
spi-bfin5xx.c:1008:		if (chip_info->ctl_reg & ~bfin_ctl_reg) {
spi-bfin5xx.c:1009:			dev_err(&spi->dev,
spi-bfin5xx.c:1013:		chip->enable_dma = chip_info->enable_dma != 0
spi-bfin5xx.c:1014:		    && drv_data->master_info->enable_dma;
spi-bfin5xx.c:1015:		chip->ctl_reg = chip_info->ctl_reg;
spi-bfin5xx.c:1016:		chip->cs_chg_udelay = chip_info->cs_chg_udelay;
spi-bfin5xx.c:1017:		chip->idle_tx_val = chip_info->idle_tx_val;
spi-bfin5xx.c:1018:		chip->pio_interrupt = chip_info->pio_interrupt;
spi-bfin5xx.c:1021:		chip->ctl_reg &= bfin_ctl_reg;
spi-bfin5xx.c:1025:	if (spi->mode & SPI_CPOL)
spi-bfin5xx.c:1026:		chip->ctl_reg |= BIT_CTL_CPOL;
spi-bfin5xx.c:1027:	if (spi->mode & SPI_CPHA)
spi-bfin5xx.c:1028:		chip->ctl_reg |= BIT_CTL_CPHA;
spi-bfin5xx.c:1029:	if (spi->mode & SPI_LSB_FIRST)
spi-bfin5xx.c:1030:		chip->ctl_reg |= BIT_CTL_LSBF;
spi-bfin5xx.c:1032:	chip->ctl_reg |= BIT_CTL_MASTER;
spi-bfin5xx.c:1038:	chip->baud = hz_to_spi_baud(spi->max_speed_hz);
spi-bfin5xx.c:1039:	chip->chip_select_num = spi->chip_select;
spi-bfin5xx.c:1040:	if (chip->chip_select_num < MAX_CTRL_CS) {
spi-bfin5xx.c:1041:		if (!(spi->mode & SPI_CPHA))
spi-bfin5xx.c:1042:			dev_warn(&spi->dev,
spi-bfin5xx.c:1044:				"See Documentation/blackfin/bfin-spi-notes.txt\n");
spi-bfin5xx.c:1046:		chip->flag = (1 << spi->chip_select) << 8;
spi-bfin5xx.c:1048:		chip->cs_gpio = chip->chip_select_num - MAX_CTRL_CS;
spi-bfin5xx.c:1050:	if (chip->enable_dma && chip->pio_interrupt) {
spi-bfin5xx.c:1051:		dev_err(&spi->dev,
spi-bfin5xx.c:1059:	if (chip->enable_dma && !drv_data->dma_requested) {
spi-bfin5xx.c:1061:		ret = request_dma(drv_data->dma_channel, "BFIN_SPI_DMA");
spi-bfin5xx.c:1063:			dev_err(&spi->dev,
spi-bfin5xx.c:1067:		drv_data->dma_requested = 1;
spi-bfin5xx.c:1069:		ret = set_dma_callback(drv_data->dma_channel,
spi-bfin5xx.c:1072:			dev_err(&spi->dev, "Unable to set dma callback\n");
spi-bfin5xx.c:1075:		dma_disable_irq(drv_data->dma_channel);
spi-bfin5xx.c:1078:	if (chip->pio_interrupt && !drv_data->irq_requested) {
spi-bfin5xx.c:1079:		ret = request_irq(drv_data->spi_irq, bfin_spi_pio_irq_handler,
spi-bfin5xx.c:1082:			dev_err(&spi->dev, "Unable to register spi IRQ\n");
spi-bfin5xx.c:1085:		drv_data->irq_requested = 1;
spi-bfin5xx.c:1087:		disable_irq(drv_data->spi_irq);
spi-bfin5xx.c:1090:	if (chip->chip_select_num >= MAX_CTRL_CS) {
spi-bfin5xx.c:1093:			ret = gpio_request(chip->cs_gpio, spi->modalias);
spi-bfin5xx.c:1095:				dev_err(&spi->dev, "gpio_request() error\n");
spi-bfin5xx.c:1098:			gpio_direction_output(chip->cs_gpio, 1);
spi-bfin5xx.c:1102:	dev_dbg(&spi->dev, "setup spi chip %s, width is %d, dma is %d\n",
spi-bfin5xx.c:1103:			spi->modalias, spi->bits_per_word, chip->enable_dma);
spi-bfin5xx.c:1104:	dev_dbg(&spi->dev, "ctl_reg is 0x%x, flag_reg is 0x%x\n",
spi-bfin5xx.c:1105:			chip->ctl_reg, chip->flag);
spi-bfin5xx.c:1109:	dev_dbg(&spi->dev, "chip select number is %d\n", chip->chip_select_num);
spi-bfin5xx.c:1110:	if (chip->chip_select_num < MAX_CTRL_CS) {
spi-bfin5xx.c:1111:		ret = peripheral_request(ssel[spi->master->bus_num]
spi-bfin5xx.c:1112:		                         [chip->chip_select_num-1], spi->modalias);
spi-bfin5xx.c:1114:			dev_err(&spi->dev, "peripheral_request() error\n");
spi-bfin5xx.c:1125:	if (chip->chip_select_num >= MAX_CTRL_CS)
spi-bfin5xx.c:1126:		gpio_free(chip->cs_gpio);
spi-bfin5xx.c:1128:		peripheral_free(ssel[spi->master->bus_num]
spi-bfin5xx.c:1129:			[chip->chip_select_num - 1]);
spi-bfin5xx.c:1132:		if (drv_data->dma_requested)
spi-bfin5xx.c:1133:			free_dma(drv_data->dma_channel);
spi-bfin5xx.c:1134:		drv_data->dma_requested = 0;
spi-bfin5xx.c:1151:	struct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
spi-bfin5xx.c:1156:	if (chip->chip_select_num < MAX_CTRL_CS) {
spi-bfin5xx.c:1157:		peripheral_free(ssel[spi->master->bus_num]
spi-bfin5xx.c:1158:					[chip->chip_select_num-1]);
spi-bfin5xx.c:1161:		gpio_free(chip->cs_gpio);
spi-bfin5xx.c:1170:	INIT_LIST_HEAD(&drv_data->queue);
spi-bfin5xx.c:1171:	spin_lock_init(&drv_data->lock);
spi-bfin5xx.c:1173:	drv_data->running = false;
spi-bfin5xx.c:1174:	drv_data->busy = 0;
spi-bfin5xx.c:1177:	tasklet_init(&drv_data->pump_transfers,
spi-bfin5xx.c:1181:	INIT_WORK(&drv_data->pump_messages, bfin_spi_pump_messages);
spi-bfin5xx.c:1182:	drv_data->workqueue = create_singlethread_workqueue(
spi-bfin5xx.c:1183:				dev_name(drv_data->master->dev.parent));
spi-bfin5xx.c:1184:	if (drv_data->workqueue == NULL)
spi-bfin5xx.c:1185:		return -EBUSY;
spi-bfin5xx.c:1194:	spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin5xx.c:1196:	if (drv_data->running || drv_data->busy) {
spi-bfin5xx.c:1197:		spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin5xx.c:1198:		return -EBUSY;
spi-bfin5xx.c:1201:	drv_data->running = true;
spi-bfin5xx.c:1202:	drv_data->cur_msg = NULL;
spi-bfin5xx.c:1203:	drv_data->cur_transfer = NULL;
spi-bfin5xx.c:1204:	drv_data->cur_chip = NULL;
spi-bfin5xx.c:1205:	spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin5xx.c:1207:	queue_work(drv_data->workqueue, &drv_data->pump_messages);
spi-bfin5xx.c:1218:	spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin5xx.c:1222:	 * A wait_queue on the drv_data->busy could be used, but then the common
spi-bfin5xx.c:1226:	drv_data->running = false;
spi-bfin5xx.c:1227:	while ((!list_empty(&drv_data->queue) || drv_data->busy) && limit--) {
spi-bfin5xx.c:1228:		spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin5xx.c:1230:		spin_lock_irqsave(&drv_data->lock, flags);
spi-bfin5xx.c:1233:	if (!list_empty(&drv_data->queue) || drv_data->busy)
spi-bfin5xx.c:1234:		status = -EBUSY;
spi-bfin5xx.c:1236:	spin_unlock_irqrestore(&drv_data->lock, flags);
spi-bfin5xx.c:1249:	destroy_workqueue(drv_data->workqueue);
spi-bfin5xx.c:1256:	struct device *dev = &pdev->dev;
spi-bfin5xx.c:1268:		dev_err(&pdev->dev, "can not alloc spi_master\n");
spi-bfin5xx.c:1269:		return -ENOMEM;
spi-bfin5xx.c:1273:	drv_data->master = master;
spi-bfin5xx.c:1274:	drv_data->master_info = platform_info;
spi-bfin5xx.c:1275:	drv_data->pdev = pdev;
spi-bfin5xx.c:1276:	drv_data->pin_req = platform_info->pin_req;
spi-bfin5xx.c:1278:	/* the spi->mode bits supported by this driver: */
spi-bfin5xx.c:1279:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;
spi-bfin5xx.c:1280:	master->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);
spi-bfin5xx.c:1281:	master->bus_num = pdev->id;
spi-bfin5xx.c:1282:	master->num_chipselect = platform_info->num_chipselect;
spi-bfin5xx.c:1283:	master->cleanup = bfin_spi_cleanup;
spi-bfin5xx.c:1284:	master->setup = bfin_spi_setup;
spi-bfin5xx.c:1285:	master->transfer = bfin_spi_transfer;
spi-bfin5xx.c:1291:		status = -ENOENT;
spi-bfin5xx.c:1295:	drv_data->regs = ioremap(res->start, resource_size(res));
spi-bfin5xx.c:1296:	if (drv_data->regs == NULL) {
spi-bfin5xx.c:1298:		status = -ENXIO;
spi-bfin5xx.c:1305:		status = -ENOENT;
spi-bfin5xx.c:1308:	drv_data->dma_channel = res->start;
spi-bfin5xx.c:1310:	drv_data->spi_irq = platform_get_irq(pdev, 0);
spi-bfin5xx.c:1311:	if (drv_data->spi_irq < 0) {
spi-bfin5xx.c:1313:		status = -ENOENT;
spi-bfin5xx.c:1330:	status = peripheral_request_list(drv_data->pin_req, DRV_NAME);
spi-bfin5xx.c:1332:		dev_err(&pdev->dev, ": Requesting Peripherals failed\n");
spi-bfin5xx.c:1339:	bfin_write(&drv_data->regs->ctl, BIT_CTL_CPHA | BIT_CTL_MASTER);
spi-bfin5xx.c:1340:	bfin_write(&drv_data->regs->flg, 0xFF00);
spi-bfin5xx.c:1351:		DRV_DESC, DRV_VERSION, drv_data->regs,
spi-bfin5xx.c:1352:		drv_data->dma_channel);
spi-bfin5xx.c:1358:	iounmap(drv_data->regs);
spi-bfin5xx.c:1384:	if (drv_data->master_info->enable_dma) {
spi-bfin5xx.c:1385:		if (dma_channel_active(drv_data->dma_channel))
spi-bfin5xx.c:1386:			free_dma(drv_data->dma_channel);
spi-bfin5xx.c:1389:	if (drv_data->irq_requested) {
spi-bfin5xx.c:1390:		free_irq(drv_data->spi_irq, drv_data);
spi-bfin5xx.c:1391:		drv_data->irq_requested = 0;
spi-bfin5xx.c:1395:	spi_unregister_master(drv_data->master);
spi-bfin5xx.c:1397:	peripheral_free_list(drv_data->pin_req);
spi-bfin5xx.c:1412:	drv_data->ctrl_reg = bfin_read(&drv_data->regs->ctl);
spi-bfin5xx.c:1413:	drv_data->flag_reg = bfin_read(&drv_data->regs->flg);
spi-bfin5xx.c:1418:	bfin_write(&drv_data->regs->ctl, BIT_CTL_CPHA | BIT_CTL_MASTER);
spi-bfin5xx.c:1419:	bfin_write(&drv_data->regs->flg, 0xFF00);
spi-bfin5xx.c:1429:	bfin_write(&drv_data->regs->ctl, drv_data->ctrl_reg);
spi-bfin5xx.c:1430:	bfin_write(&drv_data->regs->flg, drv_data->flag_reg);
spi-bfin5xx.c:1449:MODULE_ALIAS("platform:bfin-spi");
spi-tegra114.c:23:#include <linux/dma-mapping.h>
spi-tegra114.c:222:	return readl(tspi->base + reg);
spi-tegra114.c:228:	writel(val, tspi->base + reg);
spi-tegra114.c:232:		readl(tspi->base + SPI_COMMAND1);
spi-tegra114.c:254:	unsigned remain_len = t->len - tspi->cur_pos;
spi-tegra114.c:256:	unsigned bits_per_word = t->bits_per_word;
spi-tegra114.c:260:	tspi->bytes_per_word = DIV_ROUND_UP(bits_per_word, 8);
spi-tegra114.c:263:		tspi->is_packed = 1;
spi-tegra114.c:264:		tspi->words_per_32bit = 32/bits_per_word;
spi-tegra114.c:266:		tspi->is_packed = 0;
spi-tegra114.c:267:		tspi->words_per_32bit = 1;
spi-tegra114.c:270:	if (tspi->is_packed) {
spi-tegra114.c:271:		max_len = min(remain_len, tspi->max_buf_size);
spi-tegra114.c:272:		tspi->curr_dma_words = max_len/tspi->bytes_per_word;
spi-tegra114.c:275:		max_word = (remain_len - 1) / tspi->bytes_per_word + 1;
spi-tegra114.c:276:		max_word = min(max_word, tspi->max_buf_size/4);
spi-tegra114.c:277:		tspi->curr_dma_words = max_word;
spi-tegra114.c:293:	u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
spi-tegra114.c:298:	if (tspi->is_packed) {
spi-tegra114.c:299:		fifo_words_left = tx_empty_count * tspi->words_per_32bit;
spi-tegra114.c:300:		written_words = min(fifo_words_left, tspi->curr_dma_words);
spi-tegra114.c:301:		nbytes = written_words * tspi->bytes_per_word;
spi-tegra114.c:306:			for (i = 0; (i < 4) && nbytes; i++, nbytes--)
spi-tegra114.c:311:		max_n_32bit = min(tspi->curr_dma_words,  tx_empty_count);
spi-tegra114.c:313:		nbytes = written_words * tspi->bytes_per_word;
spi-tegra114.c:317:			for (i = 0; nbytes && (i < tspi->bytes_per_word);
spi-tegra114.c:318:							i++, nbytes--)
spi-tegra114.c:323:	tspi->cur_tx_pos += written_words * tspi->bytes_per_word;
spi-tegra114.c:335:	u8 *rx_buf = (u8 *)t->rx_buf + tspi->cur_rx_pos;
spi-tegra114.c:339:	if (tspi->is_packed) {
spi-tegra114.c:340:		len = tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra114.c:344:			for (i = 0; len && (i < 4); i++, len--)
spi-tegra114.c:347:		tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra114.c:348:		read_words += tspi->curr_dma_words;
spi-tegra114.c:350:		u32 rx_mask = ((u32)1 << t->bits_per_word) - 1;
spi-tegra114.c:355:			for (i = 0; (i < tspi->bytes_per_word); i++)
spi-tegra114.c:358:		tspi->cur_rx_pos += rx_full_count * tspi->bytes_per_word;
spi-tegra114.c:368:	dma_sync_single_for_cpu(tspi->dev, tspi->tx_dma_phys,
spi-tegra114.c:369:				tspi->dma_buf_size, DMA_TO_DEVICE);
spi-tegra114.c:371:	if (tspi->is_packed) {
spi-tegra114.c:372:		unsigned len = tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra114.c:374:		memcpy(tspi->tx_dma_buf, t->tx_buf + tspi->cur_pos, len);
spi-tegra114.c:378:		u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
spi-tegra114.c:379:		unsigned consume = tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra114.c:381:		for (count = 0; count < tspi->curr_dma_words; count++) {
spi-tegra114.c:384:			for (i = 0; consume && (i < tspi->bytes_per_word);
spi-tegra114.c:385:							i++, consume--)
spi-tegra114.c:387:			tspi->tx_dma_buf[count] = x;
spi-tegra114.c:390:	tspi->cur_tx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra114.c:393:	dma_sync_single_for_device(tspi->dev, tspi->tx_dma_phys,
spi-tegra114.c:394:				tspi->dma_buf_size, DMA_TO_DEVICE);
spi-tegra114.c:401:	dma_sync_single_for_cpu(tspi->dev, tspi->rx_dma_phys,
spi-tegra114.c:402:		tspi->dma_buf_size, DMA_FROM_DEVICE);
spi-tegra114.c:404:	if (tspi->is_packed) {
spi-tegra114.c:405:		unsigned len = tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra114.c:407:		memcpy(t->rx_buf + tspi->cur_rx_pos, tspi->rx_dma_buf, len);
spi-tegra114.c:411:		unsigned char *rx_buf = t->rx_buf + tspi->cur_rx_pos;
spi-tegra114.c:412:		u32 rx_mask = ((u32)1 << t->bits_per_word) - 1;
spi-tegra114.c:414:		for (count = 0; count < tspi->curr_dma_words; count++) {
spi-tegra114.c:415:			u32 x = tspi->rx_dma_buf[count] & rx_mask;
spi-tegra114.c:417:			for (i = 0; (i < tspi->bytes_per_word); i++)
spi-tegra114.c:421:	tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
spi-tegra114.c:424:	dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
spi-tegra114.c:425:		tspi->dma_buf_size, DMA_FROM_DEVICE);
spi-tegra114.c:437:	reinit_completion(&tspi->tx_dma_complete);
spi-tegra114.c:438:	tspi->tx_dma_desc = dmaengine_prep_slave_single(tspi->tx_dma_chan,
spi-tegra114.c:439:				tspi->tx_dma_phys, len, DMA_MEM_TO_DEV,
spi-tegra114.c:441:	if (!tspi->tx_dma_desc) {
spi-tegra114.c:442:		dev_err(tspi->dev, "Not able to get desc for Tx\n");
spi-tegra114.c:443:		return -EIO;
spi-tegra114.c:446:	tspi->tx_dma_desc->callback = tegra_spi_dma_complete;
spi-tegra114.c:447:	tspi->tx_dma_desc->callback_param = &tspi->tx_dma_complete;
spi-tegra114.c:449:	dmaengine_submit(tspi->tx_dma_desc);
spi-tegra114.c:450:	dma_async_issue_pending(tspi->tx_dma_chan);
spi-tegra114.c:456:	reinit_completion(&tspi->rx_dma_complete);
spi-tegra114.c:457:	tspi->rx_dma_desc = dmaengine_prep_slave_single(tspi->rx_dma_chan,
spi-tegra114.c:458:				tspi->rx_dma_phys, len, DMA_DEV_TO_MEM,
spi-tegra114.c:460:	if (!tspi->rx_dma_desc) {
spi-tegra114.c:461:		dev_err(tspi->dev, "Not able to get desc for Rx\n");
spi-tegra114.c:462:		return -EIO;
spi-tegra114.c:465:	tspi->rx_dma_desc->callback = tegra_spi_dma_complete;
spi-tegra114.c:466:	tspi->rx_dma_desc->callback_param = &tspi->rx_dma_complete;
spi-tegra114.c:468:	dmaengine_submit(tspi->rx_dma_desc);
spi-tegra114.c:469:	dma_async_issue_pending(tspi->rx_dma_chan);
spi-tegra114.c:484:		dev_err(tspi->dev, "Rx/Tx fifo are not empty status 0x%08x\n",
spi-tegra114.c:486:		return -EIO;
spi-tegra114.c:489:	val = SPI_DMA_BLK_SET(tspi->curr_dma_words - 1);
spi-tegra114.c:492:	if (tspi->is_packed)
spi-tegra114.c:493:		len = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,
spi-tegra114.c:496:		len = tspi->curr_dma_words * 4;
spi-tegra114.c:506:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra114.c:509:	if (tspi->cur_direction & DATA_DIR_RX)
spi-tegra114.c:513:	tspi->dma_control_reg = val;
spi-tegra114.c:515:	if (tspi->cur_direction & DATA_DIR_TX) {
spi-tegra114.c:519:			dev_err(tspi->dev,
spi-tegra114.c:525:	if (tspi->cur_direction & DATA_DIR_RX) {
spi-tegra114.c:527:		dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
spi-tegra114.c:528:				tspi->dma_buf_size, DMA_FROM_DEVICE);
spi-tegra114.c:532:			dev_err(tspi->dev,
spi-tegra114.c:534:			if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra114.c:535:				dmaengine_terminate_all(tspi->tx_dma_chan);
spi-tegra114.c:539:	tspi->is_curr_dma_xfer = true;
spi-tegra114.c:540:	tspi->dma_control_reg = val;
spi-tegra114.c:553:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra114.c:556:		cur_words = tspi->curr_dma_words;
spi-tegra114.c:558:	val = SPI_DMA_BLK_SET(cur_words - 1);
spi-tegra114.c:562:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra114.c:565:	if (tspi->cur_direction & DATA_DIR_RX)
spi-tegra114.c:569:	tspi->dma_control_reg = val;
spi-tegra114.c:571:	tspi->is_curr_dma_xfer = false;
spi-tegra114.c:587:	dma_chan = dma_request_slave_channel_reason(tspi->dev,
spi-tegra114.c:591:		if (ret != -EPROBE_DEFER)
spi-tegra114.c:592:			dev_err(tspi->dev,
spi-tegra114.c:597:	dma_buf = dma_alloc_coherent(tspi->dev, tspi->dma_buf_size,
spi-tegra114.c:600:		dev_err(tspi->dev, " Not able to allocate the dma buffer\n");
spi-tegra114.c:602:		return -ENOMEM;
spi-tegra114.c:606:		dma_sconfig.src_addr = tspi->phys + SPI_RX_FIFO;
spi-tegra114.c:610:		dma_sconfig.dst_addr = tspi->phys + SPI_TX_FIFO;
spi-tegra114.c:619:		tspi->rx_dma_chan = dma_chan;
spi-tegra114.c:620:		tspi->rx_dma_buf = dma_buf;
spi-tegra114.c:621:		tspi->rx_dma_phys = dma_phys;
spi-tegra114.c:623:		tspi->tx_dma_chan = dma_chan;
spi-tegra114.c:624:		tspi->tx_dma_buf = dma_buf;
spi-tegra114.c:625:		tspi->tx_dma_phys = dma_phys;
spi-tegra114.c:630:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
spi-tegra114.c:643:		dma_buf = tspi->rx_dma_buf;
spi-tegra114.c:644:		dma_chan = tspi->rx_dma_chan;
spi-tegra114.c:645:		dma_phys = tspi->rx_dma_phys;
spi-tegra114.c:646:		tspi->rx_dma_chan = NULL;
spi-tegra114.c:647:		tspi->rx_dma_buf = NULL;
spi-tegra114.c:649:		dma_buf = tspi->tx_dma_buf;
spi-tegra114.c:650:		dma_chan = tspi->tx_dma_chan;
spi-tegra114.c:651:		dma_phys = tspi->tx_dma_phys;
spi-tegra114.c:652:		tspi->tx_dma_buf = NULL;
spi-tegra114.c:653:		tspi->tx_dma_chan = NULL;
spi-tegra114.c:658:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
spi-tegra114.c:665:	struct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);
spi-tegra114.c:666:	u32 speed = t->speed_hz;
spi-tegra114.c:667:	u8 bits_per_word = t->bits_per_word;
spi-tegra114.c:671:	if (speed != tspi->cur_speed) {
spi-tegra114.c:672:		clk_set_rate(tspi->clk, speed);
spi-tegra114.c:673:		tspi->cur_speed = speed;
spi-tegra114.c:676:	tspi->cur_spi = spi;
spi-tegra114.c:677:	tspi->cur_pos = 0;
spi-tegra114.c:678:	tspi->cur_rx_pos = 0;
spi-tegra114.c:679:	tspi->cur_tx_pos = 0;
spi-tegra114.c:680:	tspi->curr_xfer = t;
spi-tegra114.c:685:		command1 = tspi->def_command1_reg;
spi-tegra114.c:686:		command1 |= SPI_BIT_LENGTH(bits_per_word - 1);
spi-tegra114.c:689:		req_mode = spi->mode & 0x3;
spi-tegra114.c:699:		if (tspi->cs_control) {
spi-tegra114.c:700:			if (tspi->cs_control != spi)
spi-tegra114.c:702:			tspi->cs_control = NULL;
spi-tegra114.c:707:		if (spi->mode & SPI_CS_HIGH)
spi-tegra114.c:714:		command1 = tspi->command1_reg;
spi-tegra114.c:716:		command1 |= SPI_BIT_LENGTH(bits_per_word - 1);
spi-tegra114.c:725:	struct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);
spi-tegra114.c:731:	if (tspi->is_packed)
spi-tegra114.c:735:	tspi->cur_direction = 0;
spi-tegra114.c:736:	if (t->rx_buf) {
spi-tegra114.c:738:		tspi->cur_direction |= DATA_DIR_RX;
spi-tegra114.c:740:	if (t->tx_buf) {
spi-tegra114.c:742:		tspi->cur_direction |= DATA_DIR_TX;
spi-tegra114.c:744:	command1 |= SPI_CS_SEL(spi->chip_select);
spi-tegra114.c:746:	tspi->command1_reg = command1;
spi-tegra114.c:748:	dev_dbg(tspi->dev, "The def 0x%x and written 0x%x\n",
spi-tegra114.c:749:		tspi->def_command1_reg, (unsigned)command1);
spi-tegra114.c:760:	struct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);
spi-tegra114.c:765:	dev_dbg(&spi->dev, "setup %d bpw, %scpol, %scpha, %dHz\n",
spi-tegra114.c:766:		spi->bits_per_word,
spi-tegra114.c:767:		spi->mode & SPI_CPOL ? "" : "~",
spi-tegra114.c:768:		spi->mode & SPI_CPHA ? "" : "~",
spi-tegra114.c:769:		spi->max_speed_hz);
spi-tegra114.c:771:	ret = pm_runtime_get_sync(tspi->dev);
spi-tegra114.c:773:		dev_err(tspi->dev, "pm runtime failed, e = %d\n", ret);
spi-tegra114.c:777:	spin_lock_irqsave(&tspi->lock, flags);
spi-tegra114.c:778:	val = tspi->def_command1_reg;
spi-tegra114.c:779:	if (spi->mode & SPI_CS_HIGH)
spi-tegra114.c:780:		val &= ~SPI_CS_POL_INACTIVE(spi->chip_select);
spi-tegra114.c:782:		val |= SPI_CS_POL_INACTIVE(spi->chip_select);
spi-tegra114.c:783:	tspi->def_command1_reg = val;
spi-tegra114.c:784:	tegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);
spi-tegra114.c:785:	spin_unlock_irqrestore(&tspi->lock, flags);
spi-tegra114.c:787:	pm_runtime_put(tspi->dev);
spi-tegra114.c:808:	struct spi_device *spi = msg->spi;
spi-tegra114.c:812:	msg->status = 0;
spi-tegra114.c:813:	msg->actual_length = 0;
spi-tegra114.c:815:	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
spi-tegra114.c:818:		reinit_completion(&tspi->xfer_completion);
spi-tegra114.c:822:		if (!xfer->len) {
spi-tegra114.c:830:			dev_err(tspi->dev,
spi-tegra114.c:836:		ret = wait_for_completion_timeout(&tspi->xfer_completion,
spi-tegra114.c:839:			dev_err(tspi->dev,
spi-tegra114.c:841:			ret = -EIO;
spi-tegra114.c:845:		if (tspi->tx_status ||  tspi->rx_status) {
spi-tegra114.c:846:			dev_err(tspi->dev, "Error in Transfer\n");
spi-tegra114.c:847:			ret = -EIO;
spi-tegra114.c:850:		msg->actual_length += xfer->len;
spi-tegra114.c:854:			tegra_spi_writel(tspi, tspi->def_command1_reg,
spi-tegra114.c:856:			tegra_spi_transfer_delay(xfer->delay_usecs);
spi-tegra114.c:858:		} else if (list_is_last(&xfer->transfer_list,
spi-tegra114.c:859:					&msg->transfers)) {
spi-tegra114.c:860:			if (xfer->cs_change)
spi-tegra114.c:861:				tspi->cs_control = spi;
spi-tegra114.c:863:				tegra_spi_writel(tspi, tspi->def_command1_reg,
spi-tegra114.c:865:				tegra_spi_transfer_delay(xfer->delay_usecs);
spi-tegra114.c:867:		} else if (xfer->cs_change) {
spi-tegra114.c:868:			tegra_spi_writel(tspi, tspi->def_command1_reg,
spi-tegra114.c:870:			tegra_spi_transfer_delay(xfer->delay_usecs);
spi-tegra114.c:876:	msg->status = ret;
spi-tegra114.c:883:	struct spi_transfer *t = tspi->curr_xfer;
spi-tegra114.c:886:	spin_lock_irqsave(&tspi->lock, flags);
spi-tegra114.c:887:	if (tspi->tx_status ||  tspi->rx_status) {
spi-tegra114.c:888:		dev_err(tspi->dev, "CpuXfer ERROR bit set 0x%x\n",
spi-tegra114.c:889:			tspi->status_reg);
spi-tegra114.c:890:		dev_err(tspi->dev, "CpuXfer 0x%08x:0x%08x\n",
spi-tegra114.c:891:			tspi->command1_reg, tspi->dma_control_reg);
spi-tegra114.c:892:		reset_control_assert(tspi->rst);
spi-tegra114.c:894:		reset_control_deassert(tspi->rst);
spi-tegra114.c:895:		complete(&tspi->xfer_completion);
spi-tegra114.c:899:	if (tspi->cur_direction & DATA_DIR_RX)
spi-tegra114.c:902:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra114.c:903:		tspi->cur_pos = tspi->cur_tx_pos;
spi-tegra114.c:905:		tspi->cur_pos = tspi->cur_rx_pos;
spi-tegra114.c:907:	if (tspi->cur_pos == t->len) {
spi-tegra114.c:908:		complete(&tspi->xfer_completion);
spi-tegra114.c:912:	tegra_spi_calculate_curr_xfer_param(tspi->cur_spi, tspi, t);
spi-tegra114.c:915:	spin_unlock_irqrestore(&tspi->lock, flags);
spi-tegra114.c:921:	struct spi_transfer *t = tspi->curr_xfer;
spi-tegra114.c:928:	if (tspi->cur_direction & DATA_DIR_TX) {
spi-tegra114.c:929:		if (tspi->tx_status) {
spi-tegra114.c:930:			dmaengine_terminate_all(tspi->tx_dma_chan);
spi-tegra114.c:934:				&tspi->tx_dma_complete, SPI_DMA_TIMEOUT);
spi-tegra114.c:936:				dmaengine_terminate_all(tspi->tx_dma_chan);
spi-tegra114.c:937:				dev_err(tspi->dev, "TxDma Xfer failed\n");
spi-tegra114.c:943:	if (tspi->cur_direction & DATA_DIR_RX) {
spi-tegra114.c:944:		if (tspi->rx_status) {
spi-tegra114.c:945:			dmaengine_terminate_all(tspi->rx_dma_chan);
spi-tegra114.c:949:				&tspi->rx_dma_complete, SPI_DMA_TIMEOUT);
spi-tegra114.c:951:				dmaengine_terminate_all(tspi->rx_dma_chan);
spi-tegra114.c:952:				dev_err(tspi->dev, "RxDma Xfer failed\n");
spi-tegra114.c:958:	spin_lock_irqsave(&tspi->lock, flags);
spi-tegra114.c:960:		dev_err(tspi->dev, "DmaXfer: ERROR bit set 0x%x\n",
spi-tegra114.c:961:			tspi->status_reg);
spi-tegra114.c:962:		dev_err(tspi->dev, "DmaXfer 0x%08x:0x%08x\n",
spi-tegra114.c:963:			tspi->command1_reg, tspi->dma_control_reg);
spi-tegra114.c:964:		reset_control_assert(tspi->rst);
spi-tegra114.c:966:		reset_control_deassert(tspi->rst);
spi-tegra114.c:967:		complete(&tspi->xfer_completion);
spi-tegra114.c:968:		spin_unlock_irqrestore(&tspi->lock, flags);
spi-tegra114.c:972:	if (tspi->cur_direction & DATA_DIR_RX)
spi-tegra114.c:975:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra114.c:976:		tspi->cur_pos = tspi->cur_tx_pos;
spi-tegra114.c:978:		tspi->cur_pos = tspi->cur_rx_pos;
spi-tegra114.c:980:	if (tspi->cur_pos == t->len) {
spi-tegra114.c:981:		complete(&tspi->xfer_completion);
spi-tegra114.c:986:	total_fifo_words = tegra_spi_calculate_curr_xfer_param(tspi->cur_spi,
spi-tegra114.c:994:	spin_unlock_irqrestore(&tspi->lock, flags);
spi-tegra114.c:1002:	if (!tspi->is_curr_dma_xfer)
spi-tegra114.c:1011:	tspi->status_reg = tegra_spi_readl(tspi, SPI_FIFO_STATUS);
spi-tegra114.c:1012:	if (tspi->cur_direction & DATA_DIR_TX)
spi-tegra114.c:1013:		tspi->tx_status = tspi->status_reg &
spi-tegra114.c:1016:	if (tspi->cur_direction & DATA_DIR_RX)
spi-tegra114.c:1017:		tspi->rx_status = tspi->status_reg &
spi-tegra114.c:1025:	{ .compatible = "nvidia,tegra114-spi", },
spi-tegra114.c:1037:	master = spi_alloc_master(&pdev->dev, sizeof(*tspi));
spi-tegra114.c:1039:		dev_err(&pdev->dev, "master allocation failed\n");
spi-tegra114.c:1040:		return -ENOMEM;
spi-tegra114.c:1045:	if (of_property_read_u32(pdev->dev.of_node, "spi-max-frequency",
spi-tegra114.c:1046:				 &master->max_speed_hz))
spi-tegra114.c:1047:		master->max_speed_hz = 25000000; /* 25MHz */
spi-tegra114.c:1049:	/* the spi->mode bits understood by this driver: */
spi-tegra114.c:1050:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
spi-tegra114.c:1051:	master->setup = tegra_spi_setup;
spi-tegra114.c:1052:	master->transfer_one_message = tegra_spi_transfer_one_message;
spi-tegra114.c:1053:	master->num_chipselect = MAX_CHIP_SELECT;
spi-tegra114.c:1054:	master->auto_runtime_pm = true;
spi-tegra114.c:1056:	tspi->master = master;
spi-tegra114.c:1057:	tspi->dev = &pdev->dev;
spi-tegra114.c:1058:	spin_lock_init(&tspi->lock);
spi-tegra114.c:1061:	tspi->base = devm_ioremap_resource(&pdev->dev, r);
spi-tegra114.c:1062:	if (IS_ERR(tspi->base)) {
spi-tegra114.c:1063:		ret = PTR_ERR(tspi->base);
spi-tegra114.c:1066:	tspi->phys = r->start;
spi-tegra114.c:1069:	tspi->irq = spi_irq;
spi-tegra114.c:1071:	tspi->clk = devm_clk_get(&pdev->dev, "spi");
spi-tegra114.c:1072:	if (IS_ERR(tspi->clk)) {
spi-tegra114.c:1073:		dev_err(&pdev->dev, "can not get clock\n");
spi-tegra114.c:1074:		ret = PTR_ERR(tspi->clk);
spi-tegra114.c:1078:	tspi->rst = devm_reset_control_get(&pdev->dev, "spi");
spi-tegra114.c:1079:	if (IS_ERR(tspi->rst)) {
spi-tegra114.c:1080:		dev_err(&pdev->dev, "can not get reset\n");
spi-tegra114.c:1081:		ret = PTR_ERR(tspi->rst);
spi-tegra114.c:1085:	tspi->max_buf_size = SPI_FIFO_DEPTH << 2;
spi-tegra114.c:1086:	tspi->dma_buf_size = DEFAULT_SPI_DMA_BUF_LEN;
spi-tegra114.c:1094:	tspi->max_buf_size = tspi->dma_buf_size;
spi-tegra114.c:1095:	init_completion(&tspi->tx_dma_complete);
spi-tegra114.c:1096:	init_completion(&tspi->rx_dma_complete);
spi-tegra114.c:1098:	init_completion(&tspi->xfer_completion);
spi-tegra114.c:1100:	pm_runtime_enable(&pdev->dev);
spi-tegra114.c:1101:	if (!pm_runtime_enabled(&pdev->dev)) {
spi-tegra114.c:1102:		ret = tegra_spi_runtime_resume(&pdev->dev);
spi-tegra114.c:1107:	ret = pm_runtime_get_sync(&pdev->dev);
spi-tegra114.c:1109:		dev_err(&pdev->dev, "pm runtime get failed, e = %d\n", ret);
spi-tegra114.c:1113:	reset_control_assert(tspi->rst);
spi-tegra114.c:1115:	reset_control_deassert(tspi->rst);
spi-tegra114.c:1116:	tspi->def_command1_reg  = SPI_M_S;
spi-tegra114.c:1117:	tegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);
spi-tegra114.c:1118:	pm_runtime_put(&pdev->dev);
spi-tegra114.c:1119:	ret = request_threaded_irq(tspi->irq, tegra_spi_isr,
spi-tegra114.c:1121:				   dev_name(&pdev->dev), tspi);
spi-tegra114.c:1123:		dev_err(&pdev->dev, "Failed to register ISR for IRQ %d\n",
spi-tegra114.c:1124:			tspi->irq);
spi-tegra114.c:1128:	master->dev.of_node = pdev->dev.of_node;
spi-tegra114.c:1129:	ret = devm_spi_register_master(&pdev->dev, master);
spi-tegra114.c:1131:		dev_err(&pdev->dev, "can not register to master err %d\n", ret);
spi-tegra114.c:1139:	pm_runtime_disable(&pdev->dev);
spi-tegra114.c:1140:	if (!pm_runtime_status_suspended(&pdev->dev))
spi-tegra114.c:1141:		tegra_spi_runtime_suspend(&pdev->dev);
spi-tegra114.c:1155:	free_irq(tspi->irq, tspi);
spi-tegra114.c:1157:	if (tspi->tx_dma_chan)
spi-tegra114.c:1160:	if (tspi->rx_dma_chan)
spi-tegra114.c:1163:	pm_runtime_disable(&pdev->dev);
spi-tegra114.c:1164:	if (!pm_runtime_status_suspended(&pdev->dev))
spi-tegra114.c:1165:		tegra_spi_runtime_suspend(&pdev->dev);
spi-tegra114.c:1189:	tegra_spi_writel(tspi, tspi->command1_reg, SPI_COMMAND1);
spi-tegra114.c:1204:	clk_disable_unprepare(tspi->clk);
spi-tegra114.c:1214:	ret = clk_prepare_enable(tspi->clk);
spi-tegra114.c:1216:		dev_err(tspi->dev, "clk_prepare failed: %d\n", ret);
spi-tegra114.c:1229:		.name		= "spi-tegra114",
spi-tegra114.c:1238:MODULE_ALIAS("platform:spi-tegra114");
spi-xilinx.c:9: * 2002-2007 (c) MontaVista Software, Inc.
spi-xilinx.c:58:#define XSPI_SSR_OFFSET		0x70	/* 32-bit Slave Select Register */
spi-xilinx.c:122:	if (!xspi->tx_ptr) {
spi-xilinx.c:123:		xspi->write_fn(0, xspi->regs + XSPI_TXD_OFFSET);
spi-xilinx.c:127:	switch (xspi->bytes_per_word) {
spi-xilinx.c:129:		data = *(u8 *)(xspi->tx_ptr);
spi-xilinx.c:132:		data = *(u16 *)(xspi->tx_ptr);
spi-xilinx.c:135:		data = *(u32 *)(xspi->tx_ptr);
spi-xilinx.c:139:	xspi->write_fn(data, xspi->regs + XSPI_TXD_OFFSET);
spi-xilinx.c:140:	xspi->tx_ptr += xspi->bytes_per_word;
spi-xilinx.c:145:	u32 data = xspi->read_fn(xspi->regs + XSPI_RXD_OFFSET);
spi-xilinx.c:147:	if (!xspi->rx_ptr)
spi-xilinx.c:150:	switch (xspi->bytes_per_word) {
spi-xilinx.c:152:		*(u8 *)(xspi->rx_ptr) = data;
spi-xilinx.c:155:		*(u16 *)(xspi->rx_ptr) = data;
spi-xilinx.c:158:		*(u32 *)(xspi->rx_ptr) = data;
spi-xilinx.c:162:	xspi->rx_ptr += xspi->bytes_per_word;
spi-xilinx.c:167:	void __iomem *regs_base = xspi->regs;
spi-xilinx.c:170:	xspi->write_fn(XIPIF_V123B_RESET_MASK,
spi-xilinx.c:175:	xspi->write_fn(XSPI_INTR_TX_EMPTY,
spi-xilinx.c:178:	xspi->write_fn(0, regs_base + XIPIF_V123B_DGIER_OFFSET);
spi-xilinx.c:180:	xspi->write_fn(0xffff, regs_base + XSPI_SSR_OFFSET);
spi-xilinx.c:183:	xspi->write_fn(XSPI_CR_MANUAL_SSELECT |	XSPI_CR_MASTER_MODE |
spi-xilinx.c:190:	struct xilinx_spi *xspi = spi_master_get_devdata(spi->master);
spi-xilinx.c:196:		xspi->write_fn(xspi->cs_inactive, xspi->regs + XSPI_SSR_OFFSET);
spi-xilinx.c:201:	cr = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET)	& ~XSPI_CR_MODE_MASK;
spi-xilinx.c:202:	if (spi->mode & SPI_CPHA)
spi-xilinx.c:204:	if (spi->mode & SPI_CPOL)
spi-xilinx.c:206:	if (spi->mode & SPI_LSB_FIRST)
spi-xilinx.c:208:	if (spi->mode & SPI_LOOP)
spi-xilinx.c:210:	xspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);
spi-xilinx.c:212:	/* We do not check spi->max_speed_hz here as the SPI clock
spi-xilinx.c:217:	cs = xspi->cs_inactive;
spi-xilinx.c:218:	cs ^= BIT(spi->chip_select);
spi-xilinx.c:221:	xspi->write_fn(cs, xspi->regs + XSPI_SSR_OFFSET);
spi-xilinx.c:230:	struct xilinx_spi *xspi = spi_master_get_devdata(spi->master);
spi-xilinx.c:232:	if (spi->mode & SPI_CS_HIGH)
spi-xilinx.c:233:		xspi->cs_inactive &= ~BIT(spi->chip_select);
spi-xilinx.c:235:		xspi->cs_inactive |= BIT(spi->chip_select);
spi-xilinx.c:242:	struct xilinx_spi *xspi = spi_master_get_devdata(spi->master);
spi-xilinx.c:249:	xspi->tx_ptr = t->tx_buf;
spi-xilinx.c:250:	xspi->rx_ptr = t->rx_buf;
spi-xilinx.c:251:	remaining_words = t->len / xspi->bytes_per_word;
spi-xilinx.c:253:	if (xspi->irq >= 0 &&  remaining_words > xspi->buffer_size) {
spi-xilinx.c:257:		cr = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET);
spi-xilinx.c:258:		xspi->write_fn(cr | XSPI_CR_TRANS_INHIBIT,
spi-xilinx.c:259:			       xspi->regs + XSPI_CR_OFFSET);
spi-xilinx.c:261:		isr = xspi->read_fn(xspi->regs + XIPIF_V123B_IISR_OFFSET);
spi-xilinx.c:263:			xspi->write_fn(isr,
spi-xilinx.c:264:				       xspi->regs + XIPIF_V123B_IISR_OFFSET);
spi-xilinx.c:266:		xspi->write_fn(XIPIF_V123B_GINTR_ENABLE,
spi-xilinx.c:267:				xspi->regs + XIPIF_V123B_DGIER_OFFSET);
spi-xilinx.c:268:		reinit_completion(&xspi->done);
spi-xilinx.c:276:		n_words = min(remaining_words, xspi->buffer_size);
spi-xilinx.c:279:		while (tx_words--)
spi-xilinx.c:287:			xspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);
spi-xilinx.c:288:			wait_for_completion(&xspi->done);
spi-xilinx.c:295:			xspi->write_fn(cr | XSPI_CR_TRANS_INHIBIT,
spi-xilinx.c:296:				       xspi->regs + XSPI_CR_OFFSET);
spi-xilinx.c:299:			sr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);
spi-xilinx.c:305:			if (rx_words == n_words && !(stalled--) &&
spi-xilinx.c:308:				dev_err(&spi->dev,
spi-xilinx.c:311:				return -EIO;
spi-xilinx.c:316:				rx_words--;
spi-xilinx.c:320:			sr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);
spi-xilinx.c:323:				rx_words--;
spi-xilinx.c:327:		remaining_words -= n_words;
spi-xilinx.c:331:		xspi->write_fn(0, xspi->regs + XIPIF_V123B_DGIER_OFFSET);
spi-xilinx.c:332:		xspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);
spi-xilinx.c:335:	return t->len;
spi-xilinx.c:350:	ipif_isr = xspi->read_fn(xspi->regs + XIPIF_V123B_IISR_OFFSET);
spi-xilinx.c:351:	xspi->write_fn(ipif_isr, xspi->regs + XIPIF_V123B_IISR_OFFSET);
spi-xilinx.c:354:		complete(&xspi->done);
spi-xilinx.c:369:	xspi->write_fn(XIPIF_V123B_RESET_MASK,
spi-xilinx.c:370:		xspi->regs + XIPIF_V123B_RESETR_OFFSET);
spi-xilinx.c:374:		xspi->write_fn(0, xspi->regs + XSPI_TXD_OFFSET);
spi-xilinx.c:375:		sr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);
spi-xilinx.c:383:	{ .compatible = "xlnx,xps-spi-2.00.a", },
spi-xilinx.c:384:	{ .compatible = "xlnx,xps-spi-2.00.b", },
spi-xilinx.c:399:	pdata = dev_get_platdata(&pdev->dev);
spi-xilinx.c:401:		num_cs = pdata->num_chipselect;
spi-xilinx.c:402:		bits_per_word = pdata->bits_per_word;
spi-xilinx.c:404:		of_property_read_u32(pdev->dev.of_node, "xlnx,num-ss-bits",
spi-xilinx.c:409:		dev_err(&pdev->dev,
spi-xilinx.c:411:		return -EINVAL;
spi-xilinx.c:415:		dev_err(&pdev->dev, "Invalid number of spi slaves\n");
spi-xilinx.c:416:		return -EINVAL;
spi-xilinx.c:419:	master = spi_alloc_master(&pdev->dev, sizeof(struct xilinx_spi));
spi-xilinx.c:421:		return -ENODEV;
spi-xilinx.c:423:	/* the spi->mode bits understood by this driver: */
spi-xilinx.c:424:	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST | SPI_LOOP |
spi-xilinx.c:428:	xspi->cs_inactive = 0xffffffff;
spi-xilinx.c:429:	xspi->bitbang.master = master;
spi-xilinx.c:430:	xspi->bitbang.chipselect = xilinx_spi_chipselect;
spi-xilinx.c:431:	xspi->bitbang.setup_transfer = xilinx_spi_setup_transfer;
spi-xilinx.c:432:	xspi->bitbang.txrx_bufs = xilinx_spi_txrx_bufs;
spi-xilinx.c:433:	init_completion(&xspi->done);
spi-xilinx.c:436:	xspi->regs = devm_ioremap_resource(&pdev->dev, res);
spi-xilinx.c:437:	if (IS_ERR(xspi->regs)) {
spi-xilinx.c:438:		ret = PTR_ERR(xspi->regs);
spi-xilinx.c:442:	master->bus_num = pdev->id;
spi-xilinx.c:443:	master->num_chipselect = num_cs;
spi-xilinx.c:444:	master->dev.of_node = pdev->dev.of_node;
spi-xilinx.c:453:	xspi->read_fn = xspi_read32;
spi-xilinx.c:454:	xspi->write_fn = xspi_write32;
spi-xilinx.c:456:	xspi->write_fn(XSPI_CR_LOOP, xspi->regs + XSPI_CR_OFFSET);
spi-xilinx.c:457:	tmp = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET);
spi-xilinx.c:460:		xspi->read_fn = xspi_read32_be;
spi-xilinx.c:461:		xspi->write_fn = xspi_write32_be;
spi-xilinx.c:464:	master->bits_per_word_mask = SPI_BPW_MASK(bits_per_word);
spi-xilinx.c:465:	xspi->bytes_per_word = bits_per_word / 8;
spi-xilinx.c:466:	xspi->buffer_size = xilinx_spi_find_buffer_size(xspi);
spi-xilinx.c:468:	xspi->irq = platform_get_irq(pdev, 0);
spi-xilinx.c:469:	if (xspi->irq >= 0) {
spi-xilinx.c:471:		ret = devm_request_irq(&pdev->dev, xspi->irq, xilinx_spi_irq, 0,
spi-xilinx.c:472:				dev_name(&pdev->dev), xspi);
spi-xilinx.c:480:	ret = spi_bitbang_start(&xspi->bitbang);
spi-xilinx.c:482:		dev_err(&pdev->dev, "spi_bitbang_start FAILED\n");
spi-xilinx.c:486:	dev_info(&pdev->dev, "at 0x%08llX mapped to 0x%p, irq=%d\n",
spi-xilinx.c:487:		(unsigned long long)res->start, xspi->regs, xspi->irq);
spi-xilinx.c:490:		for (i = 0; i < pdata->num_devices; i++)
spi-xilinx.c:491:			spi_new_device(master, pdata->devices + i);
spi-xilinx.c:507:	void __iomem *regs_base = xspi->regs;
spi-xilinx.c:509:	spi_bitbang_stop(&xspi->bitbang);
spi-xilinx.c:512:	xspi->write_fn(0, regs_base + XIPIF_V123B_IIER_OFFSET);
spi-xilinx.c:514:	xspi->write_fn(0, regs_base + XIPIF_V123B_DGIER_OFFSET);
spi-xilinx.c:516:	spi_master_put(xspi->bitbang.master);
spi-st-ssc4.c:2: *  Copyright (c) 2008-2014 STMicroelectronics Limited
spi-st-ssc4.c:81:	return clk_prepare_enable(spi_st->clk);
spi-st-ssc4.c:94:	clk_disable_unprepare(spi_st->clk);
spi-st-ssc4.c:103:	if (spi_st->words_remaining > FIFO_SIZE)
spi-st-ssc4.c:106:		count = spi_st->words_remaining;
spi-st-ssc4.c:109:		if (spi_st->tx_ptr) {
spi-st-ssc4.c:110:			if (spi_st->bytes_per_word == 1) {
spi-st-ssc4.c:111:				word = *spi_st->tx_ptr++;
spi-st-ssc4.c:113:				word = *spi_st->tx_ptr++;
spi-st-ssc4.c:114:				word = *spi_st->tx_ptr++ | (word << 8);
spi-st-ssc4.c:117:		writel_relaxed(word, spi_st->base + SSC_TBUF);
spi-st-ssc4.c:127:	if (spi_st->words_remaining > FIFO_SIZE)
spi-st-ssc4.c:130:		count = spi_st->words_remaining;
spi-st-ssc4.c:133:		word = readl_relaxed(spi_st->base + SSC_RBUF);
spi-st-ssc4.c:135:		if (spi_st->rx_ptr) {
spi-st-ssc4.c:136:			if (spi_st->bytes_per_word == 1) {
spi-st-ssc4.c:137:				*spi_st->rx_ptr++ = (uint8_t)word;
spi-st-ssc4.c:139:				*spi_st->rx_ptr++ = (word >> 8);
spi-st-ssc4.c:140:				*spi_st->rx_ptr++ = word & 0xff;
spi-st-ssc4.c:144:	spi_st->words_remaining -= count;
spi-st-ssc4.c:154:	spi_st->tx_ptr = t->tx_buf;
spi-st-ssc4.c:155:	spi_st->rx_ptr = t->rx_buf;
spi-st-ssc4.c:157:	if (spi->bits_per_word > 8) {
spi-st-ssc4.c:159:		 * Anything greater than 8 bits-per-word requires 2
spi-st-ssc4.c:160:		 * bytes-per-word in the RX/TX buffers
spi-st-ssc4.c:162:		spi_st->bytes_per_word = 2;
spi-st-ssc4.c:163:		spi_st->words_remaining = t->len / 2;
spi-st-ssc4.c:165:	} else if (spi->bits_per_word == 8 && !(t->len & 0x1)) {
spi-st-ssc4.c:167:		 * If transfer is even-length, and 8 bits-per-word, then
spi-st-ssc4.c:168:		 * implement as half-length 16 bits-per-word transfer
spi-st-ssc4.c:170:		spi_st->bytes_per_word = 2;
spi-st-ssc4.c:171:		spi_st->words_remaining = t->len / 2;
spi-st-ssc4.c:173:		/* Set SSC_CTL to 16 bits-per-word */
spi-st-ssc4.c:174:		ctl = readl_relaxed(spi_st->base + SSC_CTL);
spi-st-ssc4.c:175:		writel_relaxed((ctl | 0xf), spi_st->base + SSC_CTL);
spi-st-ssc4.c:177:		readl_relaxed(spi_st->base + SSC_RBUF);
spi-st-ssc4.c:180:		spi_st->bytes_per_word = 1;
spi-st-ssc4.c:181:		spi_st->words_remaining = t->len;
spi-st-ssc4.c:184:	reinit_completion(&spi_st->done);
spi-st-ssc4.c:188:	writel_relaxed(SSC_IEN_TEEN, spi_st->base + SSC_IEN);
spi-st-ssc4.c:191:	wait_for_completion(&spi_st->done);
spi-st-ssc4.c:195:		writel_relaxed(ctl, spi_st->base + SSC_CTL);
spi-st-ssc4.c:197:	spi_finalize_current_transfer(spi->master);
spi-st-ssc4.c:199:	return t->len;
spi-st-ssc4.c:204:	int cs = spi->cs_gpio;
spi-st-ssc4.c:207:		devm_gpio_free(&spi->dev, cs);
spi-st-ssc4.c:210:/* the spi->mode bits understood by this driver: */
spi-st-ssc4.c:214:	struct spi_st *spi_st = spi_master_get_devdata(spi->master);
spi-st-ssc4.c:216:	u32 hz = spi->max_speed_hz;
spi-st-ssc4.c:217:	int cs = spi->cs_gpio;
spi-st-ssc4.c:221:		dev_err(&spi->dev, "max_speed_hz unspecified\n");
spi-st-ssc4.c:222:		return -EINVAL;
spi-st-ssc4.c:226:		dev_err(&spi->dev, "%d is not a valid gpio\n", cs);
spi-st-ssc4.c:227:		return -EINVAL;
spi-st-ssc4.c:230:	if (devm_gpio_request(&spi->dev, cs, dev_name(&spi->dev))) {
spi-st-ssc4.c:231:		dev_err(&spi->dev, "could not request gpio:%d\n", cs);
spi-st-ssc4.c:232:		return -EINVAL;
spi-st-ssc4.c:235:	ret = gpio_direction_output(cs, spi->mode & SPI_CS_HIGH);
spi-st-ssc4.c:239:	spi_st_clk = clk_get_rate(spi_st->clk);
spi-st-ssc4.c:244:		dev_err(&spi->dev,
spi-st-ssc4.c:246:		return -EINVAL;
spi-st-ssc4.c:249:	spi_st->baud = spi_st_clk / (2 * sscbrg);
spi-st-ssc4.c:250:	if (sscbrg == BIT(16)) /* 16-bit counter wraps */
spi-st-ssc4.c:253:	writel_relaxed(sscbrg, spi_st->base + SSC_BRG);
spi-st-ssc4.c:255:	dev_dbg(&spi->dev,
spi-st-ssc4.c:257:		hz, spi_st->baud, sscbrg);
spi-st-ssc4.c:260:	 var = readl_relaxed(spi_st->base + SSC_CTL);
spi-st-ssc4.c:263:	 if (spi->mode & SPI_CPOL)
spi-st-ssc4.c:268:	 if (spi->mode & SPI_CPHA)
spi-st-ssc4.c:273:	 if ((spi->mode & SPI_LSB_FIRST) == 0)
spi-st-ssc4.c:278:	 if (spi->mode & SPI_LOOP)
spi-st-ssc4.c:284:	 var |= (spi->bits_per_word - 1);
spi-st-ssc4.c:289:	 writel_relaxed(var, spi_st->base + SSC_CTL);
spi-st-ssc4.c:292:	 readl_relaxed(spi_st->base + SSC_RBUF);
spi-st-ssc4.c:306:	if (spi_st->words_remaining) {
spi-st-ssc4.c:310:		writel_relaxed(0x0, spi_st->base + SSC_IEN);
spi-st-ssc4.c:313:		 * before re-enabling interrupt
spi-st-ssc4.c:315:		readl(spi_st->base + SSC_IEN);
spi-st-ssc4.c:316:		complete(&spi_st->done);
spi-st-ssc4.c:324:	struct device_node *np = pdev->dev.of_node;
spi-st-ssc4.c:331:	master = spi_alloc_master(&pdev->dev, sizeof(*spi_st));
spi-st-ssc4.c:333:		return -ENOMEM;
spi-st-ssc4.c:335:	master->dev.of_node		= np;
spi-st-ssc4.c:336:	master->mode_bits		= MODEBITS;
spi-st-ssc4.c:337:	master->setup			= spi_st_setup;
spi-st-ssc4.c:338:	master->cleanup			= spi_st_cleanup;
spi-st-ssc4.c:339:	master->transfer_one		= spi_st_transfer_one;
spi-st-ssc4.c:340:	master->bits_per_word_mask	= SPI_BPW_MASK(8) | SPI_BPW_MASK(16);
spi-st-ssc4.c:341:	master->auto_runtime_pm		= true;
spi-st-ssc4.c:342:	master->bus_num			= pdev->id;
spi-st-ssc4.c:345:	spi_st->clk = devm_clk_get(&pdev->dev, "ssc");
spi-st-ssc4.c:346:	if (IS_ERR(spi_st->clk)) {
spi-st-ssc4.c:347:		dev_err(&pdev->dev, "Unable to request clock\n");
spi-st-ssc4.c:348:		return PTR_ERR(spi_st->clk);
spi-st-ssc4.c:355:	init_completion(&spi_st->done);
spi-st-ssc4.c:359:	spi_st->base = devm_ioremap_resource(&pdev->dev, res);
spi-st-ssc4.c:360:	if (IS_ERR(spi_st->base)) {
spi-st-ssc4.c:361:		ret = PTR_ERR(spi_st->base);
spi-st-ssc4.c:366:	writel_relaxed(0x0, spi_st->base + SSC_I2C);
spi-st-ssc4.c:367:	var = readw_relaxed(spi_st->base + SSC_CTL);
spi-st-ssc4.c:369:	writel_relaxed(var, spi_st->base + SSC_CTL);
spi-st-ssc4.c:372:	var = readl_relaxed(spi_st->base + SSC_CTL);
spi-st-ssc4.c:374:	writel_relaxed(var, spi_st->base + SSC_CTL);
spi-st-ssc4.c:377:	var = readl_relaxed(spi_st->base + SSC_CTL);
spi-st-ssc4.c:379:	writel_relaxed(var, spi_st->base + SSC_CTL);
spi-st-ssc4.c:383:		dev_err(&pdev->dev, "IRQ missing or invalid\n");
spi-st-ssc4.c:384:		ret = -EINVAL;
spi-st-ssc4.c:388:	ret = devm_request_irq(&pdev->dev, irq, spi_st_irq, 0,
spi-st-ssc4.c:389:			       pdev->name, spi_st);
spi-st-ssc4.c:391:		dev_err(&pdev->dev, "Failed to request irq %d\n", irq);
spi-st-ssc4.c:396:	pm_runtime_set_active(&pdev->dev);
spi-st-ssc4.c:397:	pm_runtime_enable(&pdev->dev);
spi-st-ssc4.c:401:	ret = devm_spi_register_master(&pdev->dev, master);
spi-st-ssc4.c:403:		dev_err(&pdev->dev, "Failed to register master\n");
spi-st-ssc4.c:422:	pinctrl_pm_select_sleep_state(&pdev->dev);
spi-st-ssc4.c:433:	writel_relaxed(0, spi_st->base + SSC_IEN);
spi-st-ssc4.c:486:	{ .compatible = "st,comms-ssc4-spi", },
spi-st-ssc4.c:493:		.name = "spi-st",
spi-falcon.c:19:#define DRV_NAME		"sflash-falcon"
spi-falcon.c:54:/* SCK Rise-edge Position */
spi-falcon.c:60:/* SCK Fall-edge Position */
spi-falcon.c:84:/* 8-bit multiplexed */
spi-falcon.c:102:	struct device *dev = &spi->dev;
spi-falcon.c:103:	struct falcon_sflash *priv = spi_master_get_devdata(spi->master);
spi-falcon.c:104:	const u8 *txp = t->tx_buf;
spi-falcon.c:105:	u8 *rxp = t->rx_buf;
spi-falcon.c:106:	unsigned int bytelen = ((8 * t->len + 7) / 8);
spi-falcon.c:127:					return -ENODATA;
spi-falcon.c:136:				priv->sfcmd = ((spi->chip_select
spi-falcon.c:139:				priv->sfcmd |= SFCMD_KEEP_CS_KEEP_SELECTED;
spi-falcon.c:140:				priv->sfcmd |= *txp;
spi-falcon.c:142:				bytelen--;
spi-falcon.c:152:						priv->sfcmd & SFCMD_OPC_MASK);
spi-falcon.c:193:				bytelen--;
spi-falcon.c:195:			priv->sfcmd &= ~(SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK);
spi-falcon.c:196:			priv->sfcmd |= (alen << SFCMD_ALEN_OFFSET) |
spi-falcon.c:202:				priv->sfcmd & SFCMD_OPC_MASK,
spi-falcon.c:223:			priv->sfcmd |= SFCMD_DIR_WRITE;
spi-falcon.c:227:				if (bytelen--)
spi-falcon.c:231:					priv->sfcmd &=
spi-falcon.c:236:					ltq_ebu_w32(priv->sfcmd
spi-falcon.c:241:					priv->sfcmd &= ~(SFCMD_ALEN_MASK
spi-falcon.c:251:			priv->sfcmd &= ~SFCMD_DIR_WRITE;
spi-falcon.c:255:					priv->sfcmd &=
spi-falcon.c:259:				bytelen -= len;
spi-falcon.c:260:				ltq_ebu_w32(priv->sfcmd
spi-falcon.c:262:				priv->sfcmd &= ~(SFCMD_ALEN_MASK
spi-falcon.c:272:						return -EBADE;
spi-falcon.c:280:					len--;
spi-falcon.c:288:			priv->sfcmd &= ~SFCMD_KEEP_CS_KEEP_SELECTED;
spi-falcon.c:289:			ltq_ebu_w32(priv->sfcmd | (0 << SFCMD_DLEN_OFFSET),
spi-falcon.c:296:				return -EBADE;
spi-falcon.c:316:	if (spi->max_speed_hz >= CLOCK_100M) {
spi-falcon.c:326:			if (CLOCK_50M / i <= spi->max_speed_hz)
spi-falcon.c:348:	/* set address wrap around to maximum for 24-bit addresses */
spi-falcon.c:365:	priv->sfcmd = 0;
spi-falcon.c:366:	m->actual_length = 0;
spi-falcon.c:369:	list_for_each_entry(t, &m->transfers, transfer_list) {
spi-falcon.c:370:		if (list_is_last(&t->transfer_list, &m->transfers))
spi-falcon.c:374:		ret = falcon_sflash_xfer(m->spi, t, spi_flags);
spi-falcon.c:380:		m->actual_length += t->len;
spi-falcon.c:382:		WARN_ON(t->delay_usecs || t->cs_change);
spi-falcon.c:386:	m->status = ret;
spi-falcon.c:399:		dev_err(&pdev->dev, "invalid bootstrap options\n");
spi-falcon.c:400:		return -ENODEV;
spi-falcon.c:403:	master = spi_alloc_master(&pdev->dev, sizeof(*priv));
spi-falcon.c:405:		return -ENOMEM;
spi-falcon.c:408:	priv->master = master;
spi-falcon.c:410:	master->mode_bits = SPI_MODE_3;
spi-falcon.c:411:	master->flags = SPI_MASTER_HALF_DUPLEX;
spi-falcon.c:412:	master->setup = falcon_sflash_setup;
spi-falcon.c:413:	master->transfer_one_message = falcon_sflash_xfer_one;
spi-falcon.c:414:	master->dev.of_node = pdev->dev.of_node;
spi-falcon.c:416:	ret = devm_spi_register_master(&pdev->dev, master);
spi-falcon.c:423:	{ .compatible = "lantiq,sflash-falcon" },
